; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\projects\PDFLibNet\libAFPDFLib\AFPDFDoc.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat


PUBLIC	??_R4AFPDFDoc@@6B@				; AFPDFDoc::`RTTI Complete Object Locator'
PUBLIC	??_R3AFPDFDoc@@8				; AFPDFDoc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AFPDFDoc@@8				; AFPDFDoc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AFPDFDoc@@8			; AFPDFDoc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVAFPDFDoc@@@8				; AFPDFDoc `RTTI Type Descriptor'
PUBLIC	__tcsrchr
PUBLIC	?_tcsrchr@@YAPADPADI@Z				; _tcsrchr
PUBLIC	??0?$DynArray@PAX@@QAE@XZ			; DynArray<void *>::DynArray<void *>
PUBLIC	??0Queue@@QAE@I@Z				; Queue::Queue
PUBLIC	??0?$DynArray@VCPDFSearchResult@@@@QAE@XZ	; DynArray<CPDFSearchResult>::DynArray<CPDFSearchResult>
PUBLIC	??1?$DynArray@PAX@@QAE@XZ			; DynArray<void *>::~DynArray<void *>
PUBLIC	??1Queue@@QAE@XZ				; Queue::~Queue
PUBLIC	??1?$DynArray@VCPDFSearchResult@@@@QAE@XZ	; DynArray<CPDFSearchResult>::~DynArray<CPDFSearchResult>
PUBLIC	??_GAFPDFDoc@@UAEPAXI@Z				; AFPDFDoc::`scalar deleting destructor'
PUBLIC	?shutdown@Queue@@QAEXXZ				; Queue::shutdown
PUBLIC	?initNull@Object@@QAEPAV1@XZ			; Object::initNull
PUBLIC	?getErrorCode@PDFDoc@@QAEHXZ			; PDFDoc::getErrorCode
PUBLIC	?getOutline@PDFDoc@@QAEPAVOutline@@XZ		; PDFDoc::getOutline
PUBLIC	?getRenderDPI@PageMemory@@QAENXZ		; PageMemory::getRenderDPI
PUBLIC	??_GAuxOutputDev@@QAEPAXI@Z			; AuxOutputDev::`scalar deleting destructor'
PUBLIC	??0threadParam@@QAE@PAVAFPDFDoc@@H@Z		; threadParam::threadParam
PUBLIC	?enterlock@Queue@@QAEXXZ			; Queue::enterlock
PUBLIC	?unlock@Queue@@QAEXXZ				; Queue::unlock
PUBLIC	?clearall@Queue@@QAE_NP6AXPAX@Z@Z		; Queue::clearall
PUBLIC	?AddTail@Queue@@QAEHPAX@Z			; Queue::AddTail
PUBLIC	??0threadParamThumb@@QAE@PAUHDC__@@PAVSplashOutputDev@@PAVPDFDoc@@HPAVQueue@@PAX@Z ; threadParamThumb::threadParamThumb
PUBLIC	??_GPageMemory@@QAEPAXI@Z			; PageMemory::`scalar deleting destructor'
PUBLIC	??A?$DynArray@PAX@@QAEAAPAXI@Z			; DynArray<void *>::operator[]
PUBLIC	?Add@?$DynArray@PAX@@QAEXABQAX@Z		; DynArray<void *>::Add
PUBLIC	?GetSize@?$DynArray@PAX@@QAEIXZ			; DynArray<void *>::GetSize
PUBLIC	?GetCount@?$DynArray@PAX@@QAEIXZ		; DynArray<void *>::GetCount
PUBLIC	?RemoveHead@Queue@@QAEPAXXZ			; Queue::RemoveHead
PUBLIC	?Clear@?$DynArray@PAX@@QAEXXZ			; DynArray<void *>::Clear
PUBLIC	?Delete@?$DynArray@PAX@@QAEXI@Z			; DynArray<void *>::Delete
PUBLIC	?isOk@Catalog@@QAEHXZ				; Catalog::isOk
PUBLIC	?isOk@Page@@QAEHXZ				; Page::isOk
PUBLIC	?getDefCTM@OutputDev@@QAEPANXZ			; OutputDev::getDefCTM
PUBLIC	?getDefICTM@OutputDev@@QAEPANXZ			; OutputDev::getDefICTM
PUBLIC	?NotEmpty@CRect@@QAE_NXZ			; CRect::NotEmpty
PUBLIC	?setSize@AuxOutputDev@@QAEXNN@Z			; AuxOutputDev::setSize
PUBLIC	?setPixmap@AuxOutputDev@@QAEXPAUfz_pixmap_s@@@Z	; AuxOutputDev::setPixmap
PUBLIC	??_GmupdfEngine@@QAEPAXI@Z			; mupdfEngine::`scalar deleting destructor'
PUBLIC	?OffsetRect@CRect@@QAEXHH@Z			; CRect::OffsetRect
PUBLIC	?InflateRect@CRect@@QAEXHH@Z			; CRect::InflateRect
PUBLIC	?DeflateRect@CRect@@QAEXHH@Z			; CRect::DeflateRect
PUBLIC	??0CRect@@QAE@XZ				; CRect::CRect
PUBLIC	??A?$DynArray@VCPDFSearchResult@@@@QAEAAVCPDFSearchResult@@I@Z ; DynArray<CPDFSearchResult>::operator[]
PUBLIC	?isOk@PDFDoc@@QAEHXZ				; PDFDoc::isOk
PUBLIC	?getItems@Outline@@QAEPAVGList@@XZ		; Outline::getItems
PUBLIC	?getLength@GList@@QAEHXZ			; GList::getLength
PUBLIC	?get@GList@@QAEPAXH@Z				; GList::get
PUBLIC	?findDest@PDFDoc@@QAEPAVLinkDest@@PAVGString@@@Z ; PDFDoc::findDest
PUBLIC	?isOk@LinkDest@@QAEHXZ				; LinkDest::isOk
PUBLIC	?ToArray@?$DynArray@VCPDFSearchResult@@@@QAEPAVCPDFSearchResult@@XZ ; DynArray<CPDFSearchResult>::ToArray
PUBLIC	?okToPrint@PDFDoc@@QAEHH@Z			; PDFDoc::okToPrint
PUBLIC	?getNumPages@Catalog@@QAEHXZ			; Catalog::getNumPages
PUBLIC	?getNumPages@PDFDoc@@QAEHXZ			; PDFDoc::getNumPages
PUBLIC	?isOk@TextOutputDev@@UAEHXZ			; TextOutputDev::isOk
PUBLIC	?Add@?$DynArray@VCPDFSearchResult@@@@QAEXABVCPDFSearchResult@@@Z ; DynArray<CPDFSearchResult>::Add
PUBLIC	?GetSize@?$DynArray@VCPDFSearchResult@@@@QAEIXZ	; DynArray<CPDFSearchResult>::GetSize
PUBLIC	?GetCount@?$DynArray@VCPDFSearchResult@@@@QAEIXZ ; DynArray<CPDFSearchResult>::GetCount
PUBLIC	?Clear@?$DynArray@VCPDFSearchResult@@@@QAEXXZ	; DynArray<CPDFSearchResult>::Clear
PUBLIC	?RemoveAll@?$DynArray@VCPDFSearchResult@@@@QAEXXZ ; DynArray<CPDFSearchResult>::RemoveAll
PUBLIC	?getXRef@PDFDoc@@QAEPAVXRef@@XZ			; PDFDoc::getXRef
PUBLIC	??_GPDFDoc@@QAEPAXI@Z				; PDFDoc::`scalar deleting destructor'
PUBLIC	?getBitmap@SplashOutputDev@@QAEPAVSplashBitmap@@XZ ; SplashOutputDev::getBitmap
PUBLIC	?getWidth@SplashBitmap@@QAEHXZ			; SplashBitmap::getWidth
PUBLIC	?getHeight@SplashBitmap@@QAEHXZ			; SplashBitmap::getHeight
PUBLIC	?getDataPtr@SplashBitmap@@QAEPAEXZ		; SplashBitmap::getDataPtr
PUBLIC	?isDict@Object@@QAEHXZ				; Object::isDict
PUBLIC	?getDict@Object@@QAEPAVDict@@XZ			; Object::getDict
PUBLIC	?okToCopy@PDFDoc@@QAEHH@Z			; PDFDoc::okToCopy
PUBLIC	?getDocInfo@PDFDoc@@QAEPAVObject@@PAV2@@Z	; PDFDoc::getDocInfo
PUBLIC	??0Object@@QAE@XZ				; Object::Object
PUBLIC	?isString@Object@@QAEHXZ			; Object::isString
PUBLIC	?getString@Object@@QAEPAVGString@@XZ		; Object::getString
PUBLIC	??_C@_02KPKOKMHB@?$CFS?$AA@			; `string'
PUBLIC	??_C@_0BE@ECCAOMPC@RenderFinishedEvent?$AA@	; `string'
PUBLIC	??_C@_0BA@NCBBEIAC@Error?5File?5?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	??_C@_05PABKJLOM@Title?$AA@			; `string'
PUBLIC	??_C@_06HHECMMLE@Author?$AA@			; `string'
PUBLIC	??_C@_07GEKACEDI@Subject?$AA@			; `string'
PUBLIC	??_C@_08CDHFLBJH@Keywords?$AA@			; `string'
PUBLIC	??_C@_07IMEECM@Creator?$AA@			; `string'
PUBLIC	??_C@_08CAPOGIGH@Producer?$AA@			; `string'
PUBLIC	??_C@_0N@IKAKOCOF@CancellEvent?$AA@		; `string'
PUBLIC	??_C@_0P@NCLJFCBB@CancelledEvent?$AA@		; `string'
PUBLIC	??_C@_0O@MFHBPFDF@FinishedEvent?$AA@		; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_07KEBNPAKG@?$DMhtml?$DO?6?$AA@		; `string'
PUBLIC	??_C@_07GMNDOEHG@?$DMhead?$DO?6?$AA@		; `string'
PUBLIC	??_C@_09BBFFNMKL@?$DM?1title?$DO?6?$AA@		; `string'
PUBLIC	??_C@_07NBINAAM@?$DMtitle?$DO?$AA@		; `string'
PUBLIC	??_C@_03JKGHEG@?$CC?$DO?6?$AA@			; `string'
PUBLIC	??_C@_0BP@HAMJGHOB@?$DMmeta?5name?$DN?$CCSubject?$CC?5content?$DN?$CC?$AA@ ; `string'
PUBLIC	??_C@_0CA@EAHKABAB@?$DMmeta?5name?$DN?$CCKeywords?$CC?5content?$DN?$CC?$AA@ ; `string'
PUBLIC	??_C@_0BO@NOGKHONE@?$DMmeta?5name?$DN?$CCAuthor?$CC?5content?$DN?$CC?$AA@ ; `string'
PUBLIC	??_C@_0BP@IPGFALCO@?$DMmeta?5name?$DN?$CCCreator?$CC?5content?$DN?$CC?$AA@ ; `string'
PUBLIC	??_C@_0CA@DCFLJP@?$DMmeta?5name?$DN?$CCProducer?$CC?5content?$DN?$CC?$AA@ ; `string'
PUBLIC	??_C@_0CJ@PGCBBAGD@?$DMmeta?5name?$DN?$CCCreationDate?$CC?5conten@ ; `string'
PUBLIC	??_C@_0N@GPGLEEKJ@CreationDate?$AA@		; `string'
PUBLIC	??_C@_0CE@CEKGHJIK@?$DMmeta?5name?$DN?$CCModDate?$CC?5content?$DN?$CC?$CFs@ ; `string'
PUBLIC	??_C@_0BB@CPLAAHOH@LastModifiedDate?$AA@	; `string'
PUBLIC	??_C@_08NFMJCKLP@?$DM?1head?$DO?6?$AA@		; `string'
PUBLIC	??_C@_07DKLJIGM@?$DMbody?$DO?6?$AA@		; `string'
PUBLIC	??_C@_06FNICHGOI@?$DMpre?$DO?6?$AA@		; `string'
PUBLIC	??_C@_02BOGAIONP@ab?$AA@			; `string'
PUBLIC	??_C@_07CBJILGJO@?$DM?1pre?$DO?6?$AA@		; `string'
PUBLIC	??_C@_08LKLBFGKF@?$DM?1body?$DO?6?$AA@		; `string'
PUBLIC	??_C@_08BNAHDOGP@?$DM?1html?$DO?6?$AA@		; `string'
PUBLIC	??_R0?AW4exception@?$DynArray@PAX@@@8		; enum DynArray<void *>::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AW4exception@?$DynArray@PAX@@@84
PUBLIC	__CTA1?AW4exception@?$DynArray@PAX@@
PUBLIC	__TI1?AW4exception@?$DynArray@PAX@@
PUBLIC	??_R0?AW4exception@?$DynArray@VCPDFSearchResult@@@@@8 ; enum DynArray<CPDFSearchResult>::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AW4exception@?$DynArray@VCPDFSearchResult@@@@@84
PUBLIC	__CTA1?AW4exception@?$DynArray@VCPDFSearchResult@@@@
PUBLIC	__TI1?AW4exception@?$DynArray@VCPDFSearchResult@@@@
PUBLIC	??_7AFPDFDoc@@6B@				; AFPDFDoc::`vftable'
EXTRN	__imp___mbsrchr:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__CreateSemaphoreA@16:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	??_EAFPDFDoc@@UAEPAXI@Z:PROC			; AFPDFDoc::`vector deleting destructor'
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:PROC
EXTRN	__imp__GetWindowDC@4:PROC
EXTRN	__imp__InterlockedExchange@8:PROC
EXTRN	__imp__ResumeThread@4:PROC
EXTRN	__imp__ExitThread@4:PROC
EXTRN	__imp__TryEnterCriticalSection@4:PROC
EXTRN	__imp__ReleaseSemaphore@12:PROC
EXTRN	__imp__WaitForMultipleObjects@16:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp_?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	__imp__OffsetRect@12:PROC
EXTRN	__imp__InflateRect@12:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z:PROC
EXTRN	__imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ:PROC
EXTRN	__imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__SetThreadPriority@8:PROC
EXTRN	__imp__ResetEvent@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fputs:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp__GetExitCodeThread@8:PROC
	ALIGN	4

_EmptyChar DW	01H DUP (?)
;	COMDAT ??_7AFPDFDoc@@6B@
CONST	SEGMENT
??_7AFPDFDoc@@6B@ DD FLAT:??_R4AFPDFDoc@@6B@		; AFPDFDoc::`vftable'
	DD	FLAT:??_EAFPDFDoc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4AFPDFDoc@@6B@
rdata$r	SEGMENT
??_R4AFPDFDoc@@6B@ DD 00H				; AFPDFDoc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAFPDFDoc@@@8
	DD	FLAT:??_R3AFPDFDoc@@8
rdata$r	ENDS
;	COMDAT ??_R3AFPDFDoc@@8
rdata$r	SEGMENT
??_R3AFPDFDoc@@8 DD 00H					; AFPDFDoc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2AFPDFDoc@@8
rdata$r	ENDS
;	COMDAT ??_R2AFPDFDoc@@8
rdata$r	SEGMENT
??_R2AFPDFDoc@@8 DD FLAT:??_R1A@?0A@EA@AFPDFDoc@@8	; AFPDFDoc::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AFPDFDoc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AFPDFDoc@@8 DD FLAT:??_R0?AVAFPDFDoc@@@8	; AFPDFDoc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AFPDFDoc@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAFPDFDoc@@@8
_DATA	SEGMENT
??_R0?AVAFPDFDoc@@@8 DD FLAT:??_7type_info@@6B@		; AFPDFDoc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAFPDFDoc@@', 00H
_DATA	ENDS
;	COMDAT __TI1?AW4exception@?$DynArray@VCPDFSearchResult@@@@
xdata$x	SEGMENT
__TI1?AW4exception@?$DynArray@VCPDFSearchResult@@@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AW4exception@?$DynArray@VCPDFSearchResult@@@@
xdata$x	ENDS
;	COMDAT __CTA1?AW4exception@?$DynArray@VCPDFSearchResult@@@@
xdata$x	SEGMENT
__CTA1?AW4exception@?$DynArray@VCPDFSearchResult@@@@ DD 01H
	DD	FLAT:__CT??_R0?AW4exception@?$DynArray@VCPDFSearchResult@@@@@84
xdata$x	ENDS
;	COMDAT __CT??_R0?AW4exception@?$DynArray@VCPDFSearchResult@@@@@84
xdata$x	SEGMENT
__CT??_R0?AW4exception@?$DynArray@VCPDFSearchResult@@@@@84 DD 01H
	DD	FLAT:??_R0?AW4exception@?$DynArray@VCPDFSearchResult@@@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AW4exception@?$DynArray@VCPDFSearchResult@@@@@8
_DATA	SEGMENT
??_R0?AW4exception@?$DynArray@VCPDFSearchResult@@@@@8 DD FLAT:??_7type_info@@6B@ ; enum DynArray<CPDFSearchResult>::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AW4exception@?$DynArray@VCPDFSearchResult@@@@', 00H
_DATA	ENDS
;	COMDAT __TI1?AW4exception@?$DynArray@PAX@@
xdata$x	SEGMENT
__TI1?AW4exception@?$DynArray@PAX@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AW4exception@?$DynArray@PAX@@
xdata$x	ENDS
;	COMDAT __CTA1?AW4exception@?$DynArray@PAX@@
xdata$x	SEGMENT
__CTA1?AW4exception@?$DynArray@PAX@@ DD 01H
	DD	FLAT:__CT??_R0?AW4exception@?$DynArray@PAX@@@84
xdata$x	ENDS
;	COMDAT __CT??_R0?AW4exception@?$DynArray@PAX@@@84
xdata$x	SEGMENT
__CT??_R0?AW4exception@?$DynArray@PAX@@@84 DD 01H
	DD	FLAT:??_R0?AW4exception@?$DynArray@PAX@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AW4exception@?$DynArray@PAX@@@8
_DATA	SEGMENT
??_R0?AW4exception@?$DynArray@PAX@@@8 DD FLAT:??_7type_info@@6B@ ; enum DynArray<void *>::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AW4exception@?$DynArray@PAX@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_08BNAHDOGP@?$DM?1html?$DO?6?$AA@
CONST	SEGMENT
??_C@_08BNAHDOGP@?$DM?1html?$DO?6?$AA@ DB '</html>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LKLBFGKF@?$DM?1body?$DO?6?$AA@
CONST	SEGMENT
??_C@_08LKLBFGKF@?$DM?1body?$DO?6?$AA@ DB '</body>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CBJILGJO@?$DM?1pre?$DO?6?$AA@
CONST	SEGMENT
??_C@_07CBJILGJO@?$DM?1pre?$DO?6?$AA@ DB '</pre>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02BOGAIONP@ab?$AA@
CONST	SEGMENT
??_C@_02BOGAIONP@ab?$AA@ DB 'ab', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNICHGOI@?$DMpre?$DO?6?$AA@
CONST	SEGMENT
??_C@_06FNICHGOI@?$DMpre?$DO?6?$AA@ DB '<pre>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DKLJIGM@?$DMbody?$DO?6?$AA@
CONST	SEGMENT
??_C@_07DKLJIGM@?$DMbody?$DO?6?$AA@ DB '<body>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NFMJCKLP@?$DM?1head?$DO?6?$AA@
CONST	SEGMENT
??_C@_08NFMJCKLP@?$DM?1head?$DO?6?$AA@ DB '</head>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CPLAAHOH@LastModifiedDate?$AA@
CONST	SEGMENT
??_C@_0BB@CPLAAHOH@LastModifiedDate?$AA@ DB 'LastModifiedDate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CEKGHJIK@?$DMmeta?5name?$DN?$CCModDate?$CC?5content?$DN?$CC?$CFs@
CONST	SEGMENT
??_C@_0CE@CEKGHJIK@?$DMmeta?5name?$DN?$CCModDate?$CC?5content?$DN?$CC?$CFs@ DB '<'
	DB	'meta name="ModDate" content="%s">', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GPGLEEKJ@CreationDate?$AA@
CONST	SEGMENT
??_C@_0N@GPGLEEKJ@CreationDate?$AA@ DB 'CreationDate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PGCBBAGD@?$DMmeta?5name?$DN?$CCCreationDate?$CC?5conten@
CONST	SEGMENT
??_C@_0CJ@PGCBBAGD@?$DMmeta?5name?$DN?$CCCreationDate?$CC?5conten@ DB '<m'
	DB	'eta name="CreationDate" content="%s">', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DCFLJP@?$DMmeta?5name?$DN?$CCProducer?$CC?5content?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_0CA@DCFLJP@?$DMmeta?5name?$DN?$CCProducer?$CC?5content?$DN?$CC?$AA@ DB '<'
	DB	'meta name="Producer" content="', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IPGFALCO@?$DMmeta?5name?$DN?$CCCreator?$CC?5content?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_0BP@IPGFALCO@?$DMmeta?5name?$DN?$CCCreator?$CC?5content?$DN?$CC?$AA@ DB '<'
	DB	'meta name="Creator" content="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NOGKHONE@?$DMmeta?5name?$DN?$CCAuthor?$CC?5content?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_0BO@NOGKHONE@?$DMmeta?5name?$DN?$CCAuthor?$CC?5content?$DN?$CC?$AA@ DB '<'
	DB	'meta name="Author" content="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EAHKABAB@?$DMmeta?5name?$DN?$CCKeywords?$CC?5content?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_0CA@EAHKABAB@?$DMmeta?5name?$DN?$CCKeywords?$CC?5content?$DN?$CC?$AA@ DB '<'
	DB	'meta name="Keywords" content="', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HAMJGHOB@?$DMmeta?5name?$DN?$CCSubject?$CC?5content?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_0BP@HAMJGHOB@?$DMmeta?5name?$DN?$CCSubject?$CC?5content?$DN?$CC?$AA@ DB '<'
	DB	'meta name="Subject" content="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JKGHEG@?$CC?$DO?6?$AA@
CONST	SEGMENT
??_C@_03JKGHEG@?$CC?$DO?6?$AA@ DB '">', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBINAAM@?$DMtitle?$DO?$AA@
CONST	SEGMENT
??_C@_07NBINAAM@?$DMtitle?$DO?$AA@ DB '<title>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BBFFNMKL@?$DM?1title?$DO?6?$AA@
CONST	SEGMENT
??_C@_09BBFFNMKL@?$DM?1title?$DO?6?$AA@ DB '</title>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GMNDOEHG@?$DMhead?$DO?6?$AA@
CONST	SEGMENT
??_C@_07GMNDOEHG@?$DMhead?$DO?6?$AA@ DB '<head>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KEBNPAKG@?$DMhtml?$DO?6?$AA@
CONST	SEGMENT
??_C@_07KEBNPAKG@?$DMhtml?$DO?6?$AA@ DB '<html>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MFHBPFDF@FinishedEvent?$AA@
CONST	SEGMENT
??_C@_0O@MFHBPFDF@FinishedEvent?$AA@ DB 'FinishedEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NCLJFCBB@CancelledEvent?$AA@
CONST	SEGMENT
??_C@_0P@NCLJFCBB@CancelledEvent?$AA@ DB 'CancelledEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IKAKOCOF@CancellEvent?$AA@
CONST	SEGMENT
??_C@_0N@IKAKOCOF@CancellEvent?$AA@ DB 'CancellEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CAPOGIGH@Producer?$AA@
CONST	SEGMENT
??_C@_08CAPOGIGH@Producer?$AA@ DB 'Producer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMEECM@Creator?$AA@
CONST	SEGMENT
??_C@_07IMEECM@Creator?$AA@ DB 'Creator', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CDHFLBJH@Keywords?$AA@
CONST	SEGMENT
??_C@_08CDHFLBJH@Keywords?$AA@ DB 'Keywords', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GEKACEDI@Subject?$AA@
CONST	SEGMENT
??_C@_07GEKACEDI@Subject?$AA@ DB 'Subject', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HHECMMLE@Author?$AA@
CONST	SEGMENT
??_C@_06HHECMMLE@Author?$AA@ DB 'Author', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PABKJLOM@Title?$AA@
CONST	SEGMENT
??_C@_05PABKJLOM@Title?$AA@ DB 'Title', 00H		; `string'
CONST	ENDS
;	COMDAT ??_R0PAX@8
_DATA	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BA@NCBBEIAC@Error?5File?5?$CI?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@NCBBEIAC@Error?5File?5?$CI?$CFd?$CJ?$AA@ DB 'Error File (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ECCAOMPC@RenderFinishedEvent?$AA@
CONST	SEGMENT
??_C@_0BE@ECCAOMPC@RenderFinishedEvent?$AA@ DB 'RenderFinishedEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPKOKMHB@?$CFS?$AA@
CONST	SEGMENT
??_C@_02KPKOKMHB@?$CFS?$AA@ DB '%S', 00H		; `string'
	ORG $+3780
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\dynarray.h
;	COMDAT ?Clear@?$DynArray@PAX@@QAEXXZ
_TEXT	SEGMENT
?Clear@?$DynArray@PAX@@QAEXXZ PROC			; DynArray<void *>::Clear, COMDAT
; _this$ = esi

; 150  :     size = 0; 
; 151  : 	array = (T *)realloc(array, sizeof(T)*dyn_array_step); 

	mov	eax, DWORD PTR [esi]
	push	512					; 00000200H
	push	eax
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 152  : 				  // set initial memory size again 
; 153  : 	realsize = dyn_array_step;

	mov	DWORD PTR [esi+8], 128			; 00000080H

; 154  : }

	ret	0
?Clear@?$DynArray@PAX@@QAEXXZ ENDP			; DynArray<void *>::Clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?ToArray@?$DynArray@VCPDFSearchResult@@@@QAEPAVCPDFSearchResult@@XZ
_TEXT	SEGMENT
?ToArray@?$DynArray@VCPDFSearchResult@@@@QAEPAVCPDFSearchResult@@XZ PROC ; DynArray<CPDFSearchResult>::ToArray, COMDAT
; _this$ = eax

; 188  : 	return (T *)array;

	mov	eax, DWORD PTR [eax]

; 189  : }

	ret	0
?ToArray@?$DynArray@VCPDFSearchResult@@@@QAEPAVCPDFSearchResult@@XZ ENDP ; DynArray<CPDFSearchResult>::ToArray
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Clear@?$DynArray@VCPDFSearchResult@@@@QAEXXZ
_TEXT	SEGMENT
?Clear@?$DynArray@VCPDFSearchResult@@@@QAEXXZ PROC	; DynArray<CPDFSearchResult>::Clear, COMDAT
; _this$ = esi

; 150  :     size = 0; 
; 151  : 	array = (T *)realloc(array, sizeof(T)*dyn_array_step); 

	mov	eax, DWORD PTR [esi]
	push	3584					; 00000e00H
	push	eax
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 152  : 				  // set initial memory size again 
; 153  : 	realsize = dyn_array_step;

	mov	DWORD PTR [esi+8], 128			; 00000080H

; 154  : }

	ret	0
?Clear@?$DynArray@VCPDFSearchResult@@@@QAEXXZ ENDP	; DynArray<CPDFSearchResult>::Clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetSize@?$DynArray@VCPDFSearchResult@@@@QAEIXZ
_TEXT	SEGMENT
?GetSize@?$DynArray@VCPDFSearchResult@@@@QAEIXZ PROC	; DynArray<CPDFSearchResult>::GetSize, COMDAT
; _this$ = eax

; 102  :     return size; // simply return size

	mov	eax, DWORD PTR [eax+4]

; 103  : }

	ret	0
?GetSize@?$DynArray@VCPDFSearchResult@@@@QAEIXZ ENDP	; DynArray<CPDFSearchResult>::GetSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Add@?$DynArray@VCPDFSearchResult@@@@QAEXABVCPDFSearchResult@@@Z
_TEXT	SEGMENT
$T160427 = 8						; size = 4
_item$ = 8						; size = 4
?Add@?$DynArray@VCPDFSearchResult@@@@QAEXABVCPDFSearchResult@@@Z PROC ; DynArray<CPDFSearchResult>::Add, COMDAT
; _this$ = eax

; 170  : {

	push	esi
	mov	esi, eax

; 171  :     size++;

	inc	DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]

; 172  :  
; 173  :     if (size > realsize)

	mov	eax, DWORD PTR [esi+8]
	cmp	ecx, eax
	jbe	SHORT $LN1@Add@2

; 174  :     {
; 175  : 		realsize *= dyn_array_mult;
; 176  :  
; 177  : 		array = (T *)realloc(array, sizeof(T)*realsize);

	mov	edx, DWORD PTR [esi]
	add	eax, eax
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 178  :  
; 179  : 		if (array == NULL)

	test	eax, eax
	jne	SHORT $LN1@Add@2

; 180  : 			throw MEMFAIL;

	mov	DWORD PTR $T160427[esp], eax
	push	OFFSET __TI1?AW4exception@?$DynArray@VCPDFSearchResult@@@@
	lea	eax, DWORD PTR $T160427[esp+4]
	push	eax
	call	__CxxThrowException@8
$LN6@Add@2:
$LN1@Add@2:

; 181  :     }
; 182  :  
; 183  : 	array[size-1] = item;

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	mov	esi, DWORD PTR _item$[esp]
	push	edi
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+ecx*4-28]
	mov	ecx, 7
	rep movsd
	pop	edi
	pop	esi

; 184  : }

	ret	4
$LN5@Add@2:
?Add@?$DynArray@VCPDFSearchResult@@@@QAEXABVCPDFSearchResult@@@Z ENDP ; DynArray<CPDFSearchResult>::Add
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$DynArray@VCPDFSearchResult@@@@QAEAAVCPDFSearchResult@@I@Z
_TEXT	SEGMENT
??A?$DynArray@VCPDFSearchResult@@@@QAEAAVCPDFSearchResult@@I@Z PROC ; DynArray<CPDFSearchResult>::operator[], COMDAT
; _this$ = edx
; _index$ = eax

; 165  :     return array[index]; // return array element 

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	lea	eax, DWORD PTR [eax+ecx*4]

; 166  : }

	ret	0
??A?$DynArray@VCPDFSearchResult@@@@QAEAAVCPDFSearchResult@@I@Z ENDP ; DynArray<CPDFSearchResult>::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$DynArray@VCPDFSearchResult@@@@QAE@XZ
_TEXT	SEGMENT
??1?$DynArray@VCPDFSearchResult@@@@QAE@XZ PROC		; DynArray<CPDFSearchResult>::~DynArray<CPDFSearchResult>, COMDAT
; _this$ = esi

; 61   :     if (array)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@DynArray@3

; 62   :     {
; 63   :     	free(array); // Freeing memory 

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 64   :     	array = NULL;

	mov	DWORD PTR [esi], 0
$LN1@DynArray@3:

; 65   :     }
; 66   : }

	ret	0
??1?$DynArray@VCPDFSearchResult@@@@QAE@XZ ENDP		; DynArray<CPDFSearchResult>::~DynArray<CPDFSearchResult>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$DynArray@VCPDFSearchResult@@@@QAE@XZ
_TEXT	SEGMENT
$T160439 = -4						; size = 4
??0?$DynArray@VCPDFSearchResult@@@@QAE@XZ PROC		; DynArray<CPDFSearchResult>::DynArray<CPDFSearchResult>, COMDAT
; _this$ = esi

; 47   : {

	push	ecx

; 48   :     realsize = dyn_array_step; // First, allocate step 
; 49   : 							   // for dyn_array_step items
; 50   :     size = 0;
; 51   :     array = (T *)malloc(realsize*sizeof(T));

	push	3584					; 00000e00H
	mov	DWORD PTR [esi+8], 128			; 00000080H
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 52   :  
; 53   :     if (array == NULL)

	test	eax, eax
	jne	SHORT $LN1@DynArray@4

; 54   : 		throw MEMFAIL;

	mov	DWORD PTR $T160439[esp+4], eax
	push	OFFSET __TI1?AW4exception@?$DynArray@VCPDFSearchResult@@@@
	lea	eax, DWORD PTR $T160439[esp+8]
	push	eax
	call	__CxxThrowException@8
$LN5@DynArray@4:
$LN1@DynArray@4:

; 55   : }

	mov	eax, esi
	pop	ecx
	ret	0
$LN4@DynArray@4:
??0?$DynArray@VCPDFSearchResult@@@@QAE@XZ ENDP		; DynArray<CPDFSearchResult>::DynArray<CPDFSearchResult>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Delete@?$DynArray@PAX@@QAEXI@Z
_TEXT	SEGMENT
?Delete@?$DynArray@PAX@@QAEXI@Z PROC			; DynArray<void *>::Delete, COMDAT
; _this$ = esi

; 132  : 	if (size == 1) // If array has only one element 

	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, 1
	jne	SHORT $LN6@Delete

; 133  : 		Clear(); // than we clear it, since it will be deleted 

	mov	eax, DWORD PTR [esi]
	push	512					; 00000200H
	push	eax
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 128			; 00000080H

; 143  : 		}
; 144  : 	}
; 145  : }

	ret	0
$LN6@Delete:

; 134  : 	else
; 135  : 	{
; 136  : 		if(size>0){

	test	ecx, ecx
	jbe	SHORT $LN4@Delete

; 137  : 			// otherwise, shift array elements 
; 138  : 			for(unsigned int i=pos; i<size-1; i++) 

	xor	eax, eax
	add	ecx, -1
	je	SHORT $LN1@Delete
$LL3@Delete:
	mov	ecx, DWORD PTR [esi]

; 139  : 				array[i] = array[i+1];

	mov	edx, DWORD PTR [ecx+eax*4+4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [esi+4]
	inc	eax
	dec	ecx
	cmp	eax, ecx
	jb	SHORT $LL3@Delete
$LN1@Delete:

; 140  : 	 
; 141  : 			// decrease array size
; 142  : 			size--;

	dec	DWORD PTR [esi+4]
$LN4@Delete:

; 143  : 		}
; 144  : 	}
; 145  : }

	ret	0
?Delete@?$DynArray@PAX@@QAEXI@Z ENDP			; DynArray<void *>::Delete
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetSize@?$DynArray@PAX@@QAEIXZ
_TEXT	SEGMENT
?GetSize@?$DynArray@PAX@@QAEIXZ PROC			; DynArray<void *>::GetSize, COMDAT
; _this$ = eax

; 102  :     return size; // simply return size

	mov	eax, DWORD PTR [eax+4]

; 103  : }

	ret	0
?GetSize@?$DynArray@PAX@@QAEIXZ ENDP			; DynArray<void *>::GetSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Add@?$DynArray@PAX@@QAEXABQAX@Z
_TEXT	SEGMENT
$T160456 = 8						; size = 4
_item$ = 8						; size = 4
?Add@?$DynArray@PAX@@QAEXABQAX@Z PROC			; DynArray<void *>::Add, COMDAT
; _this$ = esi

; 171  :     size++;

	inc	DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]

; 172  :  
; 173  :     if (size > realsize)

	mov	eax, DWORD PTR [esi+8]
	cmp	ecx, eax
	jbe	SHORT $LN1@Add@3

; 174  :     {
; 175  : 		realsize *= dyn_array_mult;
; 176  :  
; 177  : 		array = (T *)realloc(array, sizeof(T)*realsize);

	mov	ecx, DWORD PTR [esi]
	add	eax, eax
	mov	DWORD PTR [esi+8], eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 178  :  
; 179  : 		if (array == NULL)

	test	eax, eax
	jne	SHORT $LN1@Add@3

; 180  : 			throw MEMFAIL;

	push	OFFSET __TI1?AW4exception@?$DynArray@PAX@@
	lea	edx, DWORD PTR $T160456[esp]
	push	edx
	mov	DWORD PTR $T160456[esp+4], eax
	call	__CxxThrowException@8
$LN6@Add@3:
$LN1@Add@3:

; 181  :     }
; 182  :  
; 183  : 	array[size-1] = item;

	mov	edx, DWORD PTR _item$[esp-4]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4-4], edx

; 184  : }

	ret	4
$LN5@Add@3:
?Add@?$DynArray@PAX@@QAEXABQAX@Z ENDP			; DynArray<void *>::Add
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$DynArray@PAX@@QAEAAPAXI@Z
_TEXT	SEGMENT
??A?$DynArray@PAX@@QAEAAPAXI@Z PROC			; DynArray<void *>::operator[], COMDAT
; _this$ = eax
; _index$ = edx

; 165  :     return array[index]; // return array element 

	mov	ecx, DWORD PTR [eax]
	lea	eax, DWORD PTR [ecx+edx*4]

; 166  : }

	ret	0
??A?$DynArray@PAX@@QAEAAPAXI@Z ENDP			; DynArray<void *>::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$DynArray@PAX@@QAE@XZ
_TEXT	SEGMENT
??1?$DynArray@PAX@@QAE@XZ PROC				; DynArray<void *>::~DynArray<void *>, COMDAT
; _this$ = esi

; 61   :     if (array)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@DynArray@5

; 62   :     {
; 63   :     	free(array); // Freeing memory 

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 64   :     	array = NULL;

	mov	DWORD PTR [esi], 0
$LN1@DynArray@5:

; 65   :     }
; 66   : }

	ret	0
??1?$DynArray@PAX@@QAE@XZ ENDP				; DynArray<void *>::~DynArray<void *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$DynArray@PAX@@QAE@XZ
_TEXT	SEGMENT
$T160468 = -4						; size = 4
??0?$DynArray@PAX@@QAE@XZ PROC				; DynArray<void *>::DynArray<void *>, COMDAT
; _this$ = esi

; 47   : {

	push	ecx

; 48   :     realsize = dyn_array_step; // First, allocate step 
; 49   : 							   // for dyn_array_step items
; 50   :     size = 0;
; 51   :     array = (T *)malloc(realsize*sizeof(T));

	push	512					; 00000200H
	mov	DWORD PTR [esi+8], 128			; 00000080H
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 52   :  
; 53   :     if (array == NULL)

	test	eax, eax
	jne	SHORT $LN1@DynArray@6

; 54   : 		throw MEMFAIL;

	mov	DWORD PTR $T160468[esp+4], eax
	push	OFFSET __TI1?AW4exception@?$DynArray@PAX@@
	lea	eax, DWORD PTR $T160468[esp+8]
	push	eax
	call	__CxxThrowException@8
$LN5@DynArray@6:
$LN1@DynArray@6:

; 55   : }

	mov	eax, esi
	pop	ecx
	ret	0
$LN4@DynArray@6:
??0?$DynArray@PAX@@QAE@XZ ENDP				; DynArray<void *>::DynArray<void *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$DynArray@VCPDFSearchResult@@@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$DynArray@VCPDFSearchResult@@@@QAEXXZ PROC	; DynArray<CPDFSearchResult>::RemoveAll, COMDAT
; _this$ = esi

; 20   : 		this->Clear();

	mov	eax, DWORD PTR [esi]
	push	3584					; 00000e00H
	push	eax
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 128			; 00000080H

; 21   : 	}

	ret	0
?RemoveAll@?$DynArray@VCPDFSearchResult@@@@QAEXXZ ENDP	; DynArray<CPDFSearchResult>::RemoveAll
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$DynArray@VCPDFSearchResult@@@@QAEIXZ
_TEXT	SEGMENT
?GetCount@?$DynArray@VCPDFSearchResult@@@@QAEIXZ PROC	; DynArray<CPDFSearchResult>::GetCount, COMDAT
; _this$ = eax

; 17   : 		return this->GetSize();

	mov	eax, DWORD PTR [eax+4]

; 18   : 	}

	ret	0
?GetCount@?$DynArray@VCPDFSearchResult@@@@QAEIXZ ENDP	; DynArray<CPDFSearchResult>::GetCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$DynArray@PAX@@QAEIXZ
_TEXT	SEGMENT
?GetCount@?$DynArray@PAX@@QAEIXZ PROC			; DynArray<void *>::GetCount, COMDAT
; _this$ = eax

; 17   : 		return this->GetSize();

	mov	eax, DWORD PTR [eax+4]

; 18   : 	}

	ret	0
?GetCount@?$DynArray@PAX@@QAEIXZ ENDP			; DynArray<void *>::GetCount
_TEXT	ENDS
PUBLIC	?ExportToSWF@AFPDFDoc@@QAE_NPAD0HHHH@Z		; AFPDFDoc::ExportToSWF
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
;	COMDAT ?ExportToSWF@AFPDFDoc@@QAE_NPAD0HHHH@Z
_TEXT	SEGMENT
?ExportToSWF@AFPDFDoc@@QAE_NPAD0HHHH@Z PROC		; AFPDFDoc::ExportToSWF, COMDAT

; 3143 : 		/*double zoom=1;
; 3144 : 		double multiply=1.0;
; 3145 : 		char pagerange[255];
; 3146 : 		sprintf(pagerange,"%d-%d",fromPage,toPage);
; 3147 : 		gfxsource_t *driver = gfxsource_pdf_create();
; 3148 : 		driver->set_parameter(driver, "pages", pagerange);
; 3149 : 		driver->set_parameter(driver,"viewer",swfViewer);
; 3150 : 		gfxdocument_t* pdf = driver->open(driver, fileName);
; 3151 : 		
; 3152 : 		int pagenum = 0;
; 3153 : 		int frame = 1;
; 3154 : 		int pagenr;
; 3155 : 	    
; 3156 : 		for(pagenr = 1; pagenr <= pdf->num_pages; pagenr++) 
; 3157 : 		{
; 3158 : 			if(is_in_range(pagenr, pagerange)) {
; 3159 : 				char mapping[80];
; 3160 : 				sprintf(mapping, "%d:%d", pagenr, frame);
; 3161 : 				pdf->set_parameter(pdf, "pagemap", mapping);
; 3162 : 				pagenum++;
; 3163 : 			}
; 3164 : 			if(pagenr == pdf->num_pages && pagenum>1) {
; 3165 : 				pagenum = 0;
; 3166 : 				frame++;
; 3167 : 			}
; 3168 : 		}
; 3169 : 
; 3170 : 		pagenum = 0;
; 3171 : 		gfxdevice_t *out;
; 3172 : 		gfxdevice_t swf;
; 3173 : 		gfxdevice_t wrap;
; 3174 : 		gfxdevice_t rescale;
; 3175 : 		
; 3176 : 		gfxdevice_swf_init(&swf);
; 3177 : 		out=&swf;
; 3178 : 		/* set up filter chain */
; 3179 : 		/*if(flatten) {
; 3180 : 			gfxdevice_removeclippings_init(&wrap, &swf);
; 3181 : 			out = &wrap;
; 3182 : 		}
; 3183 : 		if(maxwidth || maxheight) {
; 3184 : 			gfxdevice_rescale_init(&rescale, out, 1024, 800, 0);
; 3185 : 			out = &rescale;
; 3186 : 		}*/
; 3187 : 		/*
; 3188 : 
; 3189 : 		InfoOutputDev *infoOut = new InfoOutputDev(m_PDFDoc->getXRef());
; 3190 : 		GFXOutputDev *gfxOut = new GFXOutputDev(infoOut,m_PDFDoc);
; 3191 : 
; 3192 : 		if(zoomtowidth && m_PDFDoc->getNumPages()) {
; 3193 : 			Page*page = m_PDFDoc->getCatalog()->getPage(1);
; 3194 : 			PDFRectangle *r = page->getCropBox();
; 3195 : 			double width_before = r->x2 - r->x1;
; 3196 : 			zoom = 72.0 * zoomtowidth / width_before;
; 3197 : 			//msg("<notice> Rendering at %f DPI. (Page width at 72 DPI: %f, target width: %d)", zoom, width_before, zoomtowidth);
; 3198 : 		}
; 3199 : 
; 3200 : 		gfxdevice_t* middev=0;
; 3201 : 		middev = (gfxdevice_t*)malloc(sizeof(gfxdevice_t));
; 3202 : 		gfxdevice_rescale_init(middev, 0x00000000, 0, 0, 1.0 / multiply);
; 3203 : 		middev->setparameter(middev, "protect", "1");
; 3204 : 		gfxOut->setDevice(middev);
; 3205 : 
; 3206 : 		for(int i=fromPage;i<=toPage;i++)
; 3207 : 		{
; 3208 : 			//Load Page Info
; 3209 : 			m_PDFDoc->displayPage((OutputDev *)infoOut,i,1/zoom,1/zoom,0,true,false,false);
; 3210 : 			m_PDFDoc->processLinks((OutputDev *)infoOut,i);
; 3211 : 			infoOut->endPage();
; 3212 : 			//Render page
; 3213 : 			m_PDFDoc->displayPage((OutputDev *)gfxOut,i,zoom,zoom,0,true,false,false);
; 3214 : 			m_PDFDoc->processLinks((OutputDev *)gfxOut,i);
; 3215 : 			gfxOut->endPage();	
; 3216 : 		}
; 3217 : 
; 3218 : 		gfxOut->setDevice(0);
; 3219 : 
; 3220 : //		free(middev);
; 3221 : 
; 3222 : 		delete infoOut;
; 3223 : 		delete gfxOut;
; 3224 : 		*/
; 3225 : 		return true;

	mov	al, 1

; 3226 : 	}

	ret	0
?ExportToSWF@AFPDFDoc@@QAE_NPAD0HHHH@Z ENDP		; AFPDFDoc::ExportToSWF
_TEXT	ENDS
PUBLIC	?setNeedNonText@AFPDFDoc@@IAEX_N@Z		; AFPDFDoc::setNeedNonText
; Function compile flags: /Ogtpy
;	COMDAT ?setNeedNonText@AFPDFDoc@@IAEX_N@Z
_TEXT	SEGMENT
?setNeedNonText@AFPDFDoc@@IAEX_N@Z PROC			; AFPDFDoc::setNeedNonText, COMDAT
; _this$ = eax
; _needs$ = ecx

; 3138 : 	void AFPDFDoc::setNeedNonText(bool needs) { _needNonText = needs; }

	mov	BYTE PTR [eax+153], cl
	ret	0
?setNeedNonText@AFPDFDoc@@IAEX_N@Z ENDP			; AFPDFDoc::setNeedNonText
_TEXT	ENDS
PUBLIC	?getNeedNonText@AFPDFDoc@@IAE_NXZ		; AFPDFDoc::getNeedNonText
; Function compile flags: /Ogtpy
;	COMDAT ?getNeedNonText@AFPDFDoc@@IAE_NXZ
_TEXT	SEGMENT
?getNeedNonText@AFPDFDoc@@IAE_NXZ PROC			; AFPDFDoc::getNeedNonText, COMDAT
; _this$ = eax

; 3137 : 	bool AFPDFDoc::getNeedNonText(){ return _needNonText; }

	mov	al, BYTE PTR [eax+153]
	ret	0
?getNeedNonText@AFPDFDoc@@IAE_NXZ ENDP			; AFPDFDoc::getNeedNonText
_TEXT	ENDS
PUBLIC	?SetSliceBox@AFPDFDoc@@QAEXHHHH@Z		; AFPDFDoc::SetSliceBox
; Function compile flags: /Ogtpy
;	COMDAT ?SetSliceBox@AFPDFDoc@@QAEXHHHH@Z
_TEXT	SEGMENT
_y$ = 8							; size = 4
?SetSliceBox@AFPDFDoc@@QAEXHHHH@Z PROC			; AFPDFDoc::SetSliceBox, COMDAT
; _this$ = eax
; _x$ = ecx
; _w$ = esi
; _h$ = edx

; 3128 : 	void AFPDFDoc::SetSliceBox(int x, int y, int w, int h){

	push	edi

; 3129 : 		m_sliceBox.left=x;
; 3130 : 		m_sliceBox.right = x+w;

	lea	edi, DWORD PTR [ecx+esi]
	mov	DWORD PTR [eax+444], edi

; 3131 : 		m_sliceBox.bottom = y+h;

	mov	edi, DWORD PTR _y$[esp]
	add	edi, edx
	mov	DWORD PTR [eax+448], edi
	mov	DWORD PTR [eax+436], ecx

; 3132 : 		m_sliceBox.top=x;

	mov	DWORD PTR [eax+440], ecx

; 3133 : 		m_sliceBox.width=w;

	mov	DWORD PTR [eax+452], esi

; 3134 : 		m_sliceBox.height=h;

	mov	DWORD PTR [eax+456], edx
	pop	edi

; 3135 : 	}

	ret	4
?SetSliceBox@AFPDFDoc@@QAEXHHHH@Z ENDP			; AFPDFDoc::SetSliceBox
_TEXT	ENDS
PUBLIC	?IsBusy@AFPDFDoc@@QAE_NXZ			; AFPDFDoc::IsBusy
; Function compile flags: /Ogtpy
;	COMDAT ?IsBusy@AFPDFDoc@@QAE_NXZ
_TEXT	SEGMENT
_exitcode$86943 = -4					; size = 4
?IsBusy@AFPDFDoc@@QAE_NXZ PROC				; AFPDFDoc::IsBusy, COMDAT
; _this$ = eax

; 3117 : 	bool AFPDFDoc::IsBusy(){

	push	ecx

; 3118 : 		if(this->m_renderingThread!=0){

	mov	eax, DWORD PTR [eax+240]
	test	eax, eax
	je	SHORT $LN1@IsBusy

; 3119 : 			DWORD exitcode=0;
; 3120 : 			GetExitCodeThread(m_renderingThread,&exitcode);

	lea	ecx, DWORD PTR _exitcode$86943[esp+4]
	push	ecx
	push	eax
	mov	DWORD PTR _exitcode$86943[esp+12], 0
	call	DWORD PTR __imp__GetExitCodeThread@8

; 3121 : 			if (exitcode==STILL_ACTIVE){	

	cmp	DWORD PTR _exitcode$86943[esp+4], 259	; 00000103H
	jne	SHORT $LN1@IsBusy

; 3122 : 				return true;

	mov	al, 1

; 3126 : 	}

	pop	ecx
	ret	0
$LN1@IsBusy:

; 3123 : 			}
; 3124 : 		}
; 3125 : 		return false;

	xor	al, al

; 3126 : 	}

	pop	ecx
	ret	0
?IsBusy@AFPDFDoc@@QAE_NXZ ENDP				; AFPDFDoc::IsBusy
_TEXT	ENDS
PUBLIC	?JpgIsBusy@AFPDFDoc@@QAE_NXZ			; AFPDFDoc::JpgIsBusy
; Function compile flags: /Ogtpy
;	COMDAT ?JpgIsBusy@AFPDFDoc@@QAE_NXZ
_TEXT	SEGMENT
_exitcode$86936 = -4					; size = 4
?JpgIsBusy@AFPDFDoc@@QAE_NXZ PROC			; AFPDFDoc::JpgIsBusy, COMDAT
; _this$ = eax

; 3105 : 	bool AFPDFDoc::JpgIsBusy(){

	push	ecx

; 3106 : 		if(m_exportJpgThread!=0){

	mov	eax, DWORD PTR [eax+244]
	test	eax, eax
	je	SHORT $LN1@JpgIsBusy

; 3107 : 			DWORD exitcode=0;
; 3108 : 			GetExitCodeThread(m_exportJpgThread,&exitcode);

	lea	ecx, DWORD PTR _exitcode$86936[esp+4]
	push	ecx
	push	eax
	mov	DWORD PTR _exitcode$86936[esp+12], 0
	call	DWORD PTR __imp__GetExitCodeThread@8

; 3109 : 			if (exitcode==STILL_ACTIVE){	

	cmp	DWORD PTR _exitcode$86936[esp+4], 259	; 00000103H
	jne	SHORT $LN1@JpgIsBusy

; 3110 : 				return true;

	mov	al, 1

; 3114 : 	}

	pop	ecx
	ret	0
$LN1@JpgIsBusy:

; 3111 : 			}
; 3112 : 		}
; 3113 : 		return false;

	xor	al, al

; 3114 : 	}

	pop	ecx
	ret	0
?JpgIsBusy@AFPDFDoc@@QAE_NXZ ENDP			; AFPDFDoc::JpgIsBusy
_TEXT	ENDS
PUBLIC	?CancelJpgSave@AFPDFDoc@@QAEXXZ			; AFPDFDoc::CancelJpgSave
; Function compile flags: /Ogtpy
;	COMDAT ?CancelJpgSave@AFPDFDoc@@QAEXXZ
_TEXT	SEGMENT
?CancelJpgSave@AFPDFDoc@@QAEXXZ PROC			; AFPDFDoc::CancelJpgSave, COMDAT
; _this$ = eax

; 2747 : 		SetEvent(this->hExportJpgCancel);

	mov	ecx, DWORD PTR [eax+172]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4

; 2748 : 	}

	ret	0
?CancelJpgSave@AFPDFDoc@@QAEXXZ ENDP			; AFPDFDoc::CancelJpgSave
_TEXT	ENDS
PUBLIC	?cvtDevToUser@AFPDFDoc@@QAEXNNPAN0@Z		; AFPDFDoc::cvtDevToUser
; Function compile flags: /Ogtpy
;	COMDAT ?cvtDevToUser@AFPDFDoc@@QAEXNNPAN0@Z
_TEXT	SEGMENT
_ux$ = 8						; size = 8
_uy$ = 16						; size = 8
?cvtDevToUser@AFPDFDoc@@QAEXNNPAN0@Z PROC		; AFPDFDoc::cvtDevToUser, COMDAT
; _this$ = ecx
; _dx$ = esi
; _dy$ = edx

; 2635 : 		if(m_Bitmap)

	mov	eax, DWORD PTR [ecx+352]
	test	eax, eax
	je	SHORT $LN4@cvtDevToUs

; 2636 : 			m_Bitmap->cvtDevTouser(ux,uy,dx,dy);

	fld	QWORD PTR [eax+80]
	fld	QWORD PTR _ux$[esp-4]
	fmul	ST(1), ST(0)
	fld	QWORD PTR [eax+96]
	fld	QWORD PTR _uy$[esp-4]
	fmul	ST(1), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [eax+112]
	fstp	QWORD PTR [esi]
	fmul	QWORD PTR [eax+88]
	fld	QWORD PTR [eax+104]
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [eax+120]

; 2641 : 			*dy=uy;

	fstp	QWORD PTR [edx]

; 2642 : 		}
; 2643 : 
; 2644 : 	}

	ret	16					; 00000010H
$LN4@cvtDevToUs:

; 2637 : 		else if(m_splashOut)

	cmp	DWORD PTR [ecx+344], 0
	je	SHORT $LN2@cvtDevToUs

; 2638 : 			m_splashOut->cvtDevToUser(ux,uy,dx,dy);

	mov	ecx, DWORD PTR [ecx+344]
	fld	QWORD PTR _uy$[esp-4]
	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	edx, DWORD PTR [eax]
	push	esi
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _ux$[esp+20]
	fstp	QWORD PTR [esp]
	call	edx

; 2642 : 		}
; 2643 : 
; 2644 : 	}

	ret	16					; 00000010H
$LN2@cvtDevToUs:

; 2639 : 		else{
; 2640 : 			*dx=ux;

	fld	QWORD PTR _ux$[esp-4]
	fstp	QWORD PTR [esi]

; 2641 : 			*dy=uy;

	fld	QWORD PTR _uy$[esp-4]
	fstp	QWORD PTR [edx]

; 2642 : 		}
; 2643 : 
; 2644 : 	}

	ret	16					; 00000010H
?cvtDevToUser@AFPDFDoc@@QAEXNNPAN0@Z ENDP		; AFPDFDoc::cvtDevToUser
_TEXT	ENDS
PUBLIC	?cvtUserToDev@AFPDFDoc@@QAEXNNPAH0@Z		; AFPDFDoc::cvtUserToDev
; Function compile flags: /Ogtpy
;	COMDAT ?cvtUserToDev@AFPDFDoc@@QAEXNNPAH0@Z
_TEXT	SEGMENT
_ux$ = 8						; size = 8
_uy$ = 16						; size = 8
?cvtUserToDev@AFPDFDoc@@QAEXNNPAH0@Z PROC		; AFPDFDoc::cvtUserToDev, COMDAT
; _this$ = eax
; _dx$ = ebx
; _dy$ = edi

; 2623 : 	void AFPDFDoc::cvtUserToDev(double ux, double uy, int *dx, int *dy){

	push	esi

; 2624 : 		if(m_Bitmap)

	mov	esi, DWORD PTR [eax+352]
	test	esi, esi
	je	SHORT $LN4@cvtUserToD

; 2625 : 			m_Bitmap->cvtUserToDev(ux,uy,dx,dy);

	fld	QWORD PTR [esi+32]
	fld	QWORD PTR _ux$[esp]
	fmul	ST(1), ST(0)
	fld	QWORD PTR [esi+48]
	fld	QWORD PTR _uy$[esp]
	fmul	ST(1), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [esi+64]
	fld	QWORD PTR __real@3fe0000000000000
	fadd	ST(1), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	mov	DWORD PTR [ebx], eax
	fld	QWORD PTR [esi+40]
	fmulp	ST(2), ST(0)
	fld	QWORD PTR [esi+56]
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR [esi+72]
	faddp	ST(1), ST(0)

; 2630 : 			*dy=(int)uy;

	call	__ftol2_sse
	mov	DWORD PTR [edi], eax

; 2631 : 		}
; 2632 : 	}

	pop	esi
	ret	16					; 00000010H
$LN4@cvtUserToD:

; 2626 : 		else if(m_splashOut)

	cmp	DWORD PTR [eax+344], 0
	je	SHORT $LN2@cvtUserToD

; 2627 : 			m_splashOut->cvtUserToDev(ux,uy,dx,dy);	

	mov	ecx, DWORD PTR [eax+344]
	fld	QWORD PTR _uy$[esp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	push	edi
	push	ebx
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _ux$[esp+24]
	fstp	QWORD PTR [esp]
	call	edx

; 2631 : 		}
; 2632 : 	}

	pop	esi
	ret	16					; 00000010H
$LN2@cvtUserToD:

; 2628 : 		else{
; 2629 : 			*dx=(int)ux;

	fld	QWORD PTR _ux$[esp]
	call	__ftol2_sse

; 2630 : 			*dy=(int)uy;

	fld	QWORD PTR _uy$[esp]
	mov	DWORD PTR [ebx], eax
	call	__ftol2_sse
	mov	DWORD PTR [edi], eax

; 2631 : 		}
; 2632 : 	}

	pop	esi
	ret	16					; 00000010H
?cvtUserToDev@AFPDFDoc@@QAEXNNPAH0@Z ENDP		; AFPDFDoc::cvtUserToDev
_TEXT	ENDS
PUBLIC	?getLastModifiedDate@AFPDFDoc@@QAEPADXZ		; AFPDFDoc::getLastModifiedDate
; Function compile flags: /Ogtpy
;	COMDAT ?getLastModifiedDate@AFPDFDoc@@QAEPADXZ
_TEXT	SEGMENT
?getLastModifiedDate@AFPDFDoc@@QAEPADXZ PROC		; AFPDFDoc::getLastModifiedDate, COMDAT

; 2602 : #ifdef PDFLIBNET_ORIGINAL
; 2603 : 		wchar_t *s = getDocInfo("LastModifiedDate",m_PDFDoc);
; 2604 : 		char *datetime=new char[256];
; 2605 : 		USES_CONVERSION;
; 2606 : 		parseDateTime(datetime,W2A(s));
; 2607 : 		return datetime;
; 2608 : #else
; 2609 : 		return NULL;

	xor	eax, eax

; 2610 : #endif
; 2611 : 	}

	ret	0
?getLastModifiedDate@AFPDFDoc@@QAEPADXZ ENDP		; AFPDFDoc::getLastModifiedDate
_TEXT	ENDS
PUBLIC	?getCreationDate@AFPDFDoc@@QAEPADXZ		; AFPDFDoc::getCreationDate
; Function compile flags: /Ogtpy
;	COMDAT ?getCreationDate@AFPDFDoc@@QAEPADXZ
_TEXT	SEGMENT
?getCreationDate@AFPDFDoc@@QAEPADXZ PROC		; AFPDFDoc::getCreationDate, COMDAT

; 2591 : #ifdef PDFLIBNET_ORIGINAL
; 2592 : 		wchar_t * s = getDocInfo("CreationDate",m_PDFDoc);
; 2593 : 		char *datetime = new char[256];
; 2594 : 		USES_CONVERSION;
; 2595 : 		parseDateTime(datetime,W2A(s));
; 2596 : 		return datetime;
; 2597 : #else
; 2598 : 		return NULL;

	xor	eax, eax

; 2599 : #endif
; 2600 : 	}

	ret	0
?getCreationDate@AFPDFDoc@@QAEPADXZ ENDP		; AFPDFDoc::getCreationDate
_TEXT	ENDS
PUBLIC	?SetSearchCaseSensitive@AFPDFDoc@@QAEX_N@Z	; AFPDFDoc::SetSearchCaseSensitive
; Function compile flags: /Ogtpy
;	COMDAT ?SetSearchCaseSensitive@AFPDFDoc@@QAEX_N@Z
_TEXT	SEGMENT
?SetSearchCaseSensitive@AFPDFDoc@@QAEX_N@Z PROC		; AFPDFDoc::SetSearchCaseSensitive, COMDAT
; _this$ = eax
; _newVal$ = ecx

; 2566 : 		
; 2567 : 		m_bCaseSensitive=newVal;

	mov	BYTE PTR [eax+545], cl

; 2568 : 	}

	ret	0
?SetSearchCaseSensitive@AFPDFDoc@@QAEX_N@Z ENDP		; AFPDFDoc::SetSearchCaseSensitive
_TEXT	ENDS
PUBLIC	?GetSearchCaseSensitive@AFPDFDoc@@QAE_NXZ	; AFPDFDoc::GetSearchCaseSensitive
; Function compile flags: /Ogtpy
;	COMDAT ?GetSearchCaseSensitive@AFPDFDoc@@QAE_NXZ
_TEXT	SEGMENT
?GetSearchCaseSensitive@AFPDFDoc@@QAE_NXZ PROC		; AFPDFDoc::GetSearchCaseSensitive, COMDAT
; _this$ = eax

; 2560 : 		
; 2561 : 		return m_bCaseSensitive;

	mov	al, BYTE PTR [eax+545]

; 2562 : 	}

	ret	0
?GetSearchCaseSensitive@AFPDFDoc@@QAE_NXZ ENDP		; AFPDFDoc::GetSearchCaseSensitive
_TEXT	ENDS
PUBLIC	?SetSearchPage@AFPDFDoc@@QAEJJ@Z		; AFPDFDoc::SetSearchPage
; Function compile flags: /Ogtpy
;	COMDAT ?SetSearchPage@AFPDFDoc@@QAEJJ@Z
_TEXT	SEGMENT
?SetSearchPage@AFPDFDoc@@QAEJJ@Z PROC			; AFPDFDoc::SetSearchPage, COMDAT
; _this$ = eax
; _lNewValue$ = ecx

; 2554 : 		
; 2555 : 		m_SearchPage=lNewValue;

	mov	DWORD PTR [eax+512], ecx

; 2556 : 		return 0;

	xor	eax, eax

; 2557 : 	}

	ret	0
?SetSearchPage@AFPDFDoc@@QAEJJ@Z ENDP			; AFPDFDoc::SetSearchPage
_TEXT	ENDS
PUBLIC	?GetSearchPage@AFPDFDoc@@QAEJXZ			; AFPDFDoc::GetSearchPage
; Function compile flags: /Ogtpy
;	COMDAT ?GetSearchPage@AFPDFDoc@@QAEJXZ
_TEXT	SEGMENT
?GetSearchPage@AFPDFDoc@@QAEJXZ PROC			; AFPDFDoc::GetSearchPage, COMDAT
; _this$ = eax

; 2548 : 		
; 2549 : 		return m_SearchPage;

	mov	eax, DWORD PTR [eax+512]

; 2550 : 	}

	ret	0
?GetSearchPage@AFPDFDoc@@QAEJXZ ENDP			; AFPDFDoc::GetSearchPage
_TEXT	ENDS
PUBLIC	?GetSearchCount@AFPDFDoc@@QAEJXZ		; AFPDFDoc::GetSearchCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetSearchCount@AFPDFDoc@@QAEJXZ
_TEXT	SEGMENT
?GetSearchCount@AFPDFDoc@@QAEJXZ PROC			; AFPDFDoc::GetSearchCount, COMDAT
; _this$ = eax

; 2410 : 		return m_Selection.GetCount();

	mov	eax, DWORD PTR [eax+324]

; 2411 : 	}

	ret	0
?GetSearchCount@AFPDFDoc@@QAEJXZ ENDP			; AFPDFDoc::GetSearchCount
_TEXT	ENDS
PUBLIC	?GetSearchResults@AFPDFDoc@@QAEPAVCPDFSearchResult@@XZ ; AFPDFDoc::GetSearchResults
; Function compile flags: /Ogtpy
;	COMDAT ?GetSearchResults@AFPDFDoc@@QAEPAVCPDFSearchResult@@XZ
_TEXT	SEGMENT
?GetSearchResults@AFPDFDoc@@QAEPAVCPDFSearchResult@@XZ PROC ; AFPDFDoc::GetSearchResults, COMDAT
; _this$ = eax

; 2406 : 		return m_Selection.ToArray();

	mov	eax, DWORD PTR [eax+320]

; 2407 : 	}

	ret	0
?GetSearchResults@AFPDFDoc@@QAEPAVCPDFSearchResult@@XZ ENDP ; AFPDFDoc::GetSearchResults
_TEXT	ENDS
PUBLIC	?GetPDFVersion@AFPDFDoc@@QAEPA_WXZ		; AFPDFDoc::GetPDFVersion
; Function compile flags: /Ogtpy
;	COMDAT ?GetPDFVersion@AFPDFDoc@@QAEPA_WXZ
_TEXT	SEGMENT
?GetPDFVersion@AFPDFDoc@@QAEPA_WXZ PROC			; AFPDFDoc::GetPDFVersion, COMDAT

; 2069 : #if PDFLIBNET_ORIGINAL
; 2070 : 		string_type strResult;
; 2071 : 		char version[32];
; 2072 : 		if(m_PDFDoc){
; 2073 : 			sprintf(version,"%f",m_PDFDoc->getPDFVersion());
; 2074 : 			strResult=version;
; 2075 : 		}
; 2076 : 		return strResult.AllocSysString();
; 2077 : #else
; 2078 : 		return EmptyChar;

	mov	eax, OFFSET _EmptyChar

; 2079 : #endif
; 2080 : 	}

	ret	0
?GetPDFVersion@AFPDFDoc@@QAEPA_WXZ ENDP			; AFPDFDoc::GetPDFVersion
_TEXT	ENDS
PUBLIC	?SetRenderDPI@AFPDFDoc@@QAEXM@Z			; AFPDFDoc::SetRenderDPI
; Function compile flags: /Ogtpy
;	COMDAT ?SetRenderDPI@AFPDFDoc@@QAEXM@Z
_TEXT	SEGMENT
_newVal$ = 8						; size = 4
?SetRenderDPI@AFPDFDoc@@QAEXM@Z PROC			; AFPDFDoc::SetRenderDPI, COMDAT
; _this$ = eax

; 2063 : 		
; 2064 : 		m_renderDPI = newVal;

	fld	DWORD PTR _newVal$[esp-4]
	fstp	QWORD PTR [eax+536]

; 2065 : 	}

	ret	4
?SetRenderDPI@AFPDFDoc@@QAEXM@Z ENDP			; AFPDFDoc::SetRenderDPI
_TEXT	ENDS
PUBLIC	?GetRenderDPI@AFPDFDoc@@QAEMXZ			; AFPDFDoc::GetRenderDPI
; Function compile flags: /Ogtpy
;	COMDAT ?GetRenderDPI@AFPDFDoc@@QAEMXZ
_TEXT	SEGMENT
tv131 = -4						; size = 4
?GetRenderDPI@AFPDFDoc@@QAEMXZ PROC			; AFPDFDoc::GetRenderDPI, COMDAT
; _this$ = eax

; 2057 : 	{		

	push	ecx

; 2058 : 		return (float)m_renderDPI;

	fld	QWORD PTR [eax+536]
	fstp	DWORD PTR tv131[esp+4]
	fld	DWORD PTR tv131[esp+4]

; 2059 : 	}

	pop	ecx
	ret	0
?GetRenderDPI@AFPDFDoc@@QAEMXZ ENDP			; AFPDFDoc::GetRenderDPI
_TEXT	ENDS
PUBLIC	?GetOutline@AFPDFDoc@@QAEPAVOutlineItemA@@J@Z	; AFPDFDoc::GetOutline
; Function compile flags: /Ogtpy
;	COMDAT ?GetOutline@AFPDFDoc@@QAEPAVOutlineItemA@@J@Z
_TEXT	SEGMENT
?GetOutline@AFPDFDoc@@QAEPAVOutlineItemA@@J@Z PROC	; AFPDFDoc::GetOutline, COMDAT

; 1914 : 		
; 1915 : 		
; 1916 : 		/*if(m_Outline){
; 1917 : 			if(m_Outline->getItems()){
; 1918 : 				if (iOutline > 0 && iOutline <= m_Outline->getItems()->getLength()){
; 1919 : 					OutlineItemA *it=new OutlineItemA; //(m_Outline.items->get(iOutline));		
; 1920 : 					OutlineItem *ol;
; 1921 : 					ol =(OutlineItem *) m_Outline->getItems()->get(iOutline-1);
; 1922 : 					//((IOutlineItemA *)it)->SetOutlineItemXPDF((long)ol);
; 1923 : 					it->IOutlineItemA->SetOutlineItemXPDF((long)ol);
; 1924 : 					//((IOutlineItemA *)it)
; 1925 : 					return (IDispatch *)it;
; 1926 : 				}
; 1927 : 			}
; 1928 : 		}*/
; 1929 : 		return NULL;

	xor	eax, eax

; 1930 : 	}

	ret	0
?GetOutline@AFPDFDoc@@QAEPAVOutlineItemA@@J@Z ENDP	; AFPDFDoc::GetOutline
_TEXT	ENDS
PUBLIC	?GetPageHeight@AFPDFDoc@@QAEJXZ			; AFPDFDoc::GetPageHeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetPageHeight@AFPDFDoc@@QAEJXZ
_TEXT	SEGMENT
?GetPageHeight@AFPDFDoc@@QAEJXZ PROC			; AFPDFDoc::GetPageHeight, COMDAT
; _this$ = eax

; 1907 : 		
; 1908 : 		return m_PageHeight;

	mov	eax, DWORD PTR [eax+516]

; 1909 : 	}

	ret	0
?GetPageHeight@AFPDFDoc@@QAEJXZ ENDP			; AFPDFDoc::GetPageHeight
_TEXT	ENDS
PUBLIC	?GetPageWidth@AFPDFDoc@@QAEJXZ			; AFPDFDoc::GetPageWidth
; Function compile flags: /Ogtpy
;	COMDAT ?GetPageWidth@AFPDFDoc@@QAEJXZ
_TEXT	SEGMENT
?GetPageWidth@AFPDFDoc@@QAEJXZ PROC			; AFPDFDoc::GetPageWidth, COMDAT
; _this$ = eax

; 1901 : 		
; 1902 : 		return m_PageWidth;

	mov	eax, DWORD PTR [eax+520]

; 1903 : 	}

	ret	0
?GetPageWidth@AFPDFDoc@@QAEJXZ ENDP			; AFPDFDoc::GetPageWidth
_TEXT	ENDS
PUBLIC	__real@3fd0000000000000
PUBLIC	?ZoomOut@AFPDFDoc@@QAENXZ			; AFPDFDoc::ZoomOut
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?ZoomOut@AFPDFDoc@@QAENXZ
_TEXT	SEGMENT
?ZoomOut@AFPDFDoc@@QAENXZ PROC				; AFPDFDoc::ZoomOut, COMDAT
; _this$ = eax

; 1796 : 		
; 1797 : 		m_renderDPI =m_renderDPI *  3/4;

	fld	QWORD PTR [eax+536]
	fmul	QWORD PTR __real@4008000000000000
	fmul	QWORD PTR __real@3fd0000000000000
	fst	QWORD PTR [eax+536]

; 1798 : 		return m_renderDPI;
; 1799 : 	}

	ret	0
?ZoomOut@AFPDFDoc@@QAENXZ ENDP				; AFPDFDoc::ZoomOut
_TEXT	ENDS
PUBLIC	?ZoomIN@AFPDFDoc@@QAENXZ			; AFPDFDoc::ZoomIN
; Function compile flags: /Ogtpy
;	COMDAT ?ZoomIN@AFPDFDoc@@QAENXZ
_TEXT	SEGMENT
?ZoomIN@AFPDFDoc@@QAENXZ PROC				; AFPDFDoc::ZoomIN, COMDAT
; _this$ = eax

; 1790 : 		m_renderDPI =m_renderDPI * 4 / 3;

	fld	QWORD PTR [eax+536]
	fmul	QWORD PTR __real@4010000000000000
	fdiv	QWORD PTR __real@4008000000000000
	fst	QWORD PTR [eax+536]

; 1791 : 		return m_renderDPI;
; 1792 : 	}

	ret	0
?ZoomIN@AFPDFDoc@@QAENXZ ENDP				; AFPDFDoc::ZoomIN
_TEXT	ENDS
PUBLIC	?SetCurrentY@AFPDFDoc@@QAEXJ@Z			; AFPDFDoc::SetCurrentY
; Function compile flags: /Ogtpy
;	COMDAT ?SetCurrentY@AFPDFDoc@@QAEXJ@Z
_TEXT	SEGMENT
?SetCurrentY@AFPDFDoc@@QAEXJ@Z PROC			; AFPDFDoc::SetCurrentY, COMDAT
; _this$ = eax
; _newVal$ = ecx

; 1600 : 		
; 1601 : 		m_ViewOffsetY = newVal;

	mov	DWORD PTR [eax+500], ecx

; 1602 : 	}

	ret	0
?SetCurrentY@AFPDFDoc@@QAEXJ@Z ENDP			; AFPDFDoc::SetCurrentY
_TEXT	ENDS
PUBLIC	?GetCurrentY@AFPDFDoc@@QAEJXZ			; AFPDFDoc::GetCurrentY
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentY@AFPDFDoc@@QAEJXZ
_TEXT	SEGMENT
?GetCurrentY@AFPDFDoc@@QAEJXZ PROC			; AFPDFDoc::GetCurrentY, COMDAT
; _this$ = eax

; 1594 : 		
; 1595 : 		return m_ViewOffsetY;

	mov	eax, DWORD PTR [eax+500]

; 1596 : 	}

	ret	0
?GetCurrentY@AFPDFDoc@@QAEJXZ ENDP			; AFPDFDoc::GetCurrentY
_TEXT	ENDS
PUBLIC	?SetCurrentX@AFPDFDoc@@QAEXJ@Z			; AFPDFDoc::SetCurrentX
; Function compile flags: /Ogtpy
;	COMDAT ?SetCurrentX@AFPDFDoc@@QAEXJ@Z
_TEXT	SEGMENT
?SetCurrentX@AFPDFDoc@@QAEXJ@Z PROC			; AFPDFDoc::SetCurrentX, COMDAT
; _this$ = eax
; _newVal$ = ecx

; 1588 : 		
; 1589 : 		m_ViewOffsetX = newVal;

	mov	DWORD PTR [eax+496], ecx

; 1590 : 	}

	ret	0
?SetCurrentX@AFPDFDoc@@QAEXJ@Z ENDP			; AFPDFDoc::SetCurrentX
_TEXT	ENDS
PUBLIC	?GetCurrentX@AFPDFDoc@@QAEJXZ			; AFPDFDoc::GetCurrentX
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentX@AFPDFDoc@@QAEJXZ
_TEXT	SEGMENT
?GetCurrentX@AFPDFDoc@@QAEJXZ PROC			; AFPDFDoc::GetCurrentX, COMDAT
; _this$ = eax

; 1582 : 		
; 1583 : 		return m_ViewOffsetX;

	mov	eax, DWORD PTR [eax+496]

; 1584 : 	}

	ret	0
?GetCurrentX@AFPDFDoc@@QAEJXZ ENDP			; AFPDFDoc::GetCurrentX
_TEXT	ENDS
PUBLIC	?SetCurrentPage@AFPDFDoc@@QAEXJ@Z		; AFPDFDoc::SetCurrentPage
; Function compile flags: /Ogtpy
;	COMDAT ?SetCurrentPage@AFPDFDoc@@QAEXJ@Z
_TEXT	SEGMENT
?SetCurrentPage@AFPDFDoc@@QAEXJ@Z PROC			; AFPDFDoc::SetCurrentPage, COMDAT
; _this$ = eax
; _newVal$ = ecx

; 1577 : 		m_CurrentPage = newVal;

	mov	DWORD PTR [eax+504], ecx

; 1578 : 	}

	ret	0
?SetCurrentPage@AFPDFDoc@@QAEXJ@Z ENDP			; AFPDFDoc::SetCurrentPage
_TEXT	ENDS
PUBLIC	?GetCurrentPage@AFPDFDoc@@QAEJXZ		; AFPDFDoc::GetCurrentPage
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentPage@AFPDFDoc@@QAEJXZ
_TEXT	SEGMENT
?GetCurrentPage@AFPDFDoc@@QAEJXZ PROC			; AFPDFDoc::GetCurrentPage, COMDAT
; _this$ = eax

; 1571 : 		
; 1572 : 		return m_CurrentPage;

	mov	eax, DWORD PTR [eax+504]

; 1573 : 	}

	ret	0
?GetCurrentPage@AFPDFDoc@@QAEJXZ ENDP			; AFPDFDoc::GetCurrentPage
_TEXT	ENDS
PUBLIC	?CancelThumbRenderCallback@AFPDFDoc@@CAXPAX@Z	; AFPDFDoc::CancelThumbRenderCallback
; Function compile flags: /Ogtpy
;	COMDAT ?CancelThumbRenderCallback@AFPDFDoc@@CAXPAX@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
?CancelThumbRenderCallback@AFPDFDoc@@CAXPAX@Z PROC	; AFPDFDoc::CancelThumbRenderCallback, COMDAT

; 1260 : 	{

	push	esi

; 1261 : 		threadParamThumb *p = (threadParamThumb *)param;
; 1262 : 		p->finishNotify( p->pageToRender, false );

	mov	esi, DWORD PTR _param$[esp]
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [esi+24]
	push	0
	push	eax
	call	ecx

; 1263 : 		delete p;

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi

; 1264 : 	}

	ret	0
?CancelThumbRenderCallback@AFPDFDoc@@CAXPAX@Z ENDP	; AFPDFDoc::CancelThumbRenderCallback
_TEXT	ENDS
PUBLIC	?callbackAbortDisplay@AFPDFDoc@@KAHPAX@Z	; AFPDFDoc::callbackAbortDisplay
; Function compile flags: /Ogtpy
;	COMDAT ?callbackAbortDisplay@AFPDFDoc@@KAHPAX@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?callbackAbortDisplay@AFPDFDoc@@KAHPAX@Z PROC		; AFPDFDoc::callbackAbortDisplay, COMDAT

; 1218 : 	{

	push	esi

; 1219 : 		AFPDFDoc *doc =(AFPDFDoc *)data;
; 1220 : 		
; 1221 : 		if(::InterlockedExchange(&doc->g_lLocker,0)!=0){

	mov	esi, DWORD PTR _data$[esp]
	push	edi
	mov	edi, DWORD PTR __imp__InterlockedExchange@8
	push	0
	add	esi, 164				; 000000a4H
	push	esi
	call	edi
	test	eax, eax
	je	SHORT $LN1@callbackAb

; 1222 : 			::InterlockedExchange(&doc->g_lLocker,1);

	push	1
	push	esi
	call	edi
	pop	edi

; 1223 : 			return gTrue;

	mov	eax, 1
	pop	esi

; 1226 : 	}

	ret	0
$LN1@callbackAb:
	pop	edi

; 1224 : 		}
; 1225 : 		return gFalse;

	xor	eax, eax
	pop	esi

; 1226 : 	}

	ret	0
?callbackAbortDisplay@AFPDFDoc@@KAHPAX@Z ENDP		; AFPDFDoc::callbackAbortDisplay
_TEXT	ENDS
PUBLIC	?SetOwnerPassword@AFPDFDoc@@QAEXPAD@Z		; AFPDFDoc::SetOwnerPassword
; Function compile flags: /Ogtpy
;	COMDAT ?SetOwnerPassword@AFPDFDoc@@QAEXPAD@Z
_TEXT	SEGMENT
?SetOwnerPassword@AFPDFDoc@@QAEXPAD@Z PROC		; AFPDFDoc::SetOwnerPassword, COMDAT
; _this$ = ecx
; _owner_password$ = eax

; 641  : 		m_OwnerPassword = owner_password;

	push	eax
	add	ecx, 356				; 00000164H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 642  : 	}

	ret	0
?SetOwnerPassword@AFPDFDoc@@QAEXPAD@Z ENDP		; AFPDFDoc::SetOwnerPassword
_TEXT	ENDS
PUBLIC	?SetUserPassword@AFPDFDoc@@QAEXPAD@Z		; AFPDFDoc::SetUserPassword
; Function compile flags: /Ogtpy
;	COMDAT ?SetUserPassword@AFPDFDoc@@QAEXPAD@Z
_TEXT	SEGMENT
?SetUserPassword@AFPDFDoc@@QAEXPAD@Z PROC		; AFPDFDoc::SetUserPassword, COMDAT
; _this$ = ecx
; _user_password$ = eax

; 638  : 		m_UserPassword = user_password;

	push	eax
	add	ecx, 384				; 00000180H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 639  : 	}

	ret	0
?SetUserPassword@AFPDFDoc@@QAEXPAD@Z ENDP		; AFPDFDoc::SetUserPassword
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GPageMemory@@QAEPAXI@Z
_TEXT	SEGMENT
??_GPageMemory@@QAEPAXI@Z PROC				; PageMemory::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@scalar@2
	push	eax
	call	DWORD PTR __imp__DeleteObject@4
$LN6@scalar@2:
	push	esi
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	ret	0
??_GPageMemory@@QAEPAXI@Z ENDP				; PageMemory::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?InvalidateBitmapCache@AFPDFDoc@@AAEXXZ		; AFPDFDoc::InvalidateBitmapCache
; Function compile flags: /Ogtpy
;	COMDAT ?InvalidateBitmapCache@AFPDFDoc@@AAEXXZ
_TEXT	SEGMENT
?InvalidateBitmapCache@AFPDFDoc@@AAEXXZ PROC		; AFPDFDoc::InvalidateBitmapCache, COMDAT
; _this$ = eax

; 444  : 	void		AFPDFDoc::InvalidateBitmapCache(){

	push	ebx
	push	ebp
	push	esi

; 445  : 		
; 446  : 			for(int i=0;i<MAX_BITMAP_CACHE;i++){

	mov	esi, eax
	add	esi, 12					; 0000000cH
	push	edi
	mov	ebp, 16					; 00000010H
	xor	ebx, ebx
$LL4@Invalidate:

; 447  : 				if(_bitmapCache[i]!=0){

	mov	edi, DWORD PTR [esi]
	cmp	edi, ebx
	je	SHORT $LN7@Invalidate

; 448  : 					_bitmapCache[i]->Dispose();

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, ebx
	je	SHORT $LN9@Invalidate
	push	eax
	call	DWORD PTR __imp__DeleteObject@4
$LN9@Invalidate:
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi], ebx

; 449  : 					delete _bitmapCache[i];

	mov	edi, DWORD PTR [esi]
	cmp	edi, ebx
	je	SHORT $LN7@Invalidate
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, ebx
	je	SHORT $LN17@Invalidate
	push	eax
	call	DWORD PTR __imp__DeleteObject@4
$LN17@Invalidate:
	push	edi
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi], ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@Invalidate:

; 450  : 				}
; 451  : 				_bitmapCache[i]=0;

	mov	DWORD PTR [esi], ebx

; 452  : 				_pageCached[i]=0;

	mov	DWORD PTR [esi+68], ebx
	add	esi, 4
	sub	ebp, 1
	jne	SHORT $LL4@Invalidate
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 453  : 			}
; 454  : 		}

	ret	0
?InvalidateBitmapCache@AFPDFDoc@@AAEXXZ ENDP		; AFPDFDoc::InvalidateBitmapCache
_TEXT	ENDS
PUBLIC	?GetBitmapCache@AFPDFDoc@@AAEPAVPageMemory@@H@Z	; AFPDFDoc::GetBitmapCache
; Function compile flags: /Ogtpy
;	COMDAT ?GetBitmapCache@AFPDFDoc@@AAEPAVPageMemory@@H@Z
_TEXT	SEGMENT
?GetBitmapCache@AFPDFDoc@@AAEPAVPageMemory@@H@Z PROC	; AFPDFDoc::GetBitmapCache, COMDAT
; _this$ = esi
; _page$ = edx

; 436  : 		for(int i=0;i<MAX_BITMAP_CACHE;i++){

	xor	eax, eax
	lea	ecx, DWORD PTR [esi+80]
$LL4@GetBitmapC:

; 437  : 			if(_pageCached[i]==page){

	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN8@GetBitmapC
	inc	eax
	add	ecx, 4
	cmp	eax, 16					; 00000010H
	jl	SHORT $LL4@GetBitmapC

; 439  : 			}
; 440  : 		}
; 441  : 		return 0;

	xor	eax, eax

; 442  : 	}

	ret	0
$LN8@GetBitmapC:

; 438  : 				return _bitmapCache[i];

	mov	eax, DWORD PTR [esi+eax*4+12]

; 442  : 	}

	ret	0
?GetBitmapCache@AFPDFDoc@@AAEPAVPageMemory@@H@Z ENDP	; AFPDFDoc::GetBitmapCache
_TEXT	ENDS
PUBLIC	??0CPDFSearchResult@@QAE@VCRect@@J@Z		; CPDFSearchResult::CPDFSearchResult
; Function compile flags: /Ogtpy
;	COMDAT ??0CPDFSearchResult@@QAE@VCRect@@J@Z
_TEXT	SEGMENT
_r$ = 8							; size = 24
_lPage$ = 32						; size = 4
??0CPDFSearchResult@@QAE@VCRect@@J@Z PROC		; CPDFSearchResult::CPDFSearchResult, COMDAT
; _this$ = eax

; 426  : 	{

	mov	ecx, DWORD PTR _r$[esp-4]
	mov	edx, DWORD PTR _r$[esp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _r$[esp+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _r$[esp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _r$[esp+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR _r$[esp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _lPage$[esp-4]
	mov	DWORD PTR [eax+20], edx
	mov	DWORD PTR [eax+24], ecx

; 427  : 		//
; 428  : 	}

	ret	28					; 0000001cH
??0CPDFSearchResult@@QAE@VCRect@@J@Z ENDP		; CPDFSearchResult::CPDFSearchResult
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getDicString@@YAPA_WPAVDict@@PADPAVUnicodeMap@@@Z
_TEXT	SEGMENT
?getDicString@@YAPA_WPAVDict@@PADPAVUnicodeMap@@@Z PROC	; getDicString, COMDAT

; 351  : #ifdef PDFLIBNET_ORIGINAL
; 352  : 		Object obj;
; 353  : 		GString *s1;
; 354  : 		GBool isUnicode;
; 355  : 		Unicode u;
; 356  : //		char buf[8];
; 357  : 		int i;
; 358  : 
; 359  : 	
; 360  : 		if (infoDict->lookup(key, &obj)->isString()) 
; 361  : 		{
; 362  : 			//fputs(text1, f);
; 363  : 			s1 = obj.getString();
; 364  : 			if(s1->getLength() > 0){
; 365  : 				if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getChar(1) & 0xff) == 0xff) {
; 366  : 					isUnicode = gTrue;
; 367  : 					i = 2;
; 368  : 				} else {
; 369  : 					isUnicode = gFalse;
; 370  : 					i = 0;
; 371  : 				}
; 372  : 				
; 373  : 				wchar_t *ret =new wchar_t[s1->getLength()+1];
; 374  : 				int j=0;
; 375  : 				i=0;
; 376  : 				while (i < s1->getLength()) {
; 377  : 					  if (isUnicode) {
; 378  : 							u = ((s1->getChar(i) & 0xff) << 8) |  (s1->getChar(i+1) & 0xff);
; 379  : 							i += 2;
; 380  : 					  } else {
; 381  : 							u = s1->getChar(i) & 0xff;
; 382  : 							++i;
; 383  : 					  }
; 384  : 					  ret[j] = u;
; 385  : 					  j++;
; 386  : 				}
; 387  : 				ret[j]='\0';
; 388  : 				
; 389  : 				return ret;
; 390  : 			}
; 391  : 
; 392  : 		}
; 393  : #endif
; 394  : 		return EmptyChar;

	mov	eax, OFFSET _EmptyChar

; 395  : 		
; 396  : 	}

	ret	0
?getDicString@@YAPA_WPAVDict@@PADPAVUnicodeMap@@@Z ENDP	; getDicString
_TEXT	ENDS
PUBLIC	?GetUnicodeString@@YAPAIPB_WH@Z			; GetUnicodeString
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnicodeString@@YAPAIPB_WH@Z
_TEXT	SEGMENT
?GetUnicodeString@@YAPAIPB_WH@Z PROC			; GetUnicodeString, COMDAT
; _str$ = edi
; _length$ = esi

; 336  : 		Unicode * ucstring = new Unicode[length + 1];

	xor	ecx, ecx
	lea	eax, DWORD PTR [esi+1]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 337  : 		int j;
; 338  : 
; 339  : 		if (ucstring == NULL)

	test	eax, eax
	jne	SHORT $LN4@GetUnicode

; 347  : 		return ucstring;
; 348  : 	}

	ret	0
$LN4@GetUnicode:

; 340  : 			return NULL;
; 341  : 
; 342  : 		/* it is almost safe to transform from UCS2 to UCS4 this way */
; 343  : 		for( j = 0; j < length; j++)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN1@GetUnicode
$LL3@GetUnicode:

; 344  : 			ucstring[j] = str[j];

	movzx	edx, WORD PTR [edi+ecx*2]
	mov	DWORD PTR [eax+ecx*4], edx
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL3@GetUnicode
$LN1@GetUnicode:

; 345  : 
; 346  : 		ucstring[j] = 0;

	mov	DWORD PTR [eax+ecx*4], 0

; 347  : 		return ucstring;
; 348  : 	}

	ret	0
?GetUnicodeString@@YAPAIPB_WH@Z ENDP			; GetUnicodeString
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0threadParamThumb@@QAE@PAUHDC__@@PAVSplashOutputDev@@PAVPDFDoc@@HPAVQueue@@PAX@Z
_TEXT	SEGMENT
_hdc$ = 8						; size = 4
_outDev$ = 12						; size = 4
_queued$ = 16						; size = 4
_finishCallback$ = 20					; size = 4
??0threadParamThumb@@QAE@PAUHDC__@@PAVSplashOutputDev@@PAVPDFDoc@@HPAVQueue@@PAX@Z PROC ; threadParamThumb::threadParamThumb, COMDAT
; _this$ = esi
; _pdfdoc$ = ecx
; _page$ = eax

; 42   : 			pageToRender=page;
; 43   : 			doc =pdfdoc;
; 44   : 			out = new AuxOutputDev(outDev);

	push	48					; 00000030H
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [esi+16], ecx
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN3@threadPara
	fldz
	mov	edx, DWORD PTR _outDev$[esp-4]
	fst	QWORD PTR [eax+24]
	mov	DWORD PTR [eax], OFFSET ??_7AuxOutputDev@@6B@
	fstp	QWORD PTR [eax+32]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	BYTE PTR [eax+40], 1
	mov	DWORD PTR [eax+44], ecx
	jmp	SHORT $LN4@threadPara
$LN3@threadPara:
	xor	eax, eax
$LN4@threadPara:

; 45   : 			hgMutex=0;
; 46   : 			finishNotify=(PAGERENDERNOTIFY)finishCallback;
; 47   : 			que = queued;
; 48   : 			hDC = hdc;

	mov	edx, DWORD PTR _hdc$[esp-4]
	mov	DWORD PTR [esi+28], eax
	mov	eax, DWORD PTR _finishCallback$[esp-4]
	mov	DWORD PTR [esi+20], ecx
	mov	ecx, DWORD PTR _queued$[esp-4]
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+32], ecx
	mov	DWORD PTR [esi+36], edx

; 49   : 		}

	mov	eax, esi
	ret	16					; 00000010H
??0threadParamThumb@@QAE@PAUHDC__@@PAVSplashOutputDev@@PAVPDFDoc@@HPAVQueue@@PAX@Z ENDP ; threadParamThumb::threadParamThumb
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0threadParam@@QAE@PAVAFPDFDoc@@H@Z
_TEXT	SEGMENT
??0threadParam@@QAE@PAVAFPDFDoc@@H@Z PROC		; threadParam::threadParam, COMDAT
; _this$ = eax
; _pdfDoc$ = ecx
; _page$ = edx

; 28   : 			doc=pdfDoc;

	mov	DWORD PTR [eax], ecx

; 29   : 			enablePreRender=true;

	mov	BYTE PTR [eax+8], 1

; 30   : 			pageToRender=page;

	mov	DWORD PTR [eax+12], edx

; 31   : 		}

	ret	0
??0threadParam@@QAE@PAVAFPDFDoc@@H@Z ENDP		; threadParam::threadParam
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\auxoutputdev.h
_TEXT	ENDS
;	COMDAT ?setPixmap@AuxOutputDev@@QAEXPAUfz_pixmap_s@@@Z
_TEXT	SEGMENT
?setPixmap@AuxOutputDev@@QAEXPAUfz_pixmap_s@@@Z PROC	; AuxOutputDev::setPixmap, COMDAT
; _this$ = eax
; _pixmap$ = ecx

; 56   : 	void setPixmap(fz_pixmap *pixmap){ _pixmap=pixmap; }

	mov	DWORD PTR [eax+44], ecx
	ret	0
?setPixmap@AuxOutputDev@@QAEXPAUfz_pixmap_s@@@Z ENDP	; AuxOutputDev::setPixmap
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setSize@AuxOutputDev@@QAEXNN@Z
_TEXT	SEGMENT
_w$ = 8							; size = 8
_h$ = 16						; size = 8
?setSize@AuxOutputDev@@QAEXNN@Z PROC			; AuxOutputDev::setSize, COMDAT
; _this$ = eax

; 42   : 	void setSize(double w, double h){ _width = w; _height = h; }

	fld	QWORD PTR _w$[esp-4]
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR _h$[esp-4]
	fstp	QWORD PTR [eax+32]
	ret	16					; 00000010H
?setSize@AuxOutputDev@@QAEXNN@Z ENDP			; AuxOutputDev::setSize
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\crect.h
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT
??0CRect@@QAE@XZ PROC					; CRect::CRect, COMDAT
; _this$ = eax

; 31   : 		left=right=top=bottom=width=height=0;

	xor	ecx, ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], ecx

; 32   : 	}

	ret	0
??0CRect@@QAE@XZ ENDP					; CRect::CRect
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?DeflateRect@CRect@@QAEXHH@Z
_TEXT	SEGMENT
?DeflateRect@CRect@@QAEXHH@Z PROC			; CRect::DeflateRect, COMDAT
; _this$ = eax

; 28   : 		::InflateRect(this,-dx,-dy);

	push	-1
	push	-1
	push	eax
	call	DWORD PTR __imp__InflateRect@12

; 29   : 	}

	ret	0
?DeflateRect@CRect@@QAEXHH@Z ENDP			; CRect::DeflateRect
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?InflateRect@CRect@@QAEXHH@Z
_TEXT	SEGMENT
?InflateRect@CRect@@QAEXHH@Z PROC			; CRect::InflateRect, COMDAT
; _this$ = eax

; 25   : 		::InflateRect(this,dx,dy);

	push	0
	push	1
	push	eax
	call	DWORD PTR __imp__InflateRect@12

; 26   : 	}

	ret	0
?InflateRect@CRect@@QAEXHH@Z ENDP			; CRect::InflateRect
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?OffsetRect@CRect@@QAEXHH@Z
_TEXT	SEGMENT
?OffsetRect@CRect@@QAEXHH@Z PROC			; CRect::OffsetRect, COMDAT
; _this$ = edx
; _dx$ = ecx
; _dy$ = eax

; 21   : 		::OffsetRect(this,dx,dy);

	push	eax
	push	ecx
	push	edx
	call	DWORD PTR __imp__OffsetRect@12

; 22   : 	}

	ret	0
?OffsetRect@CRect@@QAEXHH@Z ENDP			; CRect::OffsetRect
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?NotEmpty@CRect@@QAE_NXZ
_TEXT	SEGMENT
?NotEmpty@CRect@@QAE_NXZ PROC				; CRect::NotEmpty, COMDAT
; _this$ = eax

; 18   : 		return (width>0 || height>0 || left>0 || top>0);

	cmp	DWORD PTR [eax+16], 0
	jg	SHORT $LN3@NotEmpty
	cmp	DWORD PTR [eax+20], 0
	jg	SHORT $LN3@NotEmpty
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN3@NotEmpty
	cmp	DWORD PTR [eax+4], 0
	jg	SHORT $LN3@NotEmpty
	xor	eax, eax

; 19   : 	}

	ret	0
$LN3@NotEmpty:

; 18   : 		return (width>0 || height>0 || left>0 || top>0);

	mov	eax, 1

; 19   : 	}

	ret	0
?NotEmpty@CRect@@QAE_NXZ ENDP				; CRect::NotEmpty
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\queue.h
_TEXT	ENDS
;	COMDAT ?unlock@Queue@@QAEXXZ
_TEXT	SEGMENT
?unlock@Queue@@QAEXXZ PROC				; Queue::unlock, COMDAT
; _this$ = eax

; 144  : 		::LeaveCriticalSection(&lock);

	add	eax, 12					; 0000000cH
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 145  : 	}

	ret	0
?unlock@Queue@@QAEXXZ ENDP				; Queue::unlock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?enterlock@Queue@@QAEXXZ
_TEXT	SEGMENT
?enterlock@Queue@@QAEXXZ PROC				; Queue::enterlock, COMDAT
; _this$ = eax

; 141  : 		::EnterCriticalSection(&lock);

	add	eax, 12					; 0000000cH
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 142  : 	}

	ret	0
?enterlock@Queue@@QAEXXZ ENDP				; Queue::enterlock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clearall@Queue@@QAE_NP6AXPAX@Z@Z
_TEXT	SEGMENT
tv192 = -4						; size = 4
?clearall@Queue@@QAE_NP6AXPAX@Z@Z PROC			; Queue::clearall, COMDAT
; _this$ = esi

; 118  : 	bool clearall( void (*callback)( void * ) ) {

	push	ecx
	push	ebp

; 119  : 		::EnterCriticalSection(&lock);

	lea	ebp, DWORD PTR [esi+12]
	push	ebp
	mov	DWORD PTR tv192[esp+12], ebp
	call	DWORD PTR __imp__EnterCriticalSection@4

; 120  : 
; 121  : 		if( !queue.GetCount() && !delQueue.GetCount() ) {

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	jne	SHORT $LN38@clearall
	cmp	DWORD PTR [esi+60], eax
	jne	SHORT $LN38@clearall

; 122  : 			::LeaveCriticalSection(&lock);

	push	ebp
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 123  : 			return false;

	xor	al, al
	pop	ebp

; 138  : 	}

	pop	ecx
	ret	0
$LN38@clearall:
	push	edi

; 124  : 		}
; 125  : 
; 126  : 		// Delete all queue
; 127  : 		while( queue.GetCount() ) {

	test	eax, eax
	je	$LN40@clearall

; 129  : 			queue.Delete( 0 );

	mov	ebp, DWORD PTR __imp__realloc
$LL4@clearall:

; 128  : 			callback( queue[0] );

	mov	eax, DWORD PTR [esi+44]
	mov	edi, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi+44]
	mov	edx, DWORD PTR [edi+24]
	push	0
	push	ecx
	call	edx
	push	edi
	call	??3@YAXPAX@Z				; operator delete

; 129  : 			queue.Delete( 0 );

	mov	ecx, DWORD PTR [esi+48]
	add	esp, 4
	cmp	ecx, 1
	jne	SHORT $LN29@clearall
	mov	eax, DWORD PTR [esi+44]
	push	512					; 00000200H
	push	eax
	mov	DWORD PTR [esi+48], 0
	call	ebp
	add	esp, 8
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [esi+52], 128			; 00000080H
	jmp	SHORT $LN44@clearall
$LN29@clearall:
	test	ecx, ecx
	jbe	SHORT $LN44@clearall
	xor	eax, eax
	add	ecx, -1
	je	SHORT $LN24@clearall
$LL26@clearall:
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [esi+48]
	inc	eax
	dec	ecx
	cmp	eax, ecx
	jb	SHORT $LL26@clearall
$LN24@clearall:
	dec	DWORD PTR [esi+48]
$LN44@clearall:

; 130  : 			WaitForSingleObject( handles[SemaphoreIndex], INFINITE );

	mov	edx, DWORD PTR [esi+4]
	push	-1
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8
	cmp	DWORD PTR [esi+48], 0
	jne	SHORT $LL4@clearall

; 124  : 		}
; 125  : 
; 126  : 		// Delete all queue
; 127  : 		while( queue.GetCount() ) {

	mov	ebp, DWORD PTR tv192[esp+12]
$LN40@clearall:

; 131  : 		}
; 132  : 		// Wait for rendering thumb thread
; 133  : 		while( delQueue.GetCount() )

	cmp	DWORD PTR [esi+60], 0
	je	SHORT $LN1@clearall
	mov	edi, DWORD PTR __imp__Sleep@4
	npad	2
$LL2@clearall:

; 134  : 			Sleep( 10 );

	push	10					; 0000000aH
	call	edi
	cmp	DWORD PTR [esi+60], 0
	jne	SHORT $LL2@clearall
$LN1@clearall:

; 135  : 
; 136  : 		::LeaveCriticalSection(&lock);

	push	ebp
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	edi

; 137  : 		return true;

	mov	al, 1
	pop	ebp

; 138  : 	}

	pop	ecx
	ret	0
?clearall@Queue@@QAE_NP6AXPAX@Z@Z ENDP			; Queue::clearall
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?shutdown@Queue@@QAEXXZ
_TEXT	SEGMENT
?shutdown@Queue@@QAEXXZ PROC				; Queue::shutdown, COMDAT
; _this$ = eax

; 111  : 		::SetEvent(handles[StopperIndex]);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4

; 112  : 	} // shutdown

	ret	0
?shutdown@Queue@@QAEXXZ ENDP				; Queue::shutdown
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?RemoveHead@Queue@@QAEPAXXZ
_TEXT	SEGMENT
_result$ = -4						; size = 4
?RemoveHead@Queue@@QAEPAXXZ PROC			; Queue::RemoveHead, COMDAT
; _this$ = eax

; 57   : 	{ 

	push	ecx
	push	ebx
	push	ebp

; 58   : 		LPVOID result;
; 59   : 		DWORD woIndex;
; 60   : 		lastResult=mylastResult;
; 61   : 
; 62   : 		do {
; 63   : 			woIndex = ::WaitForMultipleObjects(3, handles, FALSE, INFINITE);

	mov	ebp, DWORD PTR __imp__WaitForMultipleObjects@16
	push	esi
	push	edi
	push	-1
	mov	edi, eax
	mov	eax, DWORD PTR [edi+40]
	push	0
	push	edi
	push	3
	mov	DWORD PTR [edi+36], eax
	call	ebp

; 64   : 			if( ::TryEnterCriticalSection( &lock ) )

	lea	ebx, DWORD PTR [edi+12]
	push	ebx
	mov	esi, eax
	call	DWORD PTR __imp__TryEnterCriticalSection@4
	test	eax, eax
	jne	SHORT $LN14@RemoveHead
	npad	4
$LL16@RemoveHead:

; 65   : 				break;
; 66   : 			switch( woIndex ) {

	sub	esi, 0
	je	SHORT $LN9@RemoveHead
	sub	esi, 1
	je	SHORT $LN8@RemoveHead
	sub	esi, 1
	jne	SHORT $LN15@RemoveHead

; 67   : 				case CancelIndex:
; 68   : 					ResetEvent( handles[CancelIndex] );

	mov	ecx, DWORD PTR [edi+8]
	push	ecx

; 69   : 					break;

	jmp	SHORT $LN31@RemoveHead
$LN8@RemoveHead:

; 72   : 					break;
; 73   : 				case SemaphoreIndex:
; 74   : 					ReleaseSemaphore( handles[SemaphoreIndex], 1, NULL );

	mov	edx, DWORD PTR [edi+4]
	push	0
	push	1
	push	edx
	call	DWORD PTR __imp__ReleaseSemaphore@12

; 75   : 					break;

	jmp	SHORT $LN15@RemoveHead
$LN9@RemoveHead:

; 70   : 				case StopperIndex:
; 71   : 					ResetEvent( handles[StopperIndex] );

	mov	eax, DWORD PTR [edi]
	push	eax
$LN31@RemoveHead:
	call	DWORD PTR __imp__ResetEvent@4
$LN15@RemoveHead:

; 58   : 		LPVOID result;
; 59   : 		DWORD woIndex;
; 60   : 		lastResult=mylastResult;
; 61   : 
; 62   : 		do {
; 63   : 			woIndex = ::WaitForMultipleObjects(3, handles, FALSE, INFINITE);

	push	-1
	push	0
	push	edi
	push	3
	call	ebp

; 64   : 			if( ::TryEnterCriticalSection( &lock ) )

	push	ebx
	mov	esi, eax
	call	DWORD PTR __imp__TryEnterCriticalSection@4
	test	eax, eax
	je	SHORT $LL16@RemoveHead
$LN14@RemoveHead:

; 76   : 			}
; 77   : 		} while( true );
; 78   : 		switch( woIndex )

	sub	esi, 0
	je	$LN2@RemoveHead
	sub	esi, 1
	je	SHORT $LN1@RemoveHead
	sub	esi, 1

; 102  : 		}
; 103  : 		return NULL;

	jne	SHORT $LN32@RemoveHead

; 79   : 		{
; 80   : 		case CancelIndex:
; 81   : 			if(queue.GetCount()>0){

	cmp	DWORD PTR [edi+48], esi
	jbe	SHORT $LN4@RemoveHead

; 82   : 				result = queue[0];

	mov	ecx, DWORD PTR [edi+44]
	lea	esi, DWORD PTR [edi+44]
	mov	edi, DWORD PTR [ecx]

; 83   : 				queue.Delete(0);

	call	?Delete@?$DynArray@PAX@@QAEXI@Z		; DynArray<void *>::Delete

; 84   : 				delete result;

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 87   : 			::LeaveCriticalSection(&lock);

	push	ebx
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	edi
	pop	esi
	pop	ebp

; 88   : 			return NULL;

	xor	eax, eax
	pop	ebx

; 104  : 	} // RemoveHead

	pop	ecx
	ret	0
$LN4@RemoveHead:

; 85   : 			}else
; 86   : 				::ResetEvent(handles[CancelIndex]);

	mov	edx, DWORD PTR [edi+8]
	push	edx
	call	DWORD PTR __imp__ResetEvent@4

; 87   : 			::LeaveCriticalSection(&lock);

	push	ebx
	call	DWORD PTR __imp__LeaveCriticalSection@4
$LN32@RemoveHead:
	pop	edi
	pop	esi
	pop	ebp

; 88   : 			return NULL;

	xor	eax, eax
	pop	ebx

; 104  : 	} // RemoveHead

	pop	ecx
	ret	0
$LN1@RemoveHead:

; 93   : 			return NULL;     
; 94   : 		case SemaphoreIndex: // semaphore
; 95   : 			result = queue[0];

	mov	eax, DWORD PTR [edi+44]
	mov	ebp, DWORD PTR [eax]

; 96   : 			delQueue.Add(result);

	lea	ecx, DWORD PTR _result$[esp+20]
	push	ecx
	lea	esi, DWORD PTR [edi+56]
	mov	DWORD PTR _result$[esp+24], ebp
	call	?Add@?$DynArray@PAX@@QAEXABQAX@Z	; DynArray<void *>::Add

; 97   : 			queue.Delete(0);

	lea	esi, DWORD PTR [edi+44]
	call	?Delete@?$DynArray@PAX@@QAEXI@Z		; DynArray<void *>::Delete

; 98   : 			lastResult=result;
; 99   : 			mylastResult=result;
; 100  : 			::LeaveCriticalSection(&lock);

	push	ebx
	mov	DWORD PTR [edi+36], ebp
	mov	DWORD PTR [edi+40], ebp
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	edi
	pop	esi

; 101  : 			return result;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 104  : 	} // RemoveHead

	pop	ecx
	ret	0
$LN2@RemoveHead:

; 89   : 			break;
; 90   : 		case StopperIndex:   // shut down thread
; 91   : 			::LeaveCriticalSection(&lock);

	push	ebx
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 92   : 			ExitThread(0); //KillThread

	push	0
	call	DWORD PTR __imp__ExitThread@4
$LN33@RemoveHead:
$LN30@RemoveHead:
	int	3
?RemoveHead@Queue@@QAEPAXXZ ENDP			; Queue::RemoveHead
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?AddTail@Queue@@QAEHPAX@Z
_TEXT	SEGMENT
$T160836 = 8						; size = 4
_p$ = 8							; size = 4
?AddTail@Queue@@QAEHPAX@Z PROC				; Queue::AddTail, COMDAT
; _this$ = eax

; 45   : 	{ 

	push	ebx
	push	esi
	push	edi
	mov	edi, eax

; 46   : 		BOOL result;
; 47   : 		::EnterCriticalSection(&lock);

	lea	ebx, DWORD PTR [edi+12]
	push	ebx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 48   : 		queue.Add(p);

	inc	DWORD PTR [edi+48]
	mov	ecx, DWORD PTR [edi+48]
	mov	eax, DWORD PTR [edi+52]
	lea	esi, DWORD PTR [edi+44]
	cmp	ecx, eax
	jbe	SHORT $LN4@AddTail
	mov	ecx, DWORD PTR [esi]
	add	eax, eax
	mov	DWORD PTR [esi+8], eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax
	test	eax, eax
	jne	SHORT $LN4@AddTail
	push	OFFSET __TI1?AW4exception@?$DynArray@PAX@@
	lea	edx, DWORD PTR $T160836[esp+12]
	push	edx
	mov	DWORD PTR $T160836[esp+16], eax
	call	__CxxThrowException@8
$LN10@AddTail:
$LN4@AddTail:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _p$[esp+8]

; 49   : 		result = ::ReleaseSemaphore(handles[SemaphoreIndex], 1, NULL);

	push	0
	mov	DWORD PTR [ecx+eax*4-4], edx
	mov	eax, DWORD PTR [edi+4]
	push	1
	push	eax
	call	DWORD PTR __imp__ReleaseSemaphore@12
	mov	edi, eax

; 50   : 		if(!result)

	test	edi, edi
	jne	SHORT $LN1@AddTail

; 51   : 			queue.Delete(0);

	call	?Delete@?$DynArray@PAX@@QAEXI@Z		; DynArray<void *>::Delete
$LN1@AddTail:

; 52   : 		::LeaveCriticalSection(&lock);

	push	ebx
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 53   : 		return result;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 54   : 	}

	ret	4
$LN9@AddTail:
?AddTail@Queue@@QAEHPAX@Z ENDP				; Queue::AddTail
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1Queue@@QAE@XZ
_TEXT	SEGMENT
??1Queue@@QAE@XZ PROC					; Queue::~Queue, COMDAT
; _this$ = esi

; 35   : 		::CloseHandle(handles[SemaphoreIndex]);

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __imp__CloseHandle@4
	push	eax
	call	edi

; 36   : 		::CloseHandle(handles[StopperIndex]);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	edi

; 37   : 		::CloseHandle(handles[CancelIndex]);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	call	edi

; 38   : 		::DeleteCriticalSection(&lock);

	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 39   : 	} // ~Queue

	mov	eax, DWORD PTR [esi+56]
	mov	edi, DWORD PTR __imp__free
	test	eax, eax
	je	SHORT $LN3@Queue@2
	push	eax
	call	edi
	add	esp, 4
	mov	DWORD PTR [esi+56], 0
$LN3@Queue@2:
	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN6@Queue@2
	push	eax
	call	edi
	add	esp, 4
	mov	DWORD PTR [esi+44], 0
$LN6@Queue@2:
	pop	edi
	ret	0
??1Queue@@QAE@XZ ENDP					; Queue::~Queue
_TEXT	ENDS
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\dynarray.h
xdata$x	SEGMENT
__unwindtable$??0Queue@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Queue@@QAE@I@Z$0
__ehfuncinfo$??0Queue@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Queue@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\queue.h
xdata$x	ENDS
;	COMDAT ??0Queue@@QAE@I@Z
_TEXT	SEGMENT
$T160873 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T160865 = 8						; size = 4
_this$ = 8						; size = 4
??0Queue@@QAE@I@Z PROC					; Queue::Queue, COMDAT

; 9    : 	Queue(UINT limit)

	push	-1
	push	__ehhandler$??0Queue@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+28]
	mov	edi, DWORD PTR __imp__malloc
	xor	ebx, ebx
	push	512					; 00000200H
	mov	DWORD PTR [esi+52], 128			; 00000080H
	mov	DWORD PTR [esi+48], ebx
	call	edi
	add	esp, 4
	mov	DWORD PTR [esi+44], eax
	cmp	eax, ebx
	jne	SHORT $LN5@Queue@3
	push	OFFSET __TI1?AW4exception@?$DynArray@PAX@@
	lea	eax, DWORD PTR $T160865[esp+32]
	push	eax
	mov	DWORD PTR $T160865[esp+36], ebx
	call	__CxxThrowException@8
$LN14@Queue@3:
$LN5@Queue@3:
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	push	512					; 00000200H
	mov	DWORD PTR [esi+64], 128			; 00000080H
	mov	DWORD PTR [esi+60], ebx
	call	edi
	add	esp, 4
	mov	DWORD PTR [esi+56], eax
	cmp	eax, ebx
	jne	SHORT $LN9@Queue@3
	push	OFFSET __TI1?AW4exception@?$DynArray@PAX@@
	lea	ecx, DWORD PTR $T160873[esp+36]
	push	ecx
	mov	DWORD PTR $T160873[esp+40], ebx
	call	__CxxThrowException@8
$LN15@Queue@3:
$LN9@Queue@3:

; 10   : 	{
; 11   : 		handles[SemaphoreIndex] = ::CreateSemaphore(NULL,  // no security attributes
; 12   : 			0,     // initial count
; 13   : 			limit, // max count
; 14   : 			NULL); // anonymous

	push	ebx
	push	1024					; 00000400H
	push	ebx
	push	ebx
	call	DWORD PTR __imp__CreateSemaphoreA@16

; 15   : 
; 16   : 		handles[StopperIndex] = ::CreateEvent(NULL,        // no security attributes
; 17   : 			TRUE,        // manual reset
; 18   : 			FALSE,       // initially non-signaled
; 19   : 			NULL);       // anonymous

	mov	edi, DWORD PTR __imp__CreateEventA@16
	push	ebx
	push	ebx
	push	1
	push	ebx
	mov	DWORD PTR [esi+4], eax
	call	edi

; 20   : 
; 21   : 
; 22   : 		handles[CancelIndex] = ::CreateEvent(NULL,        // no security attributes
; 23   : 			TRUE,        // manual reset
; 24   : 			FALSE,       // initially non-signaled
; 25   : 			NULL);       // anonymous

	push	ebx
	push	ebx
	push	1
	push	ebx
	mov	DWORD PTR [esi], eax
	call	edi

; 26   : 
; 27   : 		::InitializeCriticalSection(&lock);

	lea	edx, DWORD PTR [esi+12]
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 28   : 	} // Queue

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
$LN13@Queue@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Queue@@QAE@I@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 44					; 0000002cH
	jmp	??1?$DynArray@PAX@@QAE@XZ		; DynArray<void *>::~DynArray<void *>
__ehhandler$??0Queue@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Queue@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Queue@@QAE@I@Z ENDP					; Queue::Queue
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\pagememory.h
;	COMDAT ?getRenderDPI@PageMemory@@QAENXZ
_TEXT	SEGMENT
?getRenderDPI@PageMemory@@QAENXZ PROC			; PageMemory::getRenderDPI, COMDAT
; _this$ = eax

; 35   : 		return _renderDPI;

	fld	QWORD PTR [eax+16]

; 36   : 	}

	ret	0
?getRenderDPI@PageMemory@@QAENXZ ENDP			; PageMemory::getRenderDPI
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\link.h
_TEXT	ENDS
;	COMDAT ?isOk@LinkDest@@QAEHXZ
_TEXT	SEGMENT
?isOk@LinkDest@@QAEHXZ PROC				; LinkDest::isOk, COMDAT
; _this$ = eax

; 86   :   GBool isOk() { return ok; }

	mov	eax, DWORD PTR [eax+68]
	ret	0
?isOk@LinkDest@@QAEHXZ ENDP				; LinkDest::isOk
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\goo\glist.h
_TEXT	ENDS
;	COMDAT ?get@GList@@QAEPAXH@Z
_TEXT	SEGMENT
?get@GList@@QAEPAXH@Z PROC				; GList::get, COMDAT
; _this$ = eax
; _i$ = edx

; 45   :   void *get(int i) { return data[i]; }

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+edx*4]
	ret	0
?get@GList@@QAEPAXH@Z ENDP				; GList::get
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLength@GList@@QAEHXZ
_TEXT	SEGMENT
?getLength@GList@@QAEHXZ PROC				; GList::getLength, COMDAT
; _this$ = eax

; 39   :   int getLength() { return length; }

	mov	eax, DWORD PTR [eax+8]
	ret	0
?getLength@GList@@QAEHXZ ENDP				; GList::getLength
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\splash\splashbitmap.h
_TEXT	ENDS
;	COMDAT ?getDataPtr@SplashBitmap@@QAEPAEXZ
_TEXT	SEGMENT
?getDataPtr@SplashBitmap@@QAEPAEXZ PROC			; SplashBitmap::getDataPtr, COMDAT
; _this$ = eax

; 40   :   SplashColorPtr getDataPtr() { return data; }

	mov	eax, DWORD PTR [eax+16]
	ret	0
?getDataPtr@SplashBitmap@@QAEPAEXZ ENDP			; SplashBitmap::getDataPtr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getHeight@SplashBitmap@@QAEHXZ
_TEXT	SEGMENT
?getHeight@SplashBitmap@@QAEHXZ PROC			; SplashBitmap::getHeight, COMDAT
; _this$ = eax

; 36   :   int getHeight() { return height; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?getHeight@SplashBitmap@@QAEHXZ ENDP			; SplashBitmap::getHeight
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getWidth@SplashBitmap@@QAEHXZ
_TEXT	SEGMENT
?getWidth@SplashBitmap@@QAEHXZ PROC			; SplashBitmap::getWidth, COMDAT
; _this$ = eax

; 35   :   int getWidth() { return width; }

	mov	eax, DWORD PTR [eax]
	ret	0
?getWidth@SplashBitmap@@QAEHXZ ENDP			; SplashBitmap::getWidth
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\textoutputdev.h
_TEXT	ENDS
;	COMDAT ?isOk@TextOutputDev@@UAEHXZ
_TEXT	SEGMENT
?isOk@TextOutputDev@@UAEHXZ PROC			; TextOutputDev::isOk, COMDAT
; _this$ = ecx

; 568  :   virtual GBool isOk() { return ok; }

	mov	eax, DWORD PTR [ecx+132]
	ret	0
?isOk@TextOutputDev@@UAEHXZ ENDP			; TextOutputDev::isOk
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\outline.h
_TEXT	ENDS
;	COMDAT ?getItems@Outline@@QAEPAVGList@@XZ
_TEXT	SEGMENT
?getItems@Outline@@QAEPAVGList@@XZ PROC			; Outline::getItems, COMDAT
; _this$ = eax

; 34   :   GList *getItems() { return items; }

	mov	eax, DWORD PTR [eax]
	ret	0
?getItems@Outline@@QAEPAVGList@@XZ ENDP			; Outline::getItems
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\splashoutputdev.h
_TEXT	ENDS
;	COMDAT ?getBitmap@SplashOutputDev@@QAEPAVSplashBitmap@@XZ
_TEXT	SEGMENT
?getBitmap@SplashOutputDev@@QAEPAVSplashBitmap@@XZ PROC	; SplashOutputDev::getBitmap, COMDAT
; _this$ = eax

; 169  :   SplashBitmap *getBitmap() { return bitmap; }

	mov	eax, DWORD PTR [eax+180]
	ret	0
?getBitmap@SplashOutputDev@@QAEPAVSplashBitmap@@XZ ENDP	; SplashOutputDev::getBitmap
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\outputdev.h
_TEXT	ENDS
;	COMDAT ?getDefICTM@OutputDev@@QAEPANXZ
_TEXT	SEGMENT
?getDefICTM@OutputDev@@QAEPANXZ PROC			; OutputDev::getDefICTM, COMDAT
; _this$ = eax

; 112  :   double *getDefICTM() { return defICTM; }

	add	eax, 56					; 00000038H
	ret	0
?getDefICTM@OutputDev@@QAEPANXZ ENDP			; OutputDev::getDefICTM
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getDefCTM@OutputDev@@QAEPANXZ
_TEXT	SEGMENT
?getDefCTM@OutputDev@@QAEPANXZ PROC			; OutputDev::getDefCTM, COMDAT
; _this$ = eax

; 111  :   double *getDefCTM() { return defCTM; }

	add	eax, 8
	ret	0
?getDefCTM@OutputDev@@QAEPANXZ ENDP			; OutputDev::getDefCTM
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\pdfdoc.h
_TEXT	ENDS
;	COMDAT ?okToCopy@PDFDoc@@QAEHH@Z
_TEXT	SEGMENT
?okToCopy@PDFDoc@@QAEHH@Z PROC				; PDFDoc::okToCopy, COMDAT
; _this$ = eax

; 140  :     { return xref->okToCopy(ignoreOwnerPW); }

	mov	ecx, DWORD PTR [eax+24]
	push	0
	call	?okToCopy@XRef@@QAEHH@Z			; XRef::okToCopy
	ret	0
?okToCopy@PDFDoc@@QAEHH@Z ENDP				; PDFDoc::okToCopy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?okToPrint@PDFDoc@@QAEHH@Z
_TEXT	SEGMENT
?okToPrint@PDFDoc@@QAEHH@Z PROC				; PDFDoc::okToPrint, COMDAT
; _this$ = eax

; 136  :     { return xref->okToPrint(ignoreOwnerPW); }

	mov	ecx, DWORD PTR [eax+24]
	push	0
	call	?okToPrint@XRef@@QAEHH@Z		; XRef::okToPrint
	ret	0
?okToPrint@PDFDoc@@QAEHH@Z ENDP				; PDFDoc::okToPrint
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getOutline@PDFDoc@@QAEPAVOutline@@XZ
_TEXT	SEGMENT
?getOutline@PDFDoc@@QAEPAVOutline@@XZ PROC		; PDFDoc::getOutline, COMDAT
; _this$ = eax

; 128  :   Outline *getOutline() { return outline; }

	mov	eax, DWORD PTR [eax+32]
	ret	0
?getOutline@PDFDoc@@QAEPAVOutline@@XZ ENDP		; PDFDoc::getOutline
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getXRef@PDFDoc@@QAEPAVXRef@@XZ
_TEXT	SEGMENT
?getXRef@PDFDoc@@QAEPAVXRef@@XZ PROC			; PDFDoc::getXRef, COMDAT
; _this$ = eax

; 58   :   XRef *getXRef() { return xref; }

	mov	eax, DWORD PTR [eax+24]
	ret	0
?getXRef@PDFDoc@@QAEPAVXRef@@XZ ENDP			; PDFDoc::getXRef
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getErrorCode@PDFDoc@@QAEHXZ
_TEXT	SEGMENT
?getErrorCode@PDFDoc@@QAEHXZ PROC			; PDFDoc::getErrorCode, COMDAT
; _this$ = eax

; 52   :   int getErrorCode() { return errCode; }

	mov	eax, DWORD PTR [eax+40]
	ret	0
?getErrorCode@PDFDoc@@QAEHXZ ENDP			; PDFDoc::getErrorCode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isOk@PDFDoc@@QAEHXZ
_TEXT	SEGMENT
?isOk@PDFDoc@@QAEHXZ PROC				; PDFDoc::isOk, COMDAT
; _this$ = eax

; 49   :   GBool isOk() { return ok; }

	mov	eax, DWORD PTR [eax+36]
	ret	0
?isOk@PDFDoc@@QAEHXZ ENDP				; PDFDoc::isOk
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\page.h
_TEXT	ENDS
;	COMDAT ?isOk@Page@@QAEHXZ
_TEXT	SEGMENT
?isOk@Page@@QAEHXZ PROC					; Page::isOk, COMDAT
; _this$ = eax

; 113  :   GBool isOk() { return ok; }

	mov	eax, DWORD PTR [eax+64]
	ret	0
?isOk@Page@@QAEHXZ ENDP					; Page::isOk
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\catalog.h
_TEXT	ENDS
;	COMDAT ?getNumPages@Catalog@@QAEHXZ
_TEXT	SEGMENT
?getNumPages@Catalog@@QAEHXZ PROC			; Catalog::getNumPages, COMDAT
; _this$ = eax

; 42   :   int getNumPages() { return numPages; }

	mov	eax, DWORD PTR [eax+12]
	ret	0
?getNumPages@Catalog@@QAEHXZ ENDP			; Catalog::getNumPages
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isOk@Catalog@@QAEHXZ
_TEXT	SEGMENT
?isOk@Catalog@@QAEHXZ PROC				; Catalog::isOk, COMDAT
; _this$ = eax

; 39   :   GBool isOk() { return ok; }

	mov	eax, DWORD PTR [eax+176]
	ret	0
?isOk@Catalog@@QAEHXZ ENDP				; Catalog::isOk
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\object.h
_TEXT	ENDS
;	COMDAT ?getDict@Object@@QAEPAVDict@@XZ
_TEXT	SEGMENT
?getDict@Object@@QAEPAVDict@@XZ PROC			; Object::getDict, COMDAT
; _this$ = eax

; 160  :   Dict *getDict() { return dict; }

	mov	eax, DWORD PTR [eax+16]
	ret	0
?getDict@Object@@QAEPAVDict@@XZ ENDP			; Object::getDict
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getString@Object@@QAEPAVGString@@XZ
_TEXT	SEGMENT
?getString@Object@@QAEPAVGString@@XZ PROC		; Object::getString, COMDAT
; _this$ = eax

; 157  :   GString *getString() { return string; }

	mov	eax, DWORD PTR [eax+16]
	ret	0
?getString@Object@@QAEPAVGString@@XZ ENDP		; Object::getString
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isDict@Object@@QAEHXZ
_TEXT	SEGMENT
?isDict@Object@@QAEHXZ PROC				; Object::isDict, COMDAT
; _this$ = ecx

; 136  :   GBool isDict() { return type == objDict; }

	xor	eax, eax
	cmp	DWORD PTR [ecx+8], 7
	sete	al
	ret	0
?isDict@Object@@QAEHXZ ENDP				; Object::isDict
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isString@Object@@QAEHXZ
_TEXT	SEGMENT
?isString@Object@@QAEHXZ PROC				; Object::isString, COMDAT
; _this$ = ecx

; 132  :   GBool isString() { return type == objString; }

	xor	eax, eax
	cmp	DWORD PTR [ecx+8], 3
	sete	al
	ret	0
?isString@Object@@QAEHXZ ENDP				; Object::isString
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?initNull@Object@@QAEPAV1@XZ
_TEXT	SEGMENT
?initNull@Object@@QAEPAV1@XZ PROC			; Object::initNull, COMDAT
; _this$ = eax

; 102  :     { initObj(objNull); return this; }

	mov	DWORD PTR [eax+8], 5
	ret	0
?initNull@Object@@QAEPAV1@XZ ENDP			; Object::initNull
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0Object@@QAE@XZ
_TEXT	SEGMENT
??0Object@@QAE@XZ PROC					; Object::Object, COMDAT
; _this$ = ecx

; 87   :     {

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 13			; 0000000dH

; 88   : 	}

	ret	0
??0Object@@QAE@XZ ENDP					; Object::Object
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\tchar.h
_TEXT	ENDS
;	COMDAT __tcsrchr
_TEXT	SEGMENT
__tcsrchr PROC						; COMDAT
; __s1$ = eax

; 1546 : _Check_return_ __inline _CRPC _tcsrchr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbsrchr((_CPUC)_s1,_c);}

	push	92					; 0000005cH
	push	eax
	call	DWORD PTR __imp___mbsrchr
	add	esp, 8
	ret	0
__tcsrchr ENDP
PUBLIC	?GetOutlinePtr@AFPDFDoc@@QAEJJ@Z		; AFPDFDoc::GetOutlinePtr
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
;	COMDAT ?GetOutlinePtr@AFPDFDoc@@QAEJJ@Z
_TEXT	SEGMENT
?GetOutlinePtr@AFPDFDoc@@QAEJJ@Z PROC			; AFPDFDoc::GetOutlinePtr, COMDAT
; _this$ = eax
; _iOutline$ = ecx

; 1947 : 		
; 1948 : 		if(m_Outline){

	mov	eax, DWORD PTR [eax+348]
	test	eax, eax
	je	SHORT $LN1@GetOutline

; 1949 : 			if(m_Outline->getItems()){

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN1@GetOutline

; 1950 : 				if (iOutline > 0 && iOutline <= m_Outline->getItems()->getLength()){

	test	ecx, ecx
	jle	SHORT $LN1@GetOutline
	cmp	ecx, DWORD PTR [eax+8]
	jg	SHORT $LN1@GetOutline

; 1951 : 					OutlineItem *ol;
; 1952 : 					ol =(OutlineItem *) m_Outline->getItems()->get(iOutline-1);
; 1953 : 					return (long)ol;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+ecx*4-4]

; 1959 : 	}

	ret	0
$LN1@GetOutline:

; 1954 : 				}
; 1955 : 			}
; 1956 : 		}
; 1957 : 
; 1958 : 		return 0;

	xor	eax, eax

; 1959 : 	}

	ret	0
?GetOutlinePtr@AFPDFDoc@@QAEJJ@Z ENDP			; AFPDFDoc::GetOutlinePtr
_TEXT	ENDS
PUBLIC	?GetOutlineCount@AFPDFDoc@@QAEJXZ		; AFPDFDoc::GetOutlineCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetOutlineCount@AFPDFDoc@@QAEJXZ
_TEXT	SEGMENT
?GetOutlineCount@AFPDFDoc@@QAEJXZ PROC			; AFPDFDoc::GetOutlineCount, COMDAT
; _this$ = eax

; 1934 : 		
; 1935 : 		if(m_Outline){

	mov	eax, DWORD PTR [eax+348]
	test	eax, eax
	je	SHORT $LN1@GetOutline@2

; 1936 : 			if (m_Outline->getItems())

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN1@GetOutline@2

; 1937 : 				return m_Outline->getItems()->getLength();

	mov	eax, DWORD PTR [eax+8]

; 1942 : 	}

	ret	0
$LN1@GetOutline@2:

; 1938 : 			else
; 1939 : 				return 0;
; 1940 : 		}
; 1941 : 		return 0;

	xor	eax, eax

; 1942 : 	}

	ret	0
?GetOutlineCount@AFPDFDoc@@QAEJXZ ENDP			; AFPDFDoc::GetOutlineCount
_TEXT	ENDS
PUBLIC	__real@4052000000000000
PUBLIC	?RenderHDC@AFPDFDoc@@QAEJJ@Z			; AFPDFDoc::RenderHDC
;	COMDAT __real@4052000000000000
; File c:\projects\pdflibnet\libafpdflib\crect.h
CONST	SEGMENT
__real@4052000000000000 DQ 04052000000000000r	; 72
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
CONST	ENDS
;	COMDAT ?RenderHDC@AFPDFDoc@@QAEJJ@Z
_TEXT	SEGMENT
$T168593 = -104						; size = 4
$T168587 = -104						; size = 4
_j$86254 = -100						; size = 4
tv751 = -96						; size = 4
tv661 = -92						; size = 4
tv669 = -88						; size = 4
$T168589 = -88						; size = 4
_old_pen$86246 = -84					; size = 4
_old_brush$86247 = -80					; size = 4
_r$86264 = -76						; size = 24
_nsel$86261 = -52					; size = 24
$T168554 = -28						; size = 28
_this$ = 8						; size = 4
_lHdc$ = 12						; size = 4
?RenderHDC@AFPDFDoc@@QAEJJ@Z PROC			; AFPDFDoc::RenderHDC, COMDAT

; 1607 : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 1608 : 		HDC dc=(HDC)lHdc;
; 1609 : 		if (m_Bitmap != NULL) 

	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+352]
	test	esi, esi
	je	$LN44@RenderHDC

; 1610 : 		{
; 1611 : 			
; 1612 : 
; 1613 : 			// Draw the rendered document
; 1614 : 			m_Bitmap->Draw(
; 1615 : 				(HDC)lHdc,
; 1616 : 				m_ViewOffsetX,		//SrcX
; 1617 : 				m_ViewOffsetY,		//SrcY
; 1618 : 				m_ViewWidth,		//Width
; 1619 : 				m_ViewHeight,		//Height
; 1620 : 				m_ViewX,			//DestX
; 1621 : 				m_ViewY);			//DestY

	mov	eax, DWORD PTR [edi+492]
	mov	ecx, DWORD PTR [edi+488]
	mov	edx, DWORD PTR [edi+484]
	mov	ebx, DWORD PTR _lHdc$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+480]
	push	ecx
	mov	ecx, DWORD PTR [edi+500]
	push	edx
	mov	edx, DWORD PTR [edi+496]
	push	eax
	push	ecx
	push	edx
	call	?Draw@PageMemory@@QAEHPAUHDC__@@HHHHHH@Z ; PageMemory::Draw

; 1622 : 	
; 1623 : 			/*
; 1624 : 			Links *l =m_PDFDoc->getLinks(m_CurrentPage);
; 1625 : 
; 1626 : 			if(l->getNumLinks()>0){
; 1627 : 				HGDIOBJ draw_pen, old_pen;
; 1628 : 				HGDIOBJ old_brush;
; 1629 : 
; 1630 : 				draw_pen = CreatePen(PS_SOLID, 0, RGB(127, 127, 255));
; 1631 : 				old_pen = SelectObject(dc,draw_pen);
; 1632 : 				old_brush = SelectObject(dc,GetStockObject(NULL_BRUSH));
; 1633 : 
; 1634 : 				double x1,y1,x2,y2;
; 1635 : 				int left,top,right,bottom;
; 1636 : 				for(int j=0; j < l->getNumLinks(); j++){
; 1637 : 					Link *link = l->getLink(j);
; 1638 : 					link->getRect(&x1,&y1,&x2,&y2);
; 1639 : 					this->cvtUserToDev(x1,y1,&left,&top);
; 1640 : 					this->cvtUserToDev(x2,y2,&right,&bottom);
; 1641 : 					CRect r(left,top,right,bottom);
; 1642 : 					r.OffsetRect(-m_ViewOffsetX, -m_ViewOffsetY);
; 1643 : 					r.OffsetRect(m_ViewX, m_ViewY);
; 1644 : 					Rectangle(dc,r.left,r.top,r.right,r.bottom);
; 1645 : 				}
; 1646 : 				SelectObject(dc,old_pen);
; 1647 : 				SelectObject(dc,old_brush);
; 1648 : 				DeleteObject(draw_pen);
; 1649 : 			}
; 1650 : 			delete l;*/
; 1651 : 
; 1652 : 			// draw selection 
; 1653 : 			if (!m_HideMarks && m_CurrentPage == m_SearchPage) {

	cmp	BYTE PTR [edi+544], 0
	jne	$LN44@RenderHDC
	mov	eax, DWORD PTR [edi+504]
	cmp	eax, DWORD PTR [edi+512]
	jne	$LN44@RenderHDC

; 1654 : 				//dc.Attach((HDC)lHdc);
; 1655 : 
; 1656 : 				const double mul = m_renderDPI / FIND_DPI;
; 1657 : 
; 1658 : 				HGDIOBJ draw_pen, old_pen;
; 1659 : 				HGDIOBJ old_brush;
; 1660 : 				
; 1661 : 				draw_pen = CreatePen(PS_SOLID, 0, RGB(127, 127, 255));

	push	16744319				; 00ff7f7fH
	xor	ebx, ebx
	push	ebx
	push	ebx
	call	DWORD PTR __imp__CreatePen@12

; 1662 : 				old_pen = SelectObject(dc,draw_pen);

	mov	ecx, DWORD PTR _lHdc$[ebp]
	mov	esi, DWORD PTR __imp__SelectObject@8
	push	eax
	push	ecx
	call	esi

; 1663 : //				old_brush = SelectStockObject(dc,NULL_BRUSH);
; 1664 : 				old_brush = SelectObject(dc,GetStockObject(NULL_BRUSH));

	push	5
	mov	DWORD PTR _old_pen$86246[esp+124], eax
	call	DWORD PTR __imp__GetStockObject@4
	mov	edx, DWORD PTR _lHdc$[ebp]
	push	eax
	push	edx
	call	esi
	mov	DWORD PTR _old_brush$86247[esp+120], eax

; 1665 : 				
; 1666 : 				for(unsigned int j = 0; j < m_Selection.GetCount(); j++) {

	mov	DWORD PTR _j$86254[esp+120], ebx
	cmp	DWORD PTR [edi+324], ebx
	jbe	$LN8@RenderHDC
	fld	QWORD PTR __real@4052000000000000
	xor	eax, eax
	mov	DWORD PTR tv751[esp+120], eax
	jmp	SHORT $LN10@RenderHDC
$LN45@RenderHDC:

; 1654 : 				//dc.Attach((HDC)lHdc);
; 1655 : 
; 1656 : 				const double mul = m_renderDPI / FIND_DPI;
; 1657 : 
; 1658 : 				HGDIOBJ draw_pen, old_pen;
; 1659 : 				HGDIOBJ old_brush;
; 1660 : 				
; 1661 : 				draw_pen = CreatePen(PS_SOLID, 0, RGB(127, 127, 255));

	mov	edi, esi
$LN10@RenderHDC:

; 1667 : 					 // transform selection into current DPI and
; 1668 : 					 // offset it by current upper/left corner.
; 1669 : 					 // Provided m_renderDPI was integer we could
; 1670 : 					 // use CRect::MulDiv.
; 1671 : 					if (((CPDFSearchResult)m_Selection[j]).PageFound == m_CurrentPage){

	mov	ecx, DWORD PTR [edi+320]
	add	eax, ecx
	mov	ecx, 7
	mov	esi, eax
	lea	edi, DWORD PTR $T168554[esp+120]
	rep movsd
	mov	edx, DWORD PTR $T168554[esp+144]
	mov	esi, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [esi+504]
	jne	$LN9@RenderHDC

; 1672 : 						CRect nsel =(CRect)m_Selection[j];

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nsel$86261[esp+120], ecx

; 1673 : 						CRect r;
; 1674 : 
; 1675 : 						nsel.left   = int(nsel.left   * m_renderDPI / FIND_DPI);

	fild	DWORD PTR _nsel$86261[esp+120]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	fmul	QWORD PTR [esi+536]
	mov	DWORD PTR _nsel$86261[esp+124], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _nsel$86261[esp+128], ecx
	mov	ecx, DWORD PTR [eax+16]
	fdiv	ST(0), ST(1)
	mov	DWORD PTR _nsel$86261[esp+132], edx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _nsel$86261[esp+136], ecx
	mov	DWORD PTR _nsel$86261[esp+140], edx
	mov	DWORD PTR _r$86264[esp+140], ebx
	mov	DWORD PTR _r$86264[esp+136], ebx
	mov	DWORD PTR _r$86264[esp+132], ebx
	mov	DWORD PTR _r$86264[esp+124], ebx
	mov	DWORD PTR _r$86264[esp+128], ebx
	mov	DWORD PTR _r$86264[esp+120], ebx
	call	__ftol2_sse

; 1676 : 						nsel.top    = int(nsel.top    * m_renderDPI / FIND_DPI);

	fild	DWORD PTR _nsel$86261[esp+124]
	mov	DWORD PTR _nsel$86261[esp+120], eax
	fmul	QWORD PTR [esi+536]
	fdiv	ST(0), ST(1)
	call	__ftol2_sse

; 1677 : 						nsel.right  = int(nsel.right  * m_renderDPI / FIND_DPI);

	fild	DWORD PTR _nsel$86261[esp+128]
	mov	ebx, eax
	fmul	QWORD PTR [esi+536]
	fdiv	ST(0), ST(1)
	call	__ftol2_sse

; 1678 : 						nsel.bottom = int(nsel.bottom * m_renderDPI / FIND_DPI);

	fild	DWORD PTR _nsel$86261[esp+132]
	mov	edi, eax
	fmul	QWORD PTR [esi+536]
	fdivrp	ST(1), ST(0)
	call	__ftol2_sse

; 1679 : 
; 1680 : 						// enlarge right/bottom 
; 1681 : 						nsel.right++;
; 1682 : 						nsel.bottom++;
; 1683 : 
; 1684 : 						// rotate using predefined angles only 
; 1685 : 						switch(m_Rotation) {

	mov	ecx, DWORD PTR [esi+524]
	inc	edi
	inc	eax
	cmp	ecx, 180				; 000000b4H
	jg	$LN15@RenderHDC
	je	SHORT $LN2@RenderHDC
	test	ecx, ecx
	je	SHORT $LN4@RenderHDC
	cmp	ecx, 90					; 0000005aH
	jne	$LN5@RenderHDC

; 1689 : 
; 1690 : 						case 90:
; 1691 : 							r = CRect(
; 1692 : 								m_PageWidth - nsel.bottom,
; 1693 : 								nsel.left,
; 1694 : 								m_PageWidth - nsel.top,
; 1695 : 								nsel.right);

	mov	ecx, DWORD PTR [esi+520]
	mov	edx, ecx
	sub	edx, ebx
	sub	ecx, eax
	mov	eax, edx
	sub	eax, ecx
	mov	ebx, edi
	sub	ebx, DWORD PTR _nsel$86261[esp+120]
	mov	DWORD PTR _r$86264[esp+120], ecx
	mov	ecx, DWORD PTR _nsel$86261[esp+120]
	mov	DWORD PTR _r$86264[esp+124], ecx
	mov	DWORD PTR _r$86264[esp+128], edx
	mov	DWORD PTR _r$86264[esp+132], edi
	mov	DWORD PTR _r$86264[esp+136], eax
	mov	DWORD PTR _r$86264[esp+140], ebx

; 1696 : 							break;

	jmp	$LN5@RenderHDC
$LN4@RenderHDC:

; 1686 : 						case 0:
; 1687 : 							r = nsel;

	mov	edx, DWORD PTR _nsel$86261[esp+120]
	mov	ecx, DWORD PTR _nsel$86261[esp+140]
	mov	DWORD PTR _r$86264[esp+132], eax
	mov	eax, DWORD PTR _nsel$86261[esp+136]
	mov	DWORD PTR _r$86264[esp+120], edx
	mov	DWORD PTR _r$86264[esp+128], edi
	mov	DWORD PTR _r$86264[esp+136], eax
	mov	DWORD PTR _r$86264[esp+140], ecx

; 1688 : 							break;

	jmp	$LN55@RenderHDC
$LN2@RenderHDC:

; 1697 : 
; 1698 : 						case 180:
; 1699 : 							r = CRect(
; 1700 : 								m_PageWidth - nsel.right,
; 1701 : 								m_PageHeight - nsel.bottom,
; 1702 : 								m_PageWidth - nsel.left,
; 1703 : 								m_PageHeight - nsel.top);

	mov	ecx, DWORD PTR [esi+516]
	mov	edx, ecx
	sub	edx, ebx
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+520]
	mov	DWORD PTR $T168589[esp+120], edx
	mov	edx, DWORD PTR [esi+520]
	sub	edx, DWORD PTR _nsel$86261[esp+120]
	sub	eax, edi
	mov	edi, DWORD PTR $T168589[esp+120]
	mov	DWORD PTR $T168587[esp+120], ecx
	mov	ebx, edx
	sub	ebx, eax
	mov	ecx, edi
	sub	ecx, DWORD PTR $T168587[esp+120]
	mov	DWORD PTR _r$86264[esp+120], eax
	mov	eax, DWORD PTR $T168587[esp+120]
	mov	DWORD PTR _r$86264[esp+124], eax
	mov	DWORD PTR _r$86264[esp+128], edx
	mov	DWORD PTR _r$86264[esp+132], edi
	mov	DWORD PTR _r$86264[esp+136], ebx
	mov	DWORD PTR _r$86264[esp+140], ecx

; 1704 : 							break;

	jmp	SHORT $LN5@RenderHDC
$LN15@RenderHDC:

; 1679 : 
; 1680 : 						// enlarge right/bottom 
; 1681 : 						nsel.right++;
; 1682 : 						nsel.bottom++;
; 1683 : 
; 1684 : 						// rotate using predefined angles only 
; 1685 : 						switch(m_Rotation) {

	cmp	ecx, 270				; 0000010eH
	jne	SHORT $LN5@RenderHDC

; 1705 : 
; 1706 : 						case 270:
; 1707 : 							r = CRect(
; 1708 : 								nsel.top,
; 1709 : 								m_PageHeight - nsel.right,
; 1710 : 								nsel.bottom,
; 1711 : 								m_PageHeight - nsel.left);

	mov	edx, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR [esi+516]
	sub	ecx, DWORD PTR _nsel$86261[esp+120]
	sub	edx, edi
	mov	DWORD PTR $T168593[esp+120], edx
	mov	edx, eax
	sub	edx, ebx
	mov	edi, ecx
	sub	edi, DWORD PTR $T168593[esp+120]
	mov	DWORD PTR _r$86264[esp+120], ebx
	mov	ebx, DWORD PTR $T168593[esp+120]
	mov	DWORD PTR _r$86264[esp+128], eax
	mov	DWORD PTR _r$86264[esp+132], ecx
	mov	DWORD PTR _r$86264[esp+136], edx
	mov	DWORD PTR _r$86264[esp+140], edi
$LN55@RenderHDC:
	mov	DWORD PTR _r$86264[esp+124], ebx
$LN5@RenderHDC:

; 1712 : 							break;
; 1713 : 						}
; 1714 : 						
; 1715 : 						r.OffsetRect(-m_ViewOffsetX, -m_ViewOffsetY);

	mov	ecx, DWORD PTR [esi+500]
	mov	edx, DWORD PTR [esi+496]
	mov	edi, DWORD PTR __imp__OffsetRect@12
	neg	ecx
	push	ecx
	neg	edx
	push	edx
	lea	eax, DWORD PTR _r$86264[esp+128]
	push	eax
	call	edi

; 1716 : 						r.OffsetRect(m_ViewX, m_ViewY);

	mov	ecx, DWORD PTR [esi+492]
	mov	edx, DWORD PTR [esi+488]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _r$86264[esp+128]
	push	eax
	call	edi

; 1717 : 						r.InflateRect(1,0);

	mov	edi, DWORD PTR __imp__InflateRect@12
	push	0
	push	1
	lea	ecx, DWORD PTR _r$86264[esp+128]
	push	ecx
	call	edi

; 1718 : 						::Rectangle(dc,r.left,r.top,r.right,r.bottom);

	mov	edx, DWORD PTR _r$86264[esp+132]
	mov	eax, DWORD PTR _r$86264[esp+128]
	mov	ecx, DWORD PTR _r$86264[esp+124]
	mov	ebx, DWORD PTR _lHdc$[ebp]
	push	edx
	mov	edx, DWORD PTR _r$86264[esp+124]
	push	eax
	push	ecx
	push	edx
	push	ebx
	call	DWORD PTR __imp__Rectangle@20

; 1719 : 						//Rectangle(r);
; 1720 : 						r.DeflateRect(1,1);

	push	-1
	push	-1
	lea	eax, DWORD PTR _r$86264[esp+128]
	push	eax
	call	edi

; 1721 : 						::InvertRect(dc,&r);

	lea	ecx, DWORD PTR _r$86264[esp+120]
	push	ecx
	push	ebx
	call	DWORD PTR __imp__InvertRect@8
	fld	QWORD PTR __real@4052000000000000
	xor	ebx, ebx
$LN9@RenderHDC:
	mov	ecx, DWORD PTR _j$86254[esp+120]
	mov	eax, DWORD PTR tv751[esp+120]
	inc	ecx
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _j$86254[esp+120], ecx
	mov	DWORD PTR tv751[esp+120], eax
	cmp	ecx, DWORD PTR [esi+324]
	jb	$LN45@RenderHDC
	mov	esi, DWORD PTR __imp__SelectObject@8
	fstp	ST(0)
$LN8@RenderHDC:

; 1722 : 						//dc.InvertRect(r);
; 1723 : 					}
; 1724 : 				}
; 1725 : 
; 1726 : 				SelectObject(dc,old_pen);

	mov	edx, DWORD PTR _old_pen$86246[esp+120]
	mov	edi, DWORD PTR _lHdc$[ebp]
	push	edx
	push	edi
	call	esi

; 1727 : 				SelectObject(dc,old_brush);

	mov	eax, DWORD PTR _old_brush$86247[esp+120]
	push	eax
	push	edi
	call	esi
$LN44@RenderHDC:

; 1728 : 				//dc.Detach();
; 1729 : 			}	
; 1730 : 		}
; 1731 : 		return 0;
; 1732 : 	}

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?RenderHDC@AFPDFDoc@@QAEJJ@Z ENDP			; AFPDFDoc::RenderHDC
_TEXT	ENDS
PUBLIC	?CancelThumbRender@AFPDFDoc@@QAE_NXZ		; AFPDFDoc::CancelThumbRender
; Function compile flags: /Ogtpy
;	COMDAT ?CancelThumbRender@AFPDFDoc@@QAE_NXZ
_TEXT	SEGMENT
?CancelThumbRender@AFPDFDoc@@QAE_NXZ PROC		; AFPDFDoc::CancelThumbRender, COMDAT
; _this$ = eax

; 1255 : 	{

	push	esi

; 1256 : 		return m_QueuedThumbs.clearall( CancelThumbRenderCallback );

	mov	esi, eax
	add	esi, 252				; 000000fcH
	call	?clearall@Queue@@QAE_NP6AXPAX@Z@Z	; Queue::clearall
	pop	esi

; 1257 : 	}

	ret	0
?CancelThumbRender@AFPDFDoc@@QAE_NXZ ENDP		; AFPDFDoc::CancelThumbRender
_TEXT	ENDS
PUBLIC	?ThumbInQueue@AFPDFDoc@@QAE_NH@Z		; AFPDFDoc::ThumbInQueue
; Function compile flags: /Ogtpy
;	COMDAT ?ThumbInQueue@AFPDFDoc@@QAE_NH@Z
_TEXT	SEGMENT
?ThumbInQueue@AFPDFDoc@@QAE_NH@Z PROC			; AFPDFDoc::ThumbInQueue, COMDAT
; _this$ = eax
; _page$ = ebx

; 1230 : 	{

	push	ebp
	push	esi
	push	edi
	mov	esi, eax

; 1231 : 		m_QueuedThumbs.enterlock();

	lea	edi, DWORD PTR [esi+264]
	push	edi
	call	DWORD PTR __imp__EnterCriticalSection@4
	mov	ecx, DWORD PTR [esi+300]

; 1232 : 		//Look waiting
; 1233 : 		for(unsigned int i=0;i<m_QueuedThumbs.queue.GetCount();++i)

	xor	eax, eax
	test	ecx, ecx
	jbe	SHORT $LN37@ThumbInQue

; 1231 : 		m_QueuedThumbs.enterlock();

	mov	edx, DWORD PTR [esi+296]
$LL8@ThumbInQue:

; 1234 : 		{
; 1235 : 			if(((threadParamThumb *)m_QueuedThumbs.queue[i])->pageToRender == page)

	mov	ebp, DWORD PTR [edx]
	cmp	DWORD PTR [ebp+44], ebx
	je	SHORT $LN33@ThumbInQue
	inc	eax
	add	edx, 4
	cmp	eax, ecx
	jb	SHORT $LL8@ThumbInQue
$LN37@ThumbInQue:
	mov	ecx, DWORD PTR [esi+312]

; 1239 : 			}
; 1240 : 		}
; 1241 : 		//Look in process
; 1242 : 		for(unsigned int i=0;i<m_QueuedThumbs.delQueue.GetCount();++i)

	xor	eax, eax
	test	ecx, ecx
	jbe	SHORT $LN2@ThumbInQue
	mov	esi, DWORD PTR [esi+308]
$LL4@ThumbInQue:

; 1243 : 		{
; 1244 : 			if(((threadParamThumb *)m_QueuedThumbs.delQueue[i])->pageToRender == page)

	mov	edx, DWORD PTR [esi]
	cmp	DWORD PTR [edx+44], ebx
	je	SHORT $LN33@ThumbInQue
	inc	eax
	add	esi, 4
	cmp	eax, ecx
	jb	SHORT $LL4@ThumbInQue
$LN2@ThumbInQue:

; 1245 : 			{
; 1246 : 				m_QueuedThumbs.unlock();
; 1247 : 				return true;
; 1248 : 			}
; 1249 : 		}
; 1250 : 		m_QueuedThumbs.unlock();

	push	edi
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	edi
	pop	esi

; 1251 : 		return false;

	xor	al, al
	pop	ebp

; 1252 : 	}

	ret	0
$LN33@ThumbInQue:

; 1236 : 			{
; 1237 : 				m_QueuedThumbs.unlock();

	push	edi
	call	DWORD PTR __imp__LeaveCriticalSection@4
	pop	edi
	pop	esi

; 1238 : 				return true;

	mov	al, 1
	pop	ebp

; 1252 : 	}

	ret	0
?ThumbInQueue@AFPDFDoc@@QAE_NH@Z ENDP			; AFPDFDoc::ThumbInQueue
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GAuxOutputDev@@QAEPAXI@Z
_TEXT	SEGMENT
??_GAuxOutputDev@@QAEPAXI@Z PROC			; AuxOutputDev::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [esi], OFFSET ??_7AuxOutputDev@@6B@
	test	eax, eax
	je	SHORT $LN5@scalar@8
	push	eax
	call	_fz_droppixmap
	add	esp, 4
	mov	DWORD PTR [esi+44], 0
$LN5@scalar@8:
	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN4@scalar@8
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
	mov	DWORD PTR [esi+12], 0
$LN4@scalar@8:
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	ret	0
??_GAuxOutputDev@@QAEPAXI@Z ENDP			; AuxOutputDev::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?AddBitmapCache@AFPDFDoc@@AAEXPAVPageMemory@@H@Z ; AFPDFDoc::AddBitmapCache
; Function compile flags: /Ogtpy
;	COMDAT ?AddBitmapCache@AFPDFDoc@@AAEXPAVPageMemory@@H@Z
_TEXT	SEGMENT
_bmp$ = 8						; size = 4
_page$ = 12						; size = 4
?AddBitmapCache@AFPDFDoc@@AAEXPAVPageMemory@@H@Z PROC	; AFPDFDoc::AddBitmapCache, COMDAT
; _this$ = esi

; 467  : 	void		AFPDFDoc::AddBitmapCache(PageMemory *bmp, int page){

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _page$[esp+4]

; 468  : 		//if exists and is not equal, delete
; 469  : 		for(int i=0;i<MAX_BITMAP_CACHE;i++){

	lea	ecx, DWORD PTR [esi+80]
	push	edi
	xor	edx, edx
	xor	edi, edi
	mov	eax, ecx
$LL12@AddBitmapC:

; 470  : 			if(_pageCached[i]==page){

	cmp	DWORD PTR [eax], ebp
	je	$LN43@AddBitmapC
	inc	edi
	add	eax, 4
	cmp	edi, 16					; 00000010H
	jl	SHORT $LL12@AddBitmapC

; 475  : 					return;
; 476  : 				}else{
; 477  : 					return;
; 478  : 				}
; 479  : 			}
; 480  : 		}
; 481  : 		//Add in an empty bin
; 482  : 		for(int i=0;i<MAX_BITMAP_CACHE;i++){

	xor	eax, eax
$LL6@AddBitmapC:

; 483  : 			if(_pageCached[i]==0){

	cmp	DWORD PTR [ecx], edx
	je	$LN44@AddBitmapC
	inc	eax
	add	ecx, 4
	cmp	eax, 16					; 00000010H
	jl	SHORT $LL6@AddBitmapC

; 486  : 				return;
; 487  : 			}
; 488  : 		}
; 489  : 		//Begin to replace old cache
; 490  : 		if((++_countCached)>=MAX_BITMAP_CACHE)

	inc	DWORD PTR [esi+148]
	cmp	DWORD PTR [esi+148], 16			; 00000010H
	jl	SHORT $LN2@AddBitmapC

; 491  : 			_countCached=0;

	mov	DWORD PTR [esi+148], edx
$LN2@AddBitmapC:

; 492  : 
; 493  : 		//If new bin is busy, delete
; 494  : 		if(_bitmapCache[_countCached]!=0){

	mov	eax, DWORD PTR [esi+148]
	cmp	DWORD PTR [esi+eax*4+12], edx
	lea	eax, DWORD PTR [esi+eax*4+12]
	je	SHORT $LN1@AddBitmapC

; 495  : 			_bitmapCache[_countCached]->Dispose();

	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR __imp__DeleteObject@4
	cmp	eax, edx
	je	SHORT $LN30@AddBitmapC
	push	eax
	call	ebx
	xor	edx, edx
$LN30@AddBitmapC:
	mov	DWORD PTR [edi+4], edx
	mov	DWORD PTR [edi], edx

; 496  : 			delete _bitmapCache[_countCached];

	mov	ecx, DWORD PTR [esi+148]
	mov	edi, DWORD PTR [esi+ecx*4+12]
	cmp	edi, edx
	je	SHORT $LN17@AddBitmapC
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, edx
	je	SHORT $LN38@AddBitmapC
	push	eax
	call	ebx
	xor	edx, edx
$LN38@AddBitmapC:
	push	edi
	mov	DWORD PTR [edi+4], edx
	mov	DWORD PTR [edi], edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	edx, edx
$LN17@AddBitmapC:

; 497  : 			_bitmapCache[_countCached]=0;

	mov	eax, DWORD PTR [esi+148]
	mov	DWORD PTR [esi+eax*4+12], edx

; 498  : 			_pageCached[_countCached]=0;

	mov	ecx, DWORD PTR [esi+148]
	mov	DWORD PTR [esi+ecx*4+80], edx
$LN1@AddBitmapC:

; 499  : 		}
; 500  : 		//Save in cache
; 501  : 		_bitmapCache[_countCached]=bmp;

	mov	edx, DWORD PTR [esi+148]
	mov	eax, DWORD PTR _bmp$[esp+8]
	mov	DWORD PTR [esi+edx*4+12], eax

; 502  : 		_pageCached[_countCached]=page;

	mov	ecx, DWORD PTR [esi+148]
	mov	DWORD PTR [esi+ecx*4+80], ebp
$LN13@AddBitmapC:
	pop	edi
	pop	ebp
	pop	ebx

; 503  : 	}

	ret	8
$LN43@AddBitmapC:

; 471  : 				if( _bitmapCache[i]!=0 && _bitmapCache[i]!=bmp){

	mov	ebx, DWORD PTR [esi+edi*4+12]
	cmp	ebx, edx
	je	SHORT $LN13@AddBitmapC
	cmp	ebx, DWORD PTR _bmp$[esp+8]
	je	SHORT $LN13@AddBitmapC

; 472  : 					_bitmapCache[i]->Dispose();

	mov	eax, DWORD PTR [ebx+4]
	mov	ebp, DWORD PTR __imp__DeleteObject@4
	cmp	eax, edx
	je	SHORT $LN19@AddBitmapC
	push	eax
	call	ebp
	xor	edx, edx
$LN19@AddBitmapC:
	mov	DWORD PTR [ebx+4], edx
	mov	DWORD PTR [ebx], edx

; 473  : 					delete _bitmapCache[i];

	mov	ebx, DWORD PTR [esi+edi*4+12]
	cmp	ebx, edx
	je	SHORT $LN15@AddBitmapC
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, edx
	je	SHORT $LN27@AddBitmapC
	push	eax
	call	ebp
	xor	edx, edx
$LN27@AddBitmapC:
	push	ebx
	mov	DWORD PTR [ebx+4], edx
	mov	DWORD PTR [ebx], edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@AddBitmapC:

; 474  : 					_bitmapCache[i]=bmp;

	mov	eax, DWORD PTR _bmp$[esp+8]
	mov	DWORD PTR [esi+edi*4+12], eax
	pop	edi
	pop	ebp
	pop	ebx

; 503  : 	}

	ret	8
$LN44@AddBitmapC:

; 484  : 				_bitmapCache[i]=bmp;

	mov	ecx, DWORD PTR _bmp$[esp+8]
	pop	edi

; 485  : 				_pageCached[i]=page;

	mov	DWORD PTR [esi+eax*4+80], ebp
	pop	ebp
	mov	DWORD PTR [esi+eax*4+12], ecx
	pop	ebx

; 503  : 	}

	ret	8
?AddBitmapCache@AFPDFDoc@@AAEXPAVPageMemory@@H@Z ENDP	; AFPDFDoc::AddBitmapCache
_TEXT	ENDS
PUBLIC	?RemoveFromCache@AFPDFDoc@@AAEXH@Z		; AFPDFDoc::RemoveFromCache
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveFromCache@AFPDFDoc@@AAEXH@Z
_TEXT	SEGMENT
?RemoveFromCache@AFPDFDoc@@AAEXH@Z PROC			; AFPDFDoc::RemoveFromCache, COMDAT
; _this$ = ebx
; _page$ = ecx

; 456  : 	void		AFPDFDoc::RemoveFromCache(int page){

	push	esi

; 457  : 		for(int i=0;i<MAX_BITMAP_CACHE;i++){

	xor	esi, esi
	lea	eax, DWORD PTR [ebx+80]
$LL4@RemoveFrom:

; 458  : 			if(_pageCached[i]==page){

	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN21@RemoveFrom
	inc	esi
	add	eax, 4
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL4@RemoveFrom
	pop	esi

; 462  : 				return;
; 463  : 			}
; 464  : 		}
; 465  : 	}

	ret	0
$LN21@RemoveFrom:
	push	ebp

; 459  : 				_bitmapCache[i]->Dispose();

	mov	ebp, DWORD PTR __imp__DeleteObject@4
	push	edi
	mov	edi, DWORD PTR [ebx+esi*4+12]
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN9@RemoveFrom
	push	eax
	call	ebp
$LN9@RemoveFrom:
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi], 0

; 460  : 				delete _bitmapCache[i];

	mov	edi, DWORD PTR [ebx+esi*4+12]
	test	edi, edi
	je	SHORT $LN7@RemoveFrom
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN17@RemoveFrom
	push	eax
	call	ebp
$LN17@RemoveFrom:
	push	edi
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi], 0
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@RemoveFrom:
	pop	edi
	pop	ebp

; 461  : 				_bitmapCache[i]=0;

	mov	DWORD PTR [ebx+esi*4+12], 0
	pop	esi

; 462  : 				return;
; 463  : 			}
; 464  : 		}
; 465  : 	}

	ret	0
?RemoveFromCache@AFPDFDoc@@AAEXH@Z ENDP			; AFPDFDoc::RemoveFromCache
_TEXT	ENDS
PUBLIC	??0CPDFSearchResult@@QAE@XZ			; CPDFSearchResult::CPDFSearchResult
; Function compile flags: /Ogtpy
;	COMDAT ??0CPDFSearchResult@@QAE@XZ
_TEXT	SEGMENT
??0CPDFSearchResult@@QAE@XZ PROC			; CPDFSearchResult::CPDFSearchResult, COMDAT
; _this$ = eax

; 419  : 	{

	xor	ecx, ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+24], ecx

; 420  : 		//
; 421  : 	}

	ret	0
??0CPDFSearchResult@@QAE@XZ ENDP			; CPDFSearchResult::CPDFSearchResult
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?printInfoDate@@YAXPAU_iobuf@@PAVDict@@PAD2@Z
_TEXT	SEGMENT
_obj$ = -24						; size = 24
_f$ = 8							; size = 4
_infoDict$ = 12						; size = 4
_fmt$ = 16						; size = 4
?printInfoDate@@YAXPAU_iobuf@@PAVDict@@PAD2@Z PROC	; printInfoDate, COMDAT
; _key$ = ecx

; 318  : 	static void printInfoDate		(FILE *f, Dict *infoDict, char *key, char *fmt) {

	sub	esp, 24					; 00000018H

; 319  : 	  Object obj;

	xor	eax, eax
	mov	DWORD PTR _obj$[esp+24], eax
	mov	DWORD PTR _obj$[esp+28], eax

; 320  : 	  char *s;
; 321  : 
; 322  : 	  if (infoDict->lookup(key, &obj)->isString()) {

	lea	eax, DWORD PTR _obj$[esp+24]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _infoDict$[esp+28]
	mov	DWORD PTR _obj$[esp+40], 13		; 0000000dH
	call	?lookup@Dict@@QAEPAVObject@@PADPAV2@@Z	; Dict::lookup
	cmp	DWORD PTR [eax+8], 3
	jne	SHORT $LN2@printInfoD

; 323  : 		s = obj.getString()->getCString();

	mov	edx, DWORD PTR _obj$[esp+40]
	mov	eax, DWORD PTR [edx+4]

; 324  : 		if (s[0] == 'D' && s[1] == ':') {

	cmp	BYTE PTR [eax], 68			; 00000044H
	jne	SHORT $LN1@printInfoD
	cmp	BYTE PTR [eax+1], 58			; 0000003aH
	jne	SHORT $LN1@printInfoD

; 325  : 		  s += 2;

	add	eax, 2
$LN1@printInfoD:

; 326  : 		}
; 327  : 		fprintf(f, fmt, s);

	mov	ecx, DWORD PTR _f$[esp+20]
	push	eax
	mov	eax, DWORD PTR _fmt$[esp+24]
	push	eax
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
$LN2@printInfoD:

; 328  : 	  }
; 329  : 	  obj.free();

	lea	ecx, DWORD PTR _obj$[esp+24]
	call	?free@Object@@QAEXXZ			; Object::free

; 330  : 	}

	add	esp, 24					; 00000018H
	ret	0
?printInfoDate@@YAXPAU_iobuf@@PAVDict@@PAD2@Z ENDP	; printInfoDate
_TEXT	ENDS
PUBLIC	_text2$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?printInfoString@@YAXPAU_iobuf@@PAVDict@@PAD22PAVUnicodeMap@@@Z
_TEXT	SEGMENT
_isUnicode$ = -48					; size = 4
_text2$GSCopy$ = -44					; size = 4
_obj$ = -40						; size = 24
_buf$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_text1$ = 12						; size = 4
_uMap$ = 16						; size = 4
?printInfoString@@YAXPAU_iobuf@@PAVDict@@PAD22PAVUnicodeMap@@@Z PROC ; printInfoString, COMDAT
; _f$ = ebx
; _infoDict$ = ecx
; _text2$ = edx

; 282  : 	{

	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+52], eax
	mov	eax, DWORD PTR _key$[esp+48]
	push	ebp
	mov	ebp, DWORD PTR _uMap$[esp+52]
	push	esi
	mov	esi, DWORD PTR _text1$[esp+56]

; 309  : 		  }
; 310  : 		  n = uMap->mapUnicode(u, buf, sizeof(buf));

	mov	DWORD PTR _text2$GSCopy$[esp+60], edx
	xor	edx, edx
	push	edi
	mov	DWORD PTR _obj$[esp+64], edx
	mov	DWORD PTR _obj$[esp+68], edx
	lea	edx, DWORD PTR _obj$[esp+64]
	push	edx
	push	eax
	mov	DWORD PTR _obj$[esp+80], 13		; 0000000dH
	call	?lookup@Dict@@QAEPAVObject@@PADPAV2@@Z	; Dict::lookup
	cmp	DWORD PTR [eax+8], 3
	jne	$LN7@printInfoS
	push	ebx
	push	esi
	call	DWORD PTR __imp__fputs
	mov	ecx, DWORD PTR _obj$[esp+88]
	mov	eax, DWORD PTR [ecx+4]
	lea	edi, DWORD PTR [ecx+4]
	add	esp, 8
	cmp	BYTE PTR [eax], 254			; 000000feH
	jne	SHORT $LN6@printInfoS

; 283  : 	  Object obj;
; 284  : 	  GString *s1;
; 285  : 	  GBool isUnicode;
; 286  : 	  Unicode u;
; 287  : 	  char buf[8];
; 288  : 	  int i, n;
; 289  : 
; 290  : 	  if (infoDict->lookup(key, &obj)->isString()) {
; 291  : 		fputs(text1, f);
; 292  : 		s1 = obj.getString();
; 293  : 		if ((s1->getChar(0) & 0xff) == 0xfe &&
; 294  : 		(s1->getChar(1) & 0xff) == 0xff) {

	cmp	BYTE PTR [eax+1], 255			; 000000ffH
	jne	SHORT $LN6@printInfoS

; 295  : 		  isUnicode = gTrue;

	mov	DWORD PTR _isUnicode$[esp+64], 1

; 296  : 		  i = 2;

	mov	esi, 2

; 297  : 		} else {

	jmp	SHORT $LN30@printInfoS
$LN6@printInfoS:

; 298  : 		  isUnicode = gFalse;

	xor	esi, esi
	mov	DWORD PTR _isUnicode$[esp+64], esi
$LN30@printInfoS:

; 299  : 		  i = 0;
; 300  : 		}
; 301  : 		while (i < obj.getString()->getLength()) {

	cmp	esi, DWORD PTR [ecx]
	jge	SHORT $LN3@printInfoS
$LN4@printInfoS:

; 302  : 		  if (isUnicode) {

	cmp	DWORD PTR _isUnicode$[esp+64], 0
	je	SHORT $LN2@printInfoS

; 303  : 		u = ((s1->getChar(i) & 0xff) << 8) |
; 304  : 			(s1->getChar(i+1) & 0xff);

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [esi+eax]
	movsx	eax, BYTE PTR [ecx+1]
	movsx	ecx, BYTE PTR [ecx]
	and	ecx, 255				; 000000ffH
	and	eax, 255				; 000000ffH
	shl	ecx, 8
	or	eax, ecx

; 305  : 		i += 2;

	add	esi, 2

; 306  : 		  } else {

	jmp	SHORT $LN1@printInfoS
$LN2@printInfoS:

; 307  : 		u = s1->getChar(i) & 0xff;

	mov	edx, DWORD PTR [edi]
	movsx	eax, BYTE PTR [esi+edx]
	and	eax, 255				; 000000ffH

; 308  : 		++i;

	inc	esi
$LN1@printInfoS:

; 309  : 		  }
; 310  : 		  n = uMap->mapUnicode(u, buf, sizeof(buf));

	push	8
	lea	ecx, DWORD PTR _buf$[esp+68]
	push	ecx
	push	eax
	mov	ecx, ebp
	call	?mapUnicode@UnicodeMap@@QAEHIPADH@Z	; UnicodeMap::mapUnicode

; 311  : 		  fwrite(buf, 1, n, f);

	push	ebx
	push	eax
	lea	edx, DWORD PTR _buf$[esp+72]
	push	1
	push	edx
	call	DWORD PTR __imp__fwrite
	mov	eax, DWORD PTR _obj$[esp+96]
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LN4@printInfoS
$LN3@printInfoS:

; 312  : 		}
; 313  : 		fputs(text2, f);

	mov	ecx, DWORD PTR _text2$GSCopy$[esp+64]
	push	ebx
	push	ecx
	call	DWORD PTR __imp__fputs
	add	esp, 8
$LN7@printInfoS:

; 314  : 	  }
; 315  : 	  obj.free();

	lea	ecx, DWORD PTR _obj$[esp+64]
	call	?free@Object@@QAEXXZ			; Object::free

; 316  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+64]
	pop	edi
	pop	esi
	pop	ebp
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 52					; 00000034H
	ret	0
?printInfoString@@YAXPAU_iobuf@@PAVDict@@PAD22PAVUnicodeMap@@@Z ENDP ; printInfoString
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\pdfdoc.h
_TEXT	ENDS
;	COMDAT ?getNumPages@PDFDoc@@QAEHXZ
_TEXT	SEGMENT
?getNumPages@PDFDoc@@QAEHXZ PROC			; PDFDoc::getNumPages, COMDAT
; _this$ = eax

; 79   :   int getNumPages() { return catalog->getNumPages(); }

	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx+12]
	ret	0
?getNumPages@PDFDoc@@QAEHXZ ENDP			; PDFDoc::getNumPages
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\tchar.h
_TEXT	ENDS
;	COMDAT ?_tcsrchr@@YAPADPADI@Z
_TEXT	SEGMENT
?_tcsrchr@@YAPADPADI@Z PROC				; _tcsrchr, COMDAT
; __S$ = eax

; 2004 :         {return ((char *)_tcsrchr((const char *)_S, _C)); }

	push	92					; 0000005cH
	push	eax
	call	DWORD PTR __imp___mbsrchr
	add	esp, 8
	ret	0
?_tcsrchr@@YAPADPADI@Z ENDP				; _tcsrchr
PUBLIC	?GotoPage@AFPDFDoc@@QAEJJ@Z			; AFPDFDoc::GotoPage
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
;	COMDAT ?GotoPage@AFPDFDoc@@QAEJJ@Z
_TEXT	SEGMENT
?GotoPage@AFPDFDoc@@QAEJJ@Z PROC			; AFPDFDoc::GotoPage, COMDAT
; _this$ = eax
; _PageNumber$ = edx

; 1779 : 		
; 1780 : 		if(m_PDFDoc){

	mov	ecx, DWORD PTR [eax+332]
	test	ecx, ecx
	je	SHORT $LN11@GotoPage

; 1781 : 			if(PageNumber>=1 && PageNumber<=m_PDFDoc->getNumPages()){

	cmp	edx, 1
	jl	SHORT $LN11@GotoPage
	mov	ecx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR [ecx+12]
	jg	SHORT $LN11@GotoPage

; 1782 : 				m_CurrentPage = PageNumber;

	mov	DWORD PTR [eax+504], edx
$LN11@GotoPage:

; 1783 : 			}
; 1784 : 		}
; 1785 : 		return m_CurrentPage;

	mov	eax, DWORD PTR [eax+504]

; 1786 : 	}

	ret	0
?GotoPage@AFPDFDoc@@QAEJJ@Z ENDP			; AFPDFDoc::GotoPage
_TEXT	ENDS
PUBLIC	?PreviousPage@AFPDFDoc@@QAEJXZ			; AFPDFDoc::PreviousPage
; Function compile flags: /Ogtpy
;	COMDAT ?PreviousPage@AFPDFDoc@@QAEJXZ
_TEXT	SEGMENT
?PreviousPage@AFPDFDoc@@QAEJXZ PROC			; AFPDFDoc::PreviousPage, COMDAT
; _this$ = ecx

; 1767 : 		
; 1768 : 		if(m_PDFDoc){

	mov	edx, DWORD PTR [ecx+332]

; 1769 : 			long pageno = m_CurrentPage - 1;

	mov	eax, DWORD PTR [ecx+504]
	test	edx, edx
	je	SHORT $LN1@PreviousPa
	dec	eax

; 1770 : 			if(pageno>=1 && pageno<=m_PDFDoc->getNumPages()){

	cmp	eax, 1
	jl	SHORT $LN10@PreviousPa
	mov	edx, DWORD PTR [edx+28]
	cmp	eax, DWORD PTR [edx+12]
	jg	SHORT $LN10@PreviousPa

; 1771 : 				m_CurrentPage = pageno;

	mov	DWORD PTR [ecx+504], eax
$LN10@PreviousPa:

; 1772 : 			}
; 1773 : 		}
; 1774 : 		return m_CurrentPage;

	mov	eax, DWORD PTR [ecx+504]
$LN1@PreviousPa:

; 1775 : 	}

	ret	0
?PreviousPage@AFPDFDoc@@QAEJXZ ENDP			; AFPDFDoc::PreviousPage
_TEXT	ENDS
PUBLIC	?NextPage@AFPDFDoc@@QAEJXZ			; AFPDFDoc::NextPage
; Function compile flags: /Ogtpy
;	COMDAT ?NextPage@AFPDFDoc@@QAEJXZ
_TEXT	SEGMENT
?NextPage@AFPDFDoc@@QAEJXZ PROC				; AFPDFDoc::NextPage, COMDAT
; _this$ = ecx

; 1755 : 		
; 1756 : 		if(m_PDFDoc){

	mov	edx, DWORD PTR [ecx+332]

; 1757 : 			long pageno = m_CurrentPage + 1;

	mov	eax, DWORD PTR [ecx+504]
	test	edx, edx
	je	SHORT $LN1@NextPage
	inc	eax

; 1758 : 			if(pageno>=1 && pageno<=m_PDFDoc->getNumPages()){

	cmp	eax, 1
	jl	SHORT $LN10@NextPage
	mov	edx, DWORD PTR [edx+28]
	cmp	eax, DWORD PTR [edx+12]
	jg	SHORT $LN10@NextPage

; 1759 : 				m_CurrentPage = pageno;

	mov	DWORD PTR [ecx+504], eax
$LN10@NextPage:

; 1760 : 			}
; 1761 : 		}
; 1762 : 		return m_CurrentPage;

	mov	eax, DWORD PTR [ecx+504]
$LN1@NextPage:

; 1763 : 	}

	ret	0
?NextPage@AFPDFDoc@@QAEJXZ ENDP				; AFPDFDoc::NextPage
_TEXT	ENDS
PUBLIC	?GetPageCount@AFPDFDoc@@QAEJXZ			; AFPDFDoc::GetPageCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetPageCount@AFPDFDoc@@QAEJXZ
_TEXT	SEGMENT
?GetPageCount@AFPDFDoc@@QAEJXZ PROC			; AFPDFDoc::GetPageCount, COMDAT
; _this$ = eax

; 1743 : 		
; 1744 : 		if(m_PDFDoc){

	mov	eax, DWORD PTR [eax+332]
	test	eax, eax
	je	SHORT $LN1@GetPageCou

; 1745 : 			if(m_PDFDoc->isOk()){

	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN1@GetPageCou

; 1746 : 				return m_PDFDoc->getNumPages();

	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx+12]

; 1750 : 	}

	ret	0
$LN1@GetPageCou:

; 1747 : 			}
; 1748 : 		}
; 1749 : 		return 0;

	xor	eax, eax

; 1750 : 	}

	ret	0
?GetPageCount@AFPDFDoc@@QAEJXZ ENDP			; AFPDFDoc::GetPageCount
_TEXT	ENDS
PUBLIC	?OutputToDelegate@@YAXPAXPADH@Z			; OutputToDelegate
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OutputToDelegate@@YAXPAXPADH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OutputToDelegate@@YAXPAXPADH@Z$0
__ehfuncinfo$?OutputToDelegate@@YAXPAXPADH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OutputToDelegate@@YAXPAXPADH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?OutputToDelegate@@YAXPAXPADH@Z
_TEXT	SEGMENT
_s$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_stream$ = 8						; size = 4
_isUnicode$ = 12					; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
?OutputToDelegate@@YAXPAXPADH@Z PROC			; OutputToDelegate, COMDAT

; 64   : 	void OutputToDelegate(void *stream, char *str, int len){

	push	-1
	push	__ehhandler$?OutputToDelegate@@YAXPAXPADH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, eax

; 65   : 
; 66   : 		GBool isUnicode;
; 67   : 		Unicode u;
; 68   : 		int i;
; 69   : 		int j=0;
; 70   : 		GString s;

	lea	ecx, DWORD PTR _s$[esp+40]
	xor	esi, esi
	xor	ebp, ebp
	call	??0GString@@QAE@XZ			; GString::GString

; 71   : 		
; 72   : 		if ((str[0] & 0xff) == 0xfe && (str[1] & 0xff) == 0xff) {

	mov	edi, DWORD PTR _str$[esp+36]
	mov	DWORD PTR __$EHRec$[esp+48], esi
	cmp	BYTE PTR [edi], 254			; 000000feH
	jne	SHORT $LN7@OutputToDe
	cmp	BYTE PTR [edi+1], 255			; 000000ffH
	jne	SHORT $LN7@OutputToDe

; 73   : 			isUnicode = gTrue;

	mov	DWORD PTR _isUnicode$[esp+36], 1

; 74   : 			i = 2;

	lea	esi, DWORD PTR [ebp+2]

; 75   : 		} else {

	jmp	SHORT $LN6@OutputToDe
$LN7@OutputToDe:

; 76   : 			isUnicode = gFalse;

	mov	DWORD PTR _isUnicode$[esp+36], esi
$LN6@OutputToDe:

; 77   : 			i = 0;
; 78   : 		}
; 79   : 		
; 80   : 		wchar_t *ret =new wchar_t[len+1];

	mov	eax, DWORD PTR _len$[esp+36]
	xor	ecx, ecx
	inc	eax
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 81   : 		
; 82   : 		while (i < len) {

	mov	ecx, DWORD PTR _len$[esp+40]
	add	esp, 4
	cmp	esi, ecx
	mov	ebx, eax
	jge	SHORT $LN4@OutputToDe
$LL5@OutputToDe:

; 83   : 			  if (isUnicode) {
; 84   : 					u = ((str[i] & 0xff) << 8) |  (str[i+1] & 0xff);

	movsx	eax, BYTE PTR [esi+edi]
	and	eax, 255				; 000000ffH
	cmp	DWORD PTR _isUnicode$[esp+36], 0
	je	SHORT $LN3@OutputToDe
	movsx	edx, BYTE PTR [esi+edi+1]
	shl	eax, 8
	and	edx, 255				; 000000ffH
	or	eax, edx

; 85   : 					i += 2;

	add	esi, 2

; 86   : 			  } else {

	jmp	SHORT $LN2@OutputToDe
$LN3@OutputToDe:

; 87   : 					u = str[i] & 0xff;
; 88   : 					++i;

	inc	esi
$LN2@OutputToDe:

; 89   : 			  }
; 90   : 			  ret[j] = u;

	mov	WORD PTR [ebx+ebp*2], ax

; 91   : 			  j++;

	inc	ebp
	cmp	esi, ecx
	jl	SHORT $LL5@OutputToDe
$LN4@OutputToDe:

; 92   : 		}
; 93   : 		ret[j]='\0';

	xor	eax, eax
	mov	WORD PTR [ebx+ebp*2], ax

; 94   : 
; 95   : 		if(stream)

	mov	eax, DWORD PTR _stream$[esp+36]
	test	eax, eax
	je	SHORT $LN1@OutputToDe

; 96   : 			((OUTPUTFUNCTION)stream)(ret,len);

	push	ecx
	push	ebx
	call	eax
$LN1@OutputToDe:

; 97   : 
; 98   : 		delete ret;

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 99   : 	}

	lea	ecx, DWORD PTR _s$[esp+40]
	call	??1GString@@QAE@XZ			; GString::~GString
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OutputToDelegate@@YAXPAXPADH@Z$0:
	lea	ecx, DWORD PTR _s$[ebp]
	jmp	??1GString@@QAE@XZ			; GString::~GString
__ehhandler$?OutputToDelegate@@YAXPAXPADH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-24]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?OutputToDelegate@@YAXPAXPADH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?OutputToDelegate@@YAXPAXPADH@Z ENDP			; OutputToDelegate
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\pdfdoc.h
;	COMDAT ?getDocInfo@PDFDoc@@QAEPAVObject@@PAV2@@Z
_TEXT	SEGMENT
?getDocInfo@PDFDoc@@QAEPAVObject@@PAV2@@Z PROC		; PDFDoc::getDocInfo, COMDAT
; _this$ = ecx
; _obj$ = eax

; 148  :   Object *getDocInfo(Object *obj) { return xref->getDocInfo(obj); }

	mov	ecx, DWORD PTR [ecx+24]
	push	eax
	call	?getDocInfo@XRef@@QAEPAVObject@@PAV2@@Z	; XRef::getDocInfo
	ret	0
?getDocInfo@PDFDoc@@QAEPAVObject@@PAV2@@Z ENDP		; PDFDoc::getDocInfo
PUBLIC	?FitScreenHeight@AFPDFDoc@@QAENJ@Z		; AFPDFDoc::FitScreenHeight
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
;	COMDAT ?FitScreenHeight@AFPDFDoc@@QAENJ@Z
_TEXT	SEGMENT
tv352 = -36						; size = 4
tv350 = -36						; size = 4
tv331 = -36						; size = 4
_height$86340 = -32					; size = 8
tv323 = -24						; size = 8
_clientArea$86338 = -16					; size = 16
?FitScreenHeight@AFPDFDoc@@QAENJ@Z PROC			; AFPDFDoc::FitScreenHeight, COMDAT
; _this$ = esi
; _lhWnd$ = ecx

; 1852 : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 40					; 00000028H

; 1853 : 		
; 1854 : 
; 1855 : 			if (m_PDFDoc!=NULL){

	cmp	DWORD PTR [esi+332], 0
	je	$LN51@FitScreenH

; 1856 : 			RECT clientArea;
; 1857 : 
; 1858 : 			//We start with invisible scrollbars. If needed, we enable SB_HORZ later.
; 1859 : //			SetScrollRange(SB_VERT,0,0);
; 1860 : //			SetScrollRange(SB_HORZ,0,0);
; 1861 : 
; 1862 : 			::GetClientRect((HWND)lhWnd,&clientArea);

	lea	eax, DWORD PTR _clientArea$86338[esp+40]
	push	eax
	push	ecx
	call	DWORD PTR __imp__GetClientRect@8

; 1863 : 			double height = clientArea.bottom-clientArea.top;

	mov	edx, DWORD PTR _clientArea$86338[esp+52]
	sub	edx, DWORD PTR _clientArea$86338[esp+44]

; 1864 : 			double width = clientArea.right-clientArea.left;

	mov	eax, DWORD PTR _clientArea$86338[esp+48]
	sub	eax, DWORD PTR _clientArea$86338[esp+40]

; 1865 : 			double contentHeight = 0;
; 1866 : 			if (m_Rotation==0||m_Rotation==180){

	mov	ecx, DWORD PTR [esi+524]
	mov	DWORD PTR tv352[esp+40], edx
	fild	DWORD PTR tv352[esp+40]
	mov	DWORD PTR tv350[esp+40], eax
	fst	QWORD PTR _height$86340[esp+40]
	fild	DWORD PTR tv350[esp+40]
	test	ecx, ecx
	je	SHORT $LN6@FitScreenH
	cmp	ecx, 180				; 000000b4H
	je	SHORT $LN6@FitScreenH

; 1868 : 			} else {
; 1869 : 				contentHeight = m_PDFDoc->getPageCropWidth(m_CurrentPage);

	mov	eax, DWORD PTR [esi+332]
	mov	eax, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [esi+504]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edx*4-4]
	mov	edx, DWORD PTR [eax+8]
	fld	QWORD PTR [edx+48]
	fsub	QWORD PTR [edx+32]
	jmp	SHORT $LN5@FitScreenH
$LN6@FitScreenH:

; 1867 : 				contentHeight = m_PDFDoc->getPageCropHeight(m_CurrentPage);

	mov	eax, DWORD PTR [esi+332]
	mov	eax, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [esi+504]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edx*4-4]
	mov	edx, DWORD PTR [eax+8]
	fld	QWORD PTR [edx+56]
	fsub	QWORD PTR [edx+40]
$LN5@FitScreenH:

; 1870 : 			}
; 1871 : 			double contentWidth = 0;
; 1872 : 			if (m_Rotation==0||m_Rotation==180){

	test	ecx, ecx
	je	SHORT $LN3@FitScreenH
	cmp	ecx, 180				; 000000b4H
	je	SHORT $LN3@FitScreenH

; 1874 : 			} else {
; 1875 : 				contentWidth = m_PDFDoc->getPageCropHeight(m_CurrentPage);

	mov	eax, DWORD PTR [eax+8]
	fld	QWORD PTR [eax+56]
	fsub	QWORD PTR [eax+40]
	jmp	SHORT $LN2@FitScreenH
$LN3@FitScreenH:

; 1873 : 				contentWidth = m_PDFDoc->getPageCropWidth(m_CurrentPage);

	mov	eax, DWORD PTR [eax+8]
	fld	QWORD PTR [eax+48]
	fsub	QWORD PTR [eax+32]
$LN2@FitScreenH:

; 1876 : 			}
; 1877 : 
; 1878 : 			m_renderDPI = 72.0/contentHeight*height;

	fld	QWORD PTR __real@4052000000000000
	fld	ST(0)
	fdivrp	ST(3), ST(0)
	fxch	ST(2)
	fst	QWORD PTR tv323[esp+40]
	fld	ST(0)
	fmul	ST(0), ST(5)
	fst	QWORD PTR [esi+536]

; 1879 : 			//Now we know the required DPI if there weren't any scrollbars
; 1880 : 	//		if (!m_ConfigDialog.m_HideScrollbars)
; 1881 : 			{
; 1882 : 				double targetWidth = (m_renderDPI*contentWidth)/72.0;

	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdivrp	ST(2), ST(0)

; 1883 : 				if (targetWidth > width)

	fxch	ST(1)
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@FitScreenH
	fstp	ST(0)

; 1884 : 				{
; 1885 : 					height -= GetSystemMetrics(SM_CYHSCROLL);

	push	3
	fstp	ST(0)
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR tv331[esp+40], eax
	fild	DWORD PTR tv331[esp+40]
	fsubr	QWORD PTR _height$86340[esp+40]
	fld	QWORD PTR tv323[esp+40]
$LN1@FitScreenH:

; 1886 : 	/*				SetScrollRange(SB_VERT,0,targetWidth-1);
; 1887 : 					GetClientRect(&clientArea);
; 1888 : 					height = clientArea.bottom-clientArea.top;
; 1889 : 					width = clientArea.right-clientArea.left;
; 1890 : 	*/
; 1891 : 				} 
; 1892 : 				m_renderDPI = 72.0/contentHeight*height;

	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [esi+536]
$LN51@FitScreenH:

; 1893 : 				//Now the result takes the potential scrollbar into account
; 1894 : 			}
; 1895 : 		}
; 1896 : 		return m_renderDPI;

	fld	QWORD PTR [esi+536]

; 1897 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?FitScreenHeight@AFPDFDoc@@QAENJ@Z ENDP			; AFPDFDoc::FitScreenHeight
_TEXT	ENDS
PUBLIC	?FitScreenWidth@AFPDFDoc@@QAENJ@Z		; AFPDFDoc::FitScreenWidth
; Function compile flags: /Ogtpy
;	COMDAT ?FitScreenWidth@AFPDFDoc@@QAENJ@Z
_TEXT	SEGMENT
tv352 = -36						; size = 4
tv350 = -36						; size = 4
tv331 = -36						; size = 4
_width$86322 = -32					; size = 8
tv323 = -24						; size = 8
_clientArea$86319 = -16					; size = 16
?FitScreenWidth@AFPDFDoc@@QAENJ@Z PROC			; AFPDFDoc::FitScreenWidth, COMDAT
; _this$ = esi
; _lhWnd$ = ecx

; 1802 : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 40					; 00000028H

; 1803 : 		
; 1804 : 		if (m_PDFDoc!=NULL)

	cmp	DWORD PTR [esi+332], 0
	je	$LN51@FitScreenW

; 1805 : 		{
; 1806 : 			RECT clientArea;
; 1807 : 
; 1808 : 			//We start with invisible scrollbars. If needed, we enable SB_VERT later.
; 1809 : //			SetScrollRange(SB_VERT,0,0);
; 1810 : //			SetScrollRange(SB_HORZ,0,0);
; 1811 : 
; 1812 : 			::GetClientRect((HWND)lhWnd, &clientArea);

	lea	eax, DWORD PTR _clientArea$86319[esp+40]
	push	eax
	push	ecx
	call	DWORD PTR __imp__GetClientRect@8

; 1813 : 			double height = clientArea.bottom-clientArea.top;

	mov	edx, DWORD PTR _clientArea$86319[esp+52]
	sub	edx, DWORD PTR _clientArea$86319[esp+44]

; 1814 : 			double width = clientArea.right-clientArea.left;

	mov	eax, DWORD PTR _clientArea$86319[esp+48]
	sub	eax, DWORD PTR _clientArea$86319[esp+40]

; 1815 : 			double contentHeight = 0;
; 1816 : 			if (m_Rotation==0||m_Rotation==180){

	mov	ecx, DWORD PTR [esi+524]
	mov	DWORD PTR tv352[esp+40], edx
	fild	DWORD PTR tv352[esp+40]
	mov	DWORD PTR tv350[esp+40], eax
	fild	DWORD PTR tv350[esp+40]
	fst	QWORD PTR _width$86322[esp+40]
	test	ecx, ecx
	je	SHORT $LN6@FitScreenW
	cmp	ecx, 180				; 000000b4H
	je	SHORT $LN6@FitScreenW

; 1818 : 			} else {
; 1819 : 				contentHeight = m_PDFDoc->getPageCropWidth(m_CurrentPage);

	mov	eax, DWORD PTR [esi+332]
	mov	eax, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [esi+504]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edx*4-4]
	mov	edx, DWORD PTR [eax+8]
	fld	QWORD PTR [edx+48]
	fsub	QWORD PTR [edx+32]
	jmp	SHORT $LN5@FitScreenW
$LN6@FitScreenW:

; 1817 : 				contentHeight = m_PDFDoc->getPageCropHeight(m_CurrentPage);

	mov	eax, DWORD PTR [esi+332]
	mov	eax, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [esi+504]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edx*4-4]
	mov	edx, DWORD PTR [eax+8]
	fld	QWORD PTR [edx+56]
	fsub	QWORD PTR [edx+40]
$LN5@FitScreenW:

; 1820 : 			}
; 1821 : 			double contentWidth = 0;
; 1822 : 			if (m_Rotation==0||m_Rotation==180){

	test	ecx, ecx
	je	SHORT $LN3@FitScreenW
	cmp	ecx, 180				; 000000b4H
	je	SHORT $LN3@FitScreenW

; 1824 : 			} else {
; 1825 : 				contentWidth = m_PDFDoc->getPageCropHeight(m_CurrentPage);

	mov	eax, DWORD PTR [eax+8]
	fld	QWORD PTR [eax+56]
	fsub	QWORD PTR [eax+40]
	jmp	SHORT $LN2@FitScreenW
$LN3@FitScreenW:

; 1823 : 				contentWidth = m_PDFDoc->getPageCropWidth(m_CurrentPage);

	mov	eax, DWORD PTR [eax+8]
	fld	QWORD PTR [eax+48]
	fsub	QWORD PTR [eax+32]
$LN2@FitScreenW:

; 1826 : 			}
; 1827 : 
; 1828 : 			m_renderDPI = 72.0/contentWidth*width;

	fld	QWORD PTR __real@4052000000000000
	fld	ST(0)
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv323[esp+40]
	fld	ST(0)
	fmul	ST(0), ST(4)
	fst	QWORD PTR [esi+536]

; 1829 : 			//Now we know the required DPI if there weren't any scrollbars
; 1830 : 
; 1831 : 	//		if (!m_ConfigDialog.m_HideScrollbars)
; 1832 : 			{
; 1833 : 				double targetHeight = (m_renderDPI*contentHeight)/72.0;

	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fdivrp	ST(1), ST(0)

; 1834 : 				if (targetHeight>height)

	fcomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@FitScreenW
	fstp	ST(1)

; 1835 : 				{
; 1836 : 					width -= GetSystemMetrics(SM_CXVSCROLL);

	push	2
	fstp	ST(0)
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR tv331[esp+40], eax
	fild	DWORD PTR tv331[esp+40]
	fsubr	QWORD PTR _width$86322[esp+40]
	fld	QWORD PTR tv323[esp+40]
	fxch	ST(1)
$LN1@FitScreenW:

; 1837 : 	/*
; 1838 : 					SetScrollRange(SB_VERT,0,100);
; 1839 : 					GetClientRect(&clientArea);
; 1840 : 					height = clientArea.bottom-clientArea.top;
; 1841 : 					width = clientArea.right-clientArea.left;
; 1842 : 	*/
; 1843 : 				} 
; 1844 : 				m_renderDPI = 72.0/contentWidth*width;

	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [esi+536]
$LN51@FitScreenW:

; 1845 : 				//Now the result takes the potential scrollbar into account
; 1846 : 			}
; 1847 : 		}
; 1848 : 		return m_renderDPI;

	fld	QWORD PTR [esi+536]

; 1849 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?FitScreenWidth@AFPDFDoc@@QAENJ@Z ENDP			; AFPDFDoc::FitScreenWidth
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GPDFDoc@@QAEPAXI@Z
_TEXT	SEGMENT
??_GPDFDoc@@QAEPAXI@Z PROC				; PDFDoc::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	ecx, esi
	call	??1PDFDoc@@QAE@XZ			; PDFDoc::~PDFDoc
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	ret	0
??_GPDFDoc@@QAEPAXI@Z ENDP				; PDFDoc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Dispose@AFPDFDoc@@QAEXXZ			; AFPDFDoc::Dispose
; Function compile flags: /Ogtpy
;	COMDAT ?Dispose@AFPDFDoc@@QAEXXZ
_TEXT	SEGMENT
_exitcode$85660 = -4					; size = 4
_exitcode$85656 = -4					; size = 4
?Dispose@AFPDFDoc@@QAEXXZ PROC				; AFPDFDoc::Dispose, COMDAT
; _this$ = edi

; 578  : 	void AFPDFDoc::Dispose(){

	push	ecx

; 579  : 
; 580  : 		
; 581  : 		m_QueuedThumbs.shutdown();

	mov	eax, DWORD PTR [edi+252]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __imp__SetEvent@4
	push	eax
	call	esi

; 582  : 		if(m_renderingThread){

	mov	eax, DWORD PTR [edi+240]
	mov	ebp, DWORD PTR __imp__GetExitCodeThread@8
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN7@Dispose@2

; 583  : 			DWORD exitcode=0;
; 584  : 			GetExitCodeThread(m_renderingThread,&exitcode);

	lea	ecx, DWORD PTR _exitcode$85656[esp+16]
	push	ecx
	push	eax
	mov	DWORD PTR _exitcode$85656[esp+24], ebx
	call	ebp

; 585  : 			if(exitcode==STILL_ACTIVE){

	cmp	DWORD PTR _exitcode$85656[esp+16], 259	; 00000103H
	jne	SHORT $LN6@Dispose@2

; 586  : 				::InterlockedExchange(&g_lLocker,1);

	push	1
	lea	edx, DWORD PTR [edi+164]
	push	edx
	call	DWORD PTR __imp__InterlockedExchange@8

; 587  : 				::WaitForSingleObject(hRenderFinished,INFINITE);

	mov	eax, DWORD PTR [edi+176]
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN6@Dispose@2:

; 588  : 				//TerminateThread(m_renderingThread,exitcode);
; 589  : 			}
; 590  : 			CloseHandle(m_renderingThread);

	mov	ecx, DWORD PTR [edi+240]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 591  : 			m_renderingThread=0;

	mov	DWORD PTR [edi+240], ebx
$LN7@Dispose@2:

; 592  : 		}
; 593  : 		if(m_exportJpgThread){

	cmp	DWORD PTR [edi+244], ebx
	je	SHORT $LN5@Dispose@2

; 594  : 			DWORD exitcode=0;
; 595  : 			GetExitCodeThread(m_renderingThread,&exitcode);

	mov	eax, DWORD PTR [edi+240]
	lea	edx, DWORD PTR _exitcode$85660[esp+16]
	push	edx
	push	eax
	mov	DWORD PTR _exitcode$85660[esp+24], ebx
	call	ebp

; 596  : 			if(exitcode==STILL_ACTIVE){

	cmp	DWORD PTR _exitcode$85660[esp+16], 259	; 00000103H
	jne	SHORT $LN4@Dispose@2

; 597  : 				::SetEvent(hExportJpgCancel);

	mov	ecx, DWORD PTR [edi+172]
	push	ecx
	call	esi

; 598  : 				::WaitForSingleObject(hExportJpgFinished,INFINITE);

	mov	edx, DWORD PTR [edi+184]
	push	-1
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN4@Dispose@2:

; 599  : 				//TerminateThread(m_exportJpgThread,exitcode);
; 600  : 			}
; 601  : 			CloseHandle(m_exportJpgThread);

	mov	eax, DWORD PTR [edi+244]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 602  : 			m_exportJpgThread=0;

	mov	DWORD PTR [edi+244], ebx
$LN5@Dispose@2:

; 603  : 		}
; 604  : 
; 605  : 		if(m_LastOpenedStream)

	mov	ecx, DWORD PTR [edi+236]
	cmp	ecx, ebx
	je	SHORT $LN3@Dispose@2

; 606  : 		{
; 607  : 			m_LastOpenedStream->close();

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 608  : 			//Let PDFDoc to delete the stream
; 609  : 			//delete m_LastOpenedStream;
; 610  : 			m_LastOpenedStream=0;

	mov	DWORD PTR [edi+236], ebx
$LN3@Dispose@2:

; 611  : 		}
; 612  : 		
; 613  : 		InvalidateBitmapCache();

	mov	eax, edi
	call	?InvalidateBitmapCache@AFPDFDoc@@AAEXXZ	; AFPDFDoc::InvalidateBitmapCache

; 614  : 		m_Bitmap=0;
; 615  : 
; 616  : 		if (m_splashOut!=NULL)

	mov	esi, DWORD PTR [edi+344]
	mov	DWORD PTR [edi+352], ebx
	cmp	esi, ebx
	je	SHORT $LN2@Dispose@2

; 617  : 		{
; 618  : 			delete m_splashOut;

	call	??_GAuxOutputDev@@QAEPAXI@Z

; 619  : 			m_splashOut=0;

	mov	DWORD PTR [edi+344], ebx
$LN2@Dispose@2:

; 620  : 		}
; 621  : 
; 622  : 		if (m_PDFDoc!=NULL)

	mov	esi, DWORD PTR [edi+332]
	cmp	esi, ebx
	je	SHORT $LN1@Dispose@2

; 623  : 		{
; 624  : 			delete m_PDFDoc;

	mov	ecx, esi
	call	??1PDFDoc@@QAE@XZ			; PDFDoc::~PDFDoc
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 625  : 			m_PDFDoc=0;

	mov	DWORD PTR [edi+332], ebx
$LN1@Dispose@2:
	pop	esi
	pop	ebp
	pop	ebx

; 626  : 		}	
; 627  : 	}

	pop	ecx
	ret	0
?Dispose@AFPDFDoc@@QAEXXZ ENDP				; AFPDFDoc::Dispose
_TEXT	ENDS
PUBLIC	??1AFPDFDoc@@UAE@XZ				; AFPDFDoc::~AFPDFDoc
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\dynarray.h
xdata$x	SEGMENT
__unwindtable$??1AFPDFDoc@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AFPDFDoc@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1AFPDFDoc@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1AFPDFDoc@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1AFPDFDoc@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1AFPDFDoc@@UAE@XZ$4
__ehfuncinfo$??1AFPDFDoc@@UAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1AFPDFDoc@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ??1AFPDFDoc@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AFPDFDoc@@UAE@XZ PROC				; AFPDFDoc::~AFPDFDoc, COMDAT
; _this$ = ecx

; 571  : 	{

	push	-1
	push	__ehhandler$??1AFPDFDoc@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+28], edi
	mov	DWORD PTR [edi], OFFSET ??_7AFPDFDoc@@6B@
	mov	DWORD PTR __$EHRec$[esp+36], 4

; 572  : 		
; 573  : 		this->Dispose();

	call	?Dispose@AFPDFDoc@@QAEXXZ		; AFPDFDoc::Dispose

; 574  : 		gDestroyMutex(&this->hgMutex);

	lea	eax, DWORD PTR [edi+188]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 575  : 		CloseHandle(hRenderFinished);

	mov	ecx, DWORD PTR [edi+176]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 576  : 	}

	lea	ecx, DWORD PTR [edi+384]
	mov	BYTE PTR __$EHRec$[esp+36], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [edi+356]
	mov	BYTE PTR __$EHRec$[esp+36], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR [edi+320]
	test	eax, eax
	je	SHORT $LN8@AFPDFDoc
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	mov	DWORD PTR [edi+320], 0
$LN8@AFPDFDoc:
	lea	esi, DWORD PTR [edi+252]
	call	??1Queue@@QAE@XZ			; Queue::~Queue
	lea	ecx, DWORD PTR [edi+228]
	call	??1GString@@QAE@XZ			; GString::~GString
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1AFPDFDoc@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 228				; 000000e4H
	jmp	??1GString@@QAE@XZ			; GString::~GString
__unwindfunclet$??1AFPDFDoc@@UAE@XZ$1:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 252				; 000000fcH
	jmp	??1Queue@@QAE@XZ			; Queue::~Queue
__unwindfunclet$??1AFPDFDoc@@UAE@XZ$2:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 320				; 00000140H
	jmp	??1?$DynArray@VCPDFSearchResult@@@@QAE@XZ ; DynArray<CPDFSearchResult>::~DynArray<CPDFSearchResult>
__unwindfunclet$??1AFPDFDoc@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 356				; 00000164H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??1AFPDFDoc@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 384				; 00000180H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1AFPDFDoc@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AFPDFDoc@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AFPDFDoc@@UAE@XZ ENDP				; AFPDFDoc::~AFPDFDoc
; Function compile flags: /Ogtpy
;	COMDAT ??_GAFPDFDoc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GAFPDFDoc@@UAEPAXI@Z PROC				; AFPDFDoc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1AFPDFDoc@@UAE@XZ			; AFPDFDoc::~AFPDFDoc
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@11
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@11:
	mov	eax, esi
	pop	esi
	ret	4
??_GAFPDFDoc@@UAEPAXI@Z ENDP				; AFPDFDoc::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ?getDocInfo@@YAPA_WPADPAVPDFDoc@@@Z
_TEXT	SEGMENT
_info$ = -24						; size = 24
_doc$ = 8						; size = 4
?getDocInfo@@YAPA_WPADPAVPDFDoc@@@Z PROC		; getDocInfo, COMDAT

; 399  : 	static wchar_t	*	getDocInfo(char *key,PDFDoc *doc){

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 24					; 00000018H

; 400  : 		Object info;
; 401  : 		UnicodeMap *uMap;
; 402  : 		if (!(uMap = globalParams->getTextEncoding())) {

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	xor	eax, eax
	mov	DWORD PTR _info$[esp+24], eax
	mov	DWORD PTR _info$[esp+28], eax
	mov	DWORD PTR _info$[esp+32], 13		; 0000000dH
	call	?getTextEncoding@GlobalParams@@QAEPAVUnicodeMap@@XZ ; GlobalParams::getTextEncoding
	test	eax, eax

; 403  : 			return (EmptyChar);			

	je	SHORT $LN15@getDocInfo

; 404  : 		}
; 405  : 
; 406  : 		doc->getDocInfo(&info);

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR _info$[esp+24]
	push	eax
	call	?getDocInfo@XRef@@QAEPAVObject@@PAV2@@Z	; XRef::getDocInfo
$LN15@getDocInfo:

; 407  : 		if (info.isDict()) {

	mov	eax, OFFSET _EmptyChar

; 408  : 			Dict *infoDict = info.getDict();
; 409  : 			return getDicString(infoDict,key,uMap);
; 410  : 		}
; 411  : 		return (EmptyChar);
; 412  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getDocInfo@@YAPA_WPADPAVPDFDoc@@@Z ENDP		; getDocInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?InitGlobalParams@@YAXPAD@Z			; InitGlobalParams
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\globals.cpp
xdata$x	SEGMENT
__unwindtable$?InitGlobalParams@@YAXPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitGlobalParams@@YAXPAD@Z$0
__ehfuncinfo$?InitGlobalParams@@YAXPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InitGlobalParams@@YAXPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?InitGlobalParams@@YAXPAD@Z
_TEXT	SEGMENT
$T185242 = -280						; size = 4
_szExe$85376 = -276					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?InitGlobalParams@@YAXPAD@Z PROC			; InitGlobalParams, COMDAT
; _configFile$ = edi

; 103  : 	void InitGlobalParams(char *configFile){

	push	-1
	push	__ehhandler$?InitGlobalParams@@YAXPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+280], eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+288]
	mov	DWORD PTR fs:0, eax

; 104  : 		if(globalParams==0){

	cmp	DWORD PTR ?globalParams@@3PAVGlobalParams@@A, 0 ; globalParams
	jne	$LN2@InitGlobal

; 105  : 			TCHAR szExe[MAX_PATH];
; 106  : 			int size = ::GetModuleFileName(NULL, szExe, MAX_PATH); 

	push	260					; 00000104H
	lea	eax, DWORD PTR _szExe$85376[esp+292]
	push	eax
	push	0
	call	DWORD PTR __imp__GetModuleFileNameA@12

; 107  : 			TCHAR *pLastSlash = _tcsrchr(szExe, ('\\'));

	lea	ecx, DWORD PTR _szExe$85376[esp+288]
	push	92					; 0000005cH
	push	ecx
	call	DWORD PTR __imp___mbsrchr
	add	esp, 8

; 108  : 			
; 109  : 			if (pLastSlash){

	test	eax, eax
	je	SHORT $LN1@InitGlobal

; 110  : 				// Truncate at slash to get app dir
; 111  : 				*pLastSlash=L'\0';

	mov	BYTE PTR [eax], 0
$LN1@InitGlobal:

; 112  : 			}
; 113  : 
; 114  : 			char *baseDir = new char[wcslen((const wchar_t *)szExe)+1];

	lea	eax, DWORD PTR _szExe$85376[esp+288]
	lea	edx, DWORD PTR [eax+2]
$LL14@InitGlobal:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL14@InitGlobal
	sub	eax, edx
	sar	eax, 1
	inc	eax
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 115  : 			sprintf(baseDir,"%S",szExe);

	lea	edx, DWORD PTR _szExe$85376[esp+292]
	push	edx
	mov	esi, eax
	push	OFFSET ??_C@_02KPKOKMHB@?$CFS?$AA@
	push	esi
	call	DWORD PTR __imp__sprintf

; 116  : 
; 117  : 			globalParams = new GlobalParams(configFile);

	push	352					; 00000160H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 20					; 00000014H
	mov	DWORD PTR $T185242[esp+288], eax
	mov	DWORD PTR __$EHRec$[esp+296], 0
	test	eax, eax
	je	SHORT $LN5@InitGlobal
	push	edi
	mov	ecx, eax
	call	??0GlobalParams@@QAE@PAD@Z		; GlobalParams::GlobalParams
	jmp	SHORT $LN6@InitGlobal
$LN5@InitGlobal:
	xor	eax, eax
$LN6@InitGlobal:
	mov	DWORD PTR __$EHRec$[esp+296], -1

; 118  : 			//Initialize default settings
; 119  : 			globalParams->setupBaseFonts(baseDir);

	push	esi
	mov	ecx, eax
	mov	DWORD PTR ?globalParams@@3PAVGlobalParams@@A, eax ; globalParams
	call	?setupBaseFonts@GlobalParams@@QAEXPAD@Z	; GlobalParams::setupBaseFonts

; 120  : 			globalParams->setErrQuiet(gFalse);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	0
	call	?setErrQuiet@GlobalParams@@QAEXH@Z	; GlobalParams::setErrQuiet

; 121  : 			globalParams->setEnableT1lib("no");

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	OFFSET ??_C@_02KAJCLHKP@no?$AA@
	call	?setEnableT1lib@GlobalParams@@QAEHPAD@Z	; GlobalParams::setEnableT1lib

; 122  : 			globalParams->setEnableFreeType("yes");

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	OFFSET ??_C@_03ICICOMAL@yes?$AA@
	call	?setEnableFreeType@GlobalParams@@QAEHPAD@Z ; GlobalParams::setEnableFreeType

; 123  : 			globalParams->setPSEmbedCIDPostScript(1);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	1
	call	?setPSEmbedCIDPostScript@GlobalParams@@QAEXH@Z ; GlobalParams::setPSEmbedCIDPostScript

; 124  : 			globalParams->setPSEmbedCIDTrueType(1);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	1
	call	?setPSEmbedCIDTrueType@GlobalParams@@QAEXH@Z ; GlobalParams::setPSEmbedCIDTrueType

; 125  : 			globalParams->setPSEmbedTrueType(1);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	1
	call	?setPSEmbedTrueType@GlobalParams@@QAEXH@Z ; GlobalParams::setPSEmbedTrueType

; 126  : 			globalParams->setPSEmbedType1(1);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	1
	call	?setPSEmbedType1@GlobalParams@@QAEXH@Z	; GlobalParams::setPSEmbedType1

; 127  : 			globalParams->setAntialias("yes");

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	OFFSET ??_C@_03ICICOMAL@yes?$AA@
	call	?setAntialias@GlobalParams@@QAEHPAD@Z	; GlobalParams::setAntialias

; 128  : 			globalParams->setVectorAntialias("yes");

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	OFFSET ??_C@_03ICICOMAL@yes?$AA@
	call	?setVectorAntialias@GlobalParams@@QAEHPAD@Z ; GlobalParams::setVectorAntialias

; 129  : 			globalParams->setTextEncoding("UTF-8");

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	OFFSET ??_C@_05EGJIMALK@UTF?98?$AA@
	call	?setTextEncoding@GlobalParams@@QAEXPAD@Z ; GlobalParams::setTextEncoding

; 130  : 
; 131  : 			InitGlobals();

	push	OFFSET ?gStreamMutex@@3U_RTL_CRITICAL_SECTION@@A ; gStreamMutex
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 132  : 			delete baseDir;

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@InitGlobal:

; 133  : 		}
; 134  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+288]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+280]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 280				; 00000118H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitGlobalParams@@YAXPAD@Z$0:
	mov	eax, DWORD PTR $T185242[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?InitGlobalParams@@YAXPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-272]
	mov	ecx, DWORD PTR [edx-276]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InitGlobalParams@@YAXPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitGlobalParams@@YAXPAD@Z ENDP			; InitGlobalParams
PUBLIC	?getProducer@AFPDFDoc@@QAEPA_WXZ		; AFPDFDoc::getProducer
; Function compile flags: /Ogtpy
;	COMDAT ?getProducer@AFPDFDoc@@QAEPA_WXZ
_TEXT	SEGMENT
_info$185972 = -24					; size = 24
?getProducer@AFPDFDoc@@QAEPA_WXZ PROC			; AFPDFDoc::getProducer, COMDAT
; _this$ = eax

; 2587 : 	wchar_t * AFPDFDoc::getProducer(){

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH

; 2588 : 		return ::getDocInfo("Producer",m_PDFDoc);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	esi
	mov	esi, DWORD PTR [eax+332]
	xor	eax, eax
	mov	DWORD PTR _info$185972[esp+32], eax
	mov	DWORD PTR _info$185972[esp+36], eax
	mov	DWORD PTR _info$185972[esp+40], 13	; 0000000dH
	call	?getTextEncoding@GlobalParams@@QAEPAVUnicodeMap@@XZ ; GlobalParams::getTextEncoding
	test	eax, eax
	je	SHORT $LN17@getProduce
	lea	ecx, DWORD PTR _info$185972[esp+32]
	push	ecx
	mov	ecx, DWORD PTR [esi+24]
	call	?getDocInfo@XRef@@QAEPAVObject@@PAV2@@Z	; XRef::getDocInfo
$LN17@getProduce:
	mov	eax, OFFSET _EmptyChar

; 2589 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?getProducer@AFPDFDoc@@QAEPA_WXZ ENDP			; AFPDFDoc::getProducer
_TEXT	ENDS
PUBLIC	?getCreator@AFPDFDoc@@QAEPA_WXZ			; AFPDFDoc::getCreator
; Function compile flags: /Ogtpy
;	COMDAT ?getCreator@AFPDFDoc@@QAEPA_WXZ
_TEXT	SEGMENT
_info$186010 = -24					; size = 24
?getCreator@AFPDFDoc@@QAEPA_WXZ PROC			; AFPDFDoc::getCreator, COMDAT
; _this$ = eax

; 2584 : 	wchar_t * AFPDFDoc::getCreator(){

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH

; 2585 : 		return ::getDocInfo("Creator",m_PDFDoc);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	esi
	mov	esi, DWORD PTR [eax+332]
	xor	eax, eax
	mov	DWORD PTR _info$186010[esp+32], eax
	mov	DWORD PTR _info$186010[esp+36], eax
	mov	DWORD PTR _info$186010[esp+40], 13	; 0000000dH
	call	?getTextEncoding@GlobalParams@@QAEPAVUnicodeMap@@XZ ; GlobalParams::getTextEncoding
	test	eax, eax
	je	SHORT $LN17@getCreator
	lea	ecx, DWORD PTR _info$186010[esp+32]
	push	ecx
	mov	ecx, DWORD PTR [esi+24]
	call	?getDocInfo@XRef@@QAEPAVObject@@PAV2@@Z	; XRef::getDocInfo
$LN17@getCreator:
	mov	eax, OFFSET _EmptyChar

; 2586 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?getCreator@AFPDFDoc@@QAEPA_WXZ ENDP			; AFPDFDoc::getCreator
_TEXT	ENDS
PUBLIC	?getKeywords@AFPDFDoc@@QAEPA_WXZ		; AFPDFDoc::getKeywords
; Function compile flags: /Ogtpy
;	COMDAT ?getKeywords@AFPDFDoc@@QAEPA_WXZ
_TEXT	SEGMENT
_info$186048 = -24					; size = 24
?getKeywords@AFPDFDoc@@QAEPA_WXZ PROC			; AFPDFDoc::getKeywords, COMDAT
; _this$ = eax

; 2581 : 	wchar_t * AFPDFDoc::getKeywords(){

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH

; 2582 : 		return ::getDocInfo("Keywords",m_PDFDoc);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	esi
	mov	esi, DWORD PTR [eax+332]
	xor	eax, eax
	mov	DWORD PTR _info$186048[esp+32], eax
	mov	DWORD PTR _info$186048[esp+36], eax
	mov	DWORD PTR _info$186048[esp+40], 13	; 0000000dH
	call	?getTextEncoding@GlobalParams@@QAEPAVUnicodeMap@@XZ ; GlobalParams::getTextEncoding
	test	eax, eax
	je	SHORT $LN17@getKeyword
	lea	ecx, DWORD PTR _info$186048[esp+32]
	push	ecx
	mov	ecx, DWORD PTR [esi+24]
	call	?getDocInfo@XRef@@QAEPAVObject@@PAV2@@Z	; XRef::getDocInfo
$LN17@getKeyword:
	mov	eax, OFFSET _EmptyChar

; 2583 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?getKeywords@AFPDFDoc@@QAEPA_WXZ ENDP			; AFPDFDoc::getKeywords
_TEXT	ENDS
PUBLIC	?getSubject@AFPDFDoc@@QAEPA_WXZ			; AFPDFDoc::getSubject
; Function compile flags: /Ogtpy
;	COMDAT ?getSubject@AFPDFDoc@@QAEPA_WXZ
_TEXT	SEGMENT
_info$186086 = -24					; size = 24
?getSubject@AFPDFDoc@@QAEPA_WXZ PROC			; AFPDFDoc::getSubject, COMDAT
; _this$ = eax

; 2578 : 	wchar_t * AFPDFDoc::getSubject(){

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH

; 2579 : 		return ::getDocInfo("Subject",m_PDFDoc);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	esi
	mov	esi, DWORD PTR [eax+332]
	xor	eax, eax
	mov	DWORD PTR _info$186086[esp+32], eax
	mov	DWORD PTR _info$186086[esp+36], eax
	mov	DWORD PTR _info$186086[esp+40], 13	; 0000000dH
	call	?getTextEncoding@GlobalParams@@QAEPAVUnicodeMap@@XZ ; GlobalParams::getTextEncoding
	test	eax, eax
	je	SHORT $LN17@getSubject
	lea	ecx, DWORD PTR _info$186086[esp+32]
	push	ecx
	mov	ecx, DWORD PTR [esi+24]
	call	?getDocInfo@XRef@@QAEPAVObject@@PAV2@@Z	; XRef::getDocInfo
$LN17@getSubject:
	mov	eax, OFFSET _EmptyChar

; 2580 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?getSubject@AFPDFDoc@@QAEPA_WXZ ENDP			; AFPDFDoc::getSubject
_TEXT	ENDS
PUBLIC	?getAuthor@AFPDFDoc@@QAEPA_WXZ			; AFPDFDoc::getAuthor
; Function compile flags: /Ogtpy
;	COMDAT ?getAuthor@AFPDFDoc@@QAEPA_WXZ
_TEXT	SEGMENT
_info$186124 = -24					; size = 24
?getAuthor@AFPDFDoc@@QAEPA_WXZ PROC			; AFPDFDoc::getAuthor, COMDAT
; _this$ = eax

; 2574 : 	wchar_t * AFPDFDoc::getAuthor(){

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH

; 2575 : 		return ::getDocInfo("Author",m_PDFDoc);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	esi
	mov	esi, DWORD PTR [eax+332]
	xor	eax, eax
	mov	DWORD PTR _info$186124[esp+32], eax
	mov	DWORD PTR _info$186124[esp+36], eax
	mov	DWORD PTR _info$186124[esp+40], 13	; 0000000dH
	call	?getTextEncoding@GlobalParams@@QAEPAVUnicodeMap@@XZ ; GlobalParams::getTextEncoding
	test	eax, eax
	je	SHORT $LN17@getAuthor
	lea	ecx, DWORD PTR _info$186124[esp+32]
	push	ecx
	mov	ecx, DWORD PTR [esi+24]
	call	?getDocInfo@XRef@@QAEPAVObject@@PAV2@@Z	; XRef::getDocInfo
$LN17@getAuthor:
	mov	eax, OFFSET _EmptyChar

; 2576 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?getAuthor@AFPDFDoc@@QAEPA_WXZ ENDP			; AFPDFDoc::getAuthor
_TEXT	ENDS
PUBLIC	?getTitle@AFPDFDoc@@QAEPA_WXZ			; AFPDFDoc::getTitle
; Function compile flags: /Ogtpy
;	COMDAT ?getTitle@AFPDFDoc@@QAEPA_WXZ
_TEXT	SEGMENT
_info$186162 = -24					; size = 24
?getTitle@AFPDFDoc@@QAEPA_WXZ PROC			; AFPDFDoc::getTitle, COMDAT
; _this$ = eax

; 2570 : 	wchar_t * AFPDFDoc::getTitle(){

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH

; 2571 : 		return ::getDocInfo("Title",m_PDFDoc);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	esi
	mov	esi, DWORD PTR [eax+332]
	xor	eax, eax
	mov	DWORD PTR _info$186162[esp+32], eax
	mov	DWORD PTR _info$186162[esp+36], eax
	mov	DWORD PTR _info$186162[esp+40], 13	; 0000000dH
	call	?getTextEncoding@GlobalParams@@QAEPAVUnicodeMap@@XZ ; GlobalParams::getTextEncoding
	test	eax, eax
	je	SHORT $LN17@getTitle
	lea	ecx, DWORD PTR _info$186162[esp+32]
	push	ecx
	mov	ecx, DWORD PTR [esi+24]
	call	?getDocInfo@XRef@@QAEPAVObject@@PAV2@@Z	; XRef::getDocInfo
$LN17@getTitle:
	mov	eax, OFFSET _EmptyChar

; 2572 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?getTitle@AFPDFDoc@@QAEPA_WXZ ENDP			; AFPDFDoc::getTitle
_TEXT	ENDS
PUBLIC	??0AFPDFDoc@@QAE@PAD@Z				; AFPDFDoc::AFPDFDoc
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\crect.h
xdata$x	SEGMENT
__unwindtable$??0AFPDFDoc@@QAE@PAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AFPDFDoc@@QAE@PAD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0AFPDFDoc@@QAE@PAD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0AFPDFDoc@@QAE@PAD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0AFPDFDoc@@QAE@PAD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0AFPDFDoc@@QAE@PAD@Z$4
__ehfuncinfo$??0AFPDFDoc@@QAE@PAD@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0AFPDFDoc@@QAE@PAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ??0AFPDFDoc@@QAE@PAD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T186193 = 12						; size = 4
_configFile$ = 12					; size = 4
??0AFPDFDoc@@QAE@PAD@Z PROC				; AFPDFDoc::AFPDFDoc, COMDAT

; 545  : 	{

	push	-1
	push	__ehhandler$??0AFPDFDoc@@QAE@PAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+24]
	xor	ebx, ebx
	lea	ecx, DWORD PTR [esi+228]
	mov	DWORD PTR [esi], OFFSET ??_7AFPDFDoc@@6B@
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+148], -1
	mov	BYTE PTR [esi+154], bl
	mov	DWORD PTR [esi+156], ebx
	mov	BYTE PTR [esi+168], bl
	mov	DWORD PTR [esi+172], ebx
	mov	DWORD PTR [esi+212], ebx
	mov	DWORD PTR [esi+220], ebx
	call	??0GString@@QAE@XZ			; GString::GString
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	lea	eax, DWORD PTR [esi+252]
	push	eax
	mov	DWORD PTR [esi+236], ebx
	mov	DWORD PTR [esi+240], ebx
	mov	DWORD PTR [esi+244], ebx
	mov	DWORD PTR [esi+248], ebx
	call	??0Queue@@QAE@I@Z			; Queue::Queue
	mov	BYTE PTR __$EHRec$[esp+36], 1
	push	3584					; 00000e00H
	mov	DWORD PTR [esi+328], 128		; 00000080H
	mov	DWORD PTR [esi+324], ebx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR [esi+320], eax
	cmp	eax, ebx
	jne	SHORT $LN11@AFPDFDoc@2
	push	OFFSET __TI1?AW4exception@?$DynArray@VCPDFSearchResult@@@@
	lea	ecx, DWORD PTR $T186193[esp+28]
	push	ecx
	mov	DWORD PTR $T186193[esp+32], ebx
	call	__CxxThrowException@8
$LN23@AFPDFDoc@2:
$LN11@AFPDFDoc@2:
	mov	BYTE PTR __$EHRec$[esp+36], 2
	lea	ecx, DWORD PTR [esi+356]
	mov	DWORD PTR [esi+332], ebx
	mov	DWORD PTR [esi+336], ebx
	mov	DWORD PTR [esi+344], ebx
	mov	DWORD PTR [esi+352], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+384]
	mov	BYTE PTR __$EHRec$[esp+36], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+36], 4
	fldz
	mov	DWORD PTR [esi+432], ebx
	mov	DWORD PTR [esi+428], ebx
	mov	DWORD PTR [esi+424], ebx
	mov	DWORD PTR [esi+416], ebx
	mov	DWORD PTR [esi+420], ebx
	mov	DWORD PTR [esi+412], ebx
	mov	DWORD PTR [esi+436], ebx
	mov	DWORD PTR [esi+440], ebx
	mov	DWORD PTR [esi+452], ebx
	mov	DWORD PTR [esi+456], ebx
	mov	DWORD PTR [esi+444], ebx
	mov	DWORD PTR [esi+448], ebx
	fst	QWORD PTR [esi+464]
	fstp	QWORD PTR [esi+472]

; 546  : 		
; 547  : 		// GMutex m;
; 548  : 		gInitMutex(&hgMutex);

	lea	edx, DWORD PTR [esi+188]
	fld	QWORD PTR __real@4052000000000000
	push	edx
	fst	QWORD PTR [esi+528]
	mov	DWORD PTR [esi+480], ebx
	fstp	QWORD PTR [esi+536]
	mov	DWORD PTR [esi+484], ebx
	mov	DWORD PTR [esi+488], ebx
	mov	DWORD PTR [esi+492], ebx
	mov	DWORD PTR [esi+496], ebx
	mov	DWORD PTR [esi+500], ebx
	mov	DWORD PTR [esi+504], 1
	mov	DWORD PTR [esi+516], ebx
	mov	DWORD PTR [esi+520], ebx
	mov	DWORD PTR [esi+524], ebx
	mov	BYTE PTR [esi+544], bl
	mov	BYTE PTR [esi+546], bl
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 549  : 
; 550  : 		//hgMutex = CreateMutex(NULL,FALSE,NULL);
; 551  : 		hRenderFinished = CreateEvent(NULL,TRUE,FALSE,TEXT("RenderFinishedEvent"));

	push	OFFSET ??_C@_0BE@ECCAOMPC@RenderFinishedEvent?$AA@
	push	ebx
	push	1
	push	ebx
	call	DWORD PTR __imp__CreateEventA@16
	mov	DWORD PTR [esi+176], eax
	lea	eax, DWORD PTR [esi+80]
	mov	ecx, 16					; 00000010H
$LL3@AFPDFDoc@2:

; 552  : 
; 553  : 		for(int i=0;i<MAX_BITMAP_CACHE;i++){
; 554  : 			_bitmapCache[i]=0;

	mov	DWORD PTR [eax-68], ebx

; 555  : 			_pageCached[i]=0;

	mov	DWORD PTR [eax], ebx
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LL3@AFPDFDoc@2

; 556  : 		}
; 557  : 
; 558  : 		InitGlobalParams(configFile);

	mov	edi, DWORD PTR _configFile$[esp+24]
	call	?InitGlobalParams@@YAXPAD@Z		; InitGlobalParams

; 559  : 		
; 560  : 		m_Bitmap=0;

	mov	DWORD PTR [esi+352], ebx

; 561  : 		m_PDFDoc=0;

	mov	DWORD PTR [esi+332], ebx

; 562  : 		m_splashOut=0;

	mov	DWORD PTR [esi+344], ebx

; 563  : 		m_Outline=0;

	mov	DWORD PTR [esi+348], ebx

; 564  : 		//Redirect
; 565  : #ifdef  _DEBUG
; 566  : 		freopen( "C:\\stderr.log", "w", stderr );
; 567  : #endif
; 568  : 	}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN22@AFPDFDoc@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AFPDFDoc@@QAE@PAD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 228				; 000000e4H
	jmp	??1GString@@QAE@XZ			; GString::~GString
__unwindfunclet$??0AFPDFDoc@@QAE@PAD@Z$1:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 252				; 000000fcH
	jmp	??1Queue@@QAE@XZ			; Queue::~Queue
__unwindfunclet$??0AFPDFDoc@@QAE@PAD@Z$2:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 320				; 00000140H
	jmp	??1?$DynArray@VCPDFSearchResult@@@@QAE@XZ ; DynArray<CPDFSearchResult>::~DynArray<CPDFSearchResult>
__unwindfunclet$??0AFPDFDoc@@QAE@PAD@Z$3:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 356				; 00000164H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??0AFPDFDoc@@QAE@PAD@Z$4:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 384				; 00000180H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0AFPDFDoc@@QAE@PAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AFPDFDoc@@QAE@PAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AFPDFDoc@@QAE@PAD@Z ENDP				; AFPDFDoc::AFPDFDoc
PUBLIC	?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z	; AFPDFDoc::findDest
;	COMDAT xdata$x
; File c:\projects\pdflibnet\xpdfwin\xpdf\pdfdoc.h
xdata$x	SEGMENT
__unwindtable$?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z$0
__ehfuncinfo$?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z
_TEXT	SEGMENT
_s$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_destName$ = 12						; size = 4
?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z PROC		; AFPDFDoc::findDest, COMDAT

; 3098 : 	LinkDest *AFPDFDoc::findDest(char *destName){

	push	-1
	push	__ehhandler$?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax

; 3099 : 		GString s(destName);

	mov	eax, DWORD PTR _destName$[esp+24]
	push	eax
	lea	ecx, DWORD PTR _s$[esp+32]
	call	??0GString@@QAE@PBD@Z			; GString::GString

; 3100 : 		return this->m_PDFDoc->getCatalog()->findDest(&s);

	mov	ecx, DWORD PTR _this$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	edx, DWORD PTR [ecx+332]
	mov	ecx, DWORD PTR [edx+28]
	lea	eax, DWORD PTR _s$[esp+28]
	push	eax
	call	?findDest@Catalog@@QAEPAVLinkDest@@PAVGString@@@Z ; Catalog::findDest
	lea	ecx, DWORD PTR _s$[esp+28]
	mov	esi, eax
	call	??1GString@@QAE@XZ			; GString::~GString
	mov	eax, esi

; 3101 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z$0:
	lea	ecx, DWORD PTR _s$[ebp]
	jmp	??1GString@@QAE@XZ			; GString::~GString
__ehhandler$?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?findDest@AFPDFDoc@@QAEPAVLinkDest@@PAD@Z ENDP		; AFPDFDoc::findDest
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\pdfdoc.h
;	COMDAT ?findDest@PDFDoc@@QAEPAVLinkDest@@PAVGString@@@Z
_TEXT	SEGMENT
?findDest@PDFDoc@@QAEPAVLinkDest@@PAVGString@@@Z PROC	; PDFDoc::findDest, COMDAT
; _this$ = ecx
; _name$ = eax

; 121  :     { return catalog->findDest(name); }

	mov	ecx, DWORD PTR [ecx+28]
	push	eax
	call	?findDest@Catalog@@QAEPAVLinkDest@@PAVGString@@@Z ; Catalog::findDest
	ret	0
?findDest@PDFDoc@@QAEPAVLinkDest@@PAVGString@@@Z ENDP	; PDFDoc::findDest
PUBLIC	?ProcessLinkAction@AFPDFDoc@@QAEJJ@Z		; AFPDFDoc::ProcessLinkAction
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
;	COMDAT ?ProcessLinkAction@AFPDFDoc@@QAEJJ@Z
_TEXT	SEGMENT
_dy$86397 = -64						; size = 4
_dx$86396 = -60						; size = 4
_uy$86410 = -56						; size = 8
_ctm$86412 = -48					; size = 48
?ProcessLinkAction@AFPDFDoc@@QAEJJ@Z PROC		; AFPDFDoc::ProcessLinkAction, COMDAT
; _this$ = edi
; _lPtrLinkAction$ = ebx

; 1962 : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 124				; 0000007cH
	push	esi

; 1963 : 		
; 1964 : 		LinkAction * link = (LinkAction *)lPtrLinkAction;
; 1965 : 		if (link == NULL)

	test	ebx, ebx

; 1966 : 			return 0;

	je	$LN12@ProcessLin

; 1967 : 		
; 1968 : 		if (link->getKind() == actionGoTo) {

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, ebx
	call	edx
	test	eax, eax
	jne	$LN12@ProcessLin

; 1969 : 			LinkGoTo * p = (LinkGoTo *)link;
; 1970 : 			LinkDest * dest;
; 1971 : 			GString  * namedDest;
; 1972 : 			int pageno;
; 1973 : 			int x = m_ViewOffsetX, y = m_ViewOffsetY;
; 1974 : 			int dx, dy;
; 1975 : 			dest = p->getDest();

	mov	esi, DWORD PTR [ebx+4]

; 1976 : 
; 1977 : 			if (dest == NULL) {

	test	esi, esi
	jne	SHORT $LN48@ProcessLin

; 1978 : 				if ((namedDest = p->getNamedDest()) == NULL)

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax

; 1979 : 					return 0;

	je	$LN12@ProcessLin

; 1980 : 
; 1981 : 				dest = m_PDFDoc->findDest(namedDest);

	mov	ecx, DWORD PTR [edi+332]
	mov	ecx, DWORD PTR [ecx+28]
	push	eax
	call	?findDest@Catalog@@QAEPAVLinkDest@@PAVGString@@@Z ; Catalog::findDest
	mov	esi, eax

; 1982 : 			}
; 1983 : 
; 1984 : 			if (dest == NULL || !dest->isOk())

	test	esi, esi
	je	$LN12@ProcessLin
$LN48@ProcessLin:
	cmp	DWORD PTR [esi+68], 0
	je	$LN12@ProcessLin

; 1985 : 				return 0;
; 1986 : 
; 1987 : 			if (dest->isPageRef()) {

	cmp	DWORD PTR [esi+4], 0

; 1988 : 				Ref ref = dest->getPageRef();

	mov	eax, DWORD PTR [esi+8]
	je	SHORT $LN30@ProcessLin
	mov	edx, DWORD PTR [esi+12]

; 1989 : 				pageno = m_PDFDoc->getCatalog()->findPage(ref.num, ref.gen);

	mov	ecx, DWORD PTR [edi+332]
	mov	ecx, DWORD PTR [ecx+28]
	push	edx
	push	eax
	call	?findPage@Catalog@@QAEHHH@Z		; Catalog::findPage

; 1990 : 			} else
; 1991 : 				pageno = dest->getPageNum();

$LN30@ProcessLin:

; 1992 : 
; 1993 : 			if (pageno <= 0 || pageno >= m_PDFDoc->getNumPages())

	test	eax, eax
	jle	$LN12@ProcessLin
	mov	edx, DWORD PTR [edi+332]
	mov	ecx, DWORD PTR [edx+28]
	cmp	eax, DWORD PTR [ecx+12]
	jge	$LN12@ProcessLin

; 1994 : 				return 0;
; 1995 : 
; 1996 : 			// go to the page 
; 1997 : 			if(pageno>=1 && pageno<=m_PDFDoc->getNumPages()){

	cmp	eax, 1
	jl	SHORT $LN3@ProcessLin

; 1998 : 				m_CurrentPage = pageno;

	mov	DWORD PTR [edi+504], eax
$LN3@ProcessLin:

; 1999 : 			}
; 2000 : /*
; 2001 : 			switch (dest->getKind()) {
; 2002 : 			case destXYZ:
; 2003 : 				{
; 2004 : 					m_splashOut->cvtUserToDev(dest->getLeft(),
; 2005 : 						dest->getTop(), &dx, &dy);
; 2006 : 
; 2007 : 					if (dest->getChangeLeft()) x = dx;
; 2008 : 					if (dest->getChangeTop())  y = dy;
; 2009 : 					// ignore zoom 
; 2010 : 				}
; 2011 : 				break;
; 2012 : 				// preserve user defined zoom factor, so do not fit 
; 2013 : 			case destFit:
; 2014 : 			case destFitB:
; 2015 : 				x = y = 0;
; 2016 : 				break;
; 2017 : 			case destFitH:
; 2018 : 			case destFitBH:
; 2019 : 				//~ do fit
; 2020 : 				m_splashOut->cvtUserToDev(0, dest->getTop(), &dx, &dy);
; 2021 : 				x = 0;
; 2022 : 				y = dy;
; 2023 : 				break;
; 2024 : 			case destFitV:
; 2025 : 			case destFitBV:
; 2026 : 				//~ do fit
; 2027 : 				m_splashOut->cvtUserToDev(dest->getLeft(), 0, &dx, &dy);
; 2028 : 				x = dx;
; 2029 : 				y = 0;
; 2030 : 				break;
; 2031 : 			case destFitR:
; 2032 : 				//~ do fit
; 2033 : 				m_splashOut->cvtUserToDev(dest->getLeft(), dest->getTop(), &dx, &dy);
; 2034 : 				x = dx;
; 2035 : 				y = dy;
; 2036 : 				break;
; 2037 : 			}*/
; 2038 : 			
; 2039 : 			
; 2040 : 			if(m_splashOut==NULL){

	mov	ecx, DWORD PTR [edi+344]

; 2041 : 				double uy = dest->getTop();

	fld	QWORD PTR [esi+40]
	test	ecx, ecx
	jne	SHORT $LN2@ProcessLin

; 2042 : 				Page *p =this->m_PDFDoc->getCatalog()->getPage(this->m_CurrentPage);
; 2043 : 				double ctm[6];
; 2044 : 				p->getDefaultCTM(ctm,this->m_renderDPI,m_renderDPI,m_Rotation,gTrue,gFalse);

	mov	eax, DWORD PTR [edi+524]
	fstp	QWORD PTR _uy$86410[esp+128]
	fld	QWORD PTR [edi+536]
	push	ecx
	push	1
	push	eax
	mov	eax, DWORD PTR [edi+504]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	lea	ecx, DWORD PTR _ctm$86412[esp+156]
	fld	QWORD PTR [edi+536]
	fstp	QWORD PTR [esp]
	push	ecx
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4-4]
	call	?getDefaultCTM@Page@@QAEXPANNNHHH@Z	; Page::getDefaultCTM

; 2045 : 				dx = (int)(/*ctm[0] * ux + */ctm[2] * uy + ctm[4] + 0.5);
; 2046 : 				dy = (int)(/*ctm[1] * ux + */ctm[3] * uy + ctm[5] + 0.5);

	fld	QWORD PTR _ctm$86412[esp+152]
	fmul	QWORD PTR _uy$86410[esp+128]
	fadd	QWORD PTR _ctm$86412[esp+168]
	fadd	QWORD PTR __real@3fe0000000000000
	call	__ftol2_sse

; 2054 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@ProcessLin:

; 2047 : 
; 2048 : 			}else{
; 2049 : 				m_splashOut->cvtUserToDev(0, dest->getTop(), &dx, &dy);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	lea	edx, DWORD PTR _dy$86397[esp+128]
	push	edx
	lea	edx, DWORD PTR _dx$86396[esp+132]
	push	edx
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fldz
	fstp	QWORD PTR [esp]
	call	eax
	mov	eax, DWORD PTR _dy$86397[esp+128]

; 2054 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@ProcessLin:

; 2050 : 			}
; 2051 : 			return (long)dy;
; 2052 : 		}
; 2053 : 		return 0;

	xor	eax, eax

; 2054 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessLinkAction@AFPDFDoc@@QAEJJ@Z ENDP		; AFPDFDoc::ProcessLinkAction
PUBLIC	?GetLinksPage@AFPDFDoc@@QAEPAVLinks@@J@Z	; AFPDFDoc::GetLinksPage
; Function compile flags: /Ogtpy
;	COMDAT ?GetLinksPage@AFPDFDoc@@QAEPAVLinks@@J@Z
_TEXT	SEGMENT
?GetLinksPage@AFPDFDoc@@QAEPAVLinks@@J@Z PROC		; AFPDFDoc::GetLinksPage, COMDAT
; _this$ = eax
; _iPage$ = edx

; 2615 : 		Catalog *c = m_PDFDoc->getCatalog();

	mov	ecx, DWORD PTR [eax+332]

; 2616 : 		if(c){

	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN1@GetLinksPa

; 2617 : 			Links *l=m_PDFDoc->getLinks(iPage);

	push	edx
	call	?getLinks@PDFDoc@@QAEPAVLinks@@H@Z	; PDFDoc::getLinks

; 2621 : 	}

	ret	0
$LN1@GetLinksPa:

; 2618 : 			return l;
; 2619 : 		}
; 2620 : 		return 0;

	xor	eax, eax

; 2621 : 	}

	ret	0
?GetLinksPage@AFPDFDoc@@QAEPAVLinks@@J@Z ENDP		; AFPDFDoc::GetLinksPage
_TEXT	ENDS
PUBLIC	?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z	; AFPDFDoc::LoadFromStream
;	COMDAT xdata$x
; File c:\projects\pdflibnet\xpdfwin\xpdf\pdfdoc.h
xdata$x	SEGMENT
__unwindtable$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z$4
__ehfuncinfo$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z
_TEXT	SEGMENT
$T189079 = -56						; size = 4
_exitcode$85758 = -52					; size = 4
$T189092 = -48						; size = 4
$T189084 = -48						; size = 4
$T189098 = -44						; size = 4
$T189094 = -44						; size = 4
_obj$ = -40						; size = 24
__$EHRec$ = -12						; size = 12
_callback$ = 8						; size = 4
_fullLenght$ = 12					; size = 4
?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z PROC		; AFPDFDoc::LoadFromStream, COMDAT
; _this$ = ebx

; 699  : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, eax

; 700  : 		
; 701  : 		//Wait for previous threads and delete them
; 702  : 		if (m_renderingThread!=0)

	mov	eax, DWORD PTR [ebx+240]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN16@LoadFromSt

; 703  : 		{					
; 704  : 			DWORD exitcode=0;
; 705  : 			GetExitCodeThread(m_renderingThread,&exitcode);

	lea	ecx, DWORD PTR _exitcode$85758[esp+68]
	push	ecx
	push	eax
	mov	DWORD PTR _exitcode$85758[esp+76], edi
	call	DWORD PTR __imp__GetExitCodeThread@8

; 706  : 			if(exitcode==STILL_ACTIVE){

	cmp	DWORD PTR _exitcode$85758[esp+68], 259	; 00000103H
	jne	SHORT $LN15@LoadFromSt

; 707  : 				::InterlockedExchange(&this->g_lLocker,1);

	push	1
	lea	edx, DWORD PTR [ebx+164]
	push	edx
	call	DWORD PTR __imp__InterlockedExchange@8

; 708  : 				WaitForSingleObject(this->hRenderFinished,INFINITE);

	mov	eax, DWORD PTR [ebx+176]
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN15@LoadFromSt:

; 709  : 			}
; 710  : 			CloseHandle(m_renderingThread);

	mov	ecx, DWORD PTR [ebx+240]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 711  : 			m_renderingThread=NULL;

	mov	DWORD PTR [ebx+240], edi
$LN16@LoadFromSt:

; 712  : 		}
; 713  : 
; 714  : 		InvalidateBitmapCache();

	mov	eax, ebx
	call	?InvalidateBitmapCache@AFPDFDoc@@AAEXXZ	; AFPDFDoc::InvalidateBitmapCache

; 715  : 		if(user_password!=NULL)
; 716  : 			m_UserPassword = user_password;
; 717  : 		if(owner_password!=NULL)
; 718  : 			m_OwnerPassword = owner_password;
; 719  : 		//Si la existia lo eliminamos
; 720  : 		if (m_splashOut!=NULL){

	mov	esi, DWORD PTR [ebx+344]
	cmp	esi, edi
	je	SHORT $LN12@LoadFromSt

; 721  : 			delete m_splashOut;

	call	??_GAuxOutputDev@@QAEPAXI@Z

; 722  : 			m_splashOut=0;

	mov	DWORD PTR [ebx+344], edi
$LN12@LoadFromSt:

; 723  : 		}
; 724  : 		//Close the stream
; 725  : 		if(m_LastOpenedStream)

	mov	ecx, DWORD PTR [ebx+236]
	cmp	ecx, edi
	je	SHORT $LN11@LoadFromSt

; 726  : 		{
; 727  : 			m_LastOpenedStream->close();

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 728  : 			m_LastOpenedStream=0;

	mov	DWORD PTR [ebx+236], edi
$LN11@LoadFromSt:

; 729  : 		}
; 730  : 		//Si ya existia la eliminamos
; 731  : 		if (m_PDFDoc!=0){

	mov	esi, DWORD PTR [ebx+332]
	cmp	esi, edi
	je	SHORT $LN10@LoadFromSt

; 732  : 			delete m_PDFDoc;

	mov	ecx, esi
	call	??1PDFDoc@@QAE@XZ			; PDFDoc::~PDFDoc
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 733  : 			m_PDFDoc=0;

	mov	DWORD PTR [ebx+332], edi
$LN10@LoadFromSt:

; 734  : 		}
; 735  : 
; 736  : 		//Intentamos abrir el documento sin clave		
; 737  : 		Object obj;
; 738  : 		obj.initNull();
; 739  : 		StreamCallback *str = new StreamCallback((READFROMSTREAM)callback,fullLenght,0,gFalse,0,&obj);

	push	8272					; 00002050H
	mov	DWORD PTR _obj$[esp+72], edi
	mov	DWORD PTR _obj$[esp+76], edi
	mov	DWORD PTR _obj$[esp+80], 5
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	cmp	esi, edi
	je	SHORT $LN23@LoadFromSt
	mov	ecx, DWORD PTR _fullLenght$[ebp]
	mov	edx, DWORD PTR _callback$[ebp]
	push	edi
	push	edi
	push	ecx
	push	edx
	lea	eax, DWORD PTR _obj$[esp+84]
	xor	edi, edi
	call	??0StreamCallback@@QAE@P6GXPAEHHH@ZJIHIPAVObject@@@Z ; StreamCallback::StreamCallback
	mov	esi, eax
	mov	DWORD PTR $T189079[esp+68], esi
	jmp	SHORT $LN24@LoadFromSt
$LN23@LoadFromSt:
	mov	DWORD PTR $T189079[esp+68], edi
	mov	esi, edi
$LN24@LoadFromSt:

; 740  : 		m_PDFDoc = new PDFDoc(str); //,new GString(user_password),new GString(owner_password));

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T189084[esp+68], eax
	mov	DWORD PTR __$EHRec$[esp+76], edi
	cmp	eax, edi
	je	SHORT $LN25@LoadFromSt
	push	edi
	push	edi
	push	edi
	push	esi
	mov	ecx, eax
	call	??0PDFDoc@@QAE@PAVBaseStream@@PAVGString@@1PAX@Z ; PDFDoc::PDFDoc
	jmp	SHORT $LN26@LoadFromSt
$LN25@LoadFromSt:
	xor	eax, eax
$LN26@LoadFromSt:
	mov	DWORD PTR __$EHRec$[esp+76], -1
	mov	DWORD PTR [ebx+332], eax

; 741  : 		m_LastOpenedStream=str;

	mov	DWORD PTR [ebx+236], esi

; 742  : 		/*
; 743  : 		if (m_PDFDoc->isOk()) {
; 744  : 		   Catalog *cat = m_PDFDoc->getCatalog();
; 745  : 		   int pages = cat->getNumPages();
; 746  : 		   for (int i = 1; i<= pages; i++)
; 747  : 		   {
; 748  : 			  Page *page = cat->getPage(i);
; 749  : 			  Object obj;              
; 750  : 			  Object *annots = page->getAnnots(&obj);    
; 751  : 			  Annots *annots1 = new Annots(m_PDFDoc->getXRef(), cat, annots); // Here annots1 is always 000000
; 752  : 			  obj.free();
; 753  : 			  int numanots = annots1->getNumAnnots();
; 754  : 		   }
; 755  : 		}*/
; 756  : 		//Esperamos a que se carge correctamente, o que ocurra un error
; 757  : 		while (!m_PDFDoc->isOk()) 

	cmp	DWORD PTR [eax+36], edi
	jne	$LN8@LoadFromSt
	npad	3
$LL9@LoadFromSt:

; 758  : 		{
; 759  : 			//En caso de que este encriptado con clave
; 760  : 			if (m_PDFDoc->getErrorCode() == errEncrypted)

	mov	eax, DWORD PTR [ebx+332]
	cmp	DWORD PTR [eax+40], 4
	jne	$LN5@LoadFromSt

; 761  : 			{
; 762  : 				//Si no se especifico clave salimos
; 763  : 				if(m_OwnerPassword.size()<=0 && m_UserPassword.size()<=0) {

	mov	eax, DWORD PTR [ebx+376]
	cmp	eax, edi
	ja	SHORT $LN6@LoadFromSt
	cmp	DWORD PTR [ebx+404], edi
	jbe	$LN86@LoadFromSt
$LN6@LoadFromSt:

; 767  : 				}else{
; 768  : 					//Si no se especifico una de las claves, usamos la misma para ambos
; 769  : 					if(m_UserPassword.size()<=0){

	cmp	DWORD PTR [ebx+404], edi
	ja	SHORT $LN4@LoadFromSt

; 770  : 						m_UserPassword=m_OwnerPassword;

	lea	ecx, DWORD PTR [ebx+356]
	push	ecx
	lea	ecx, DWORD PTR [ebx+384]
	jmp	SHORT $LN91@LoadFromSt
$LN4@LoadFromSt:

; 771  : 					}else if(m_OwnerPassword.size()<=0){

	cmp	eax, edi
	ja	SHORT $LN2@LoadFromSt

; 772  : 						m_OwnerPassword = m_UserPassword;

	lea	edx, DWORD PTR [ebx+384]
	push	edx
	lea	ecx, DWORD PTR [ebx+356]
$LN91@LoadFromSt:
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN2@LoadFromSt:

; 773  : 					}				
; 774  : 					//Intentamos abrir con clave
; 775  : 					m_PDFDoc = new PDFDoc(str, 
; 776  : 							new GString(const_cast<char*>(m_OwnerPassword.c_str())), 
; 777  : 							new GString(const_cast<char*>(m_UserPassword.c_str())));

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T189092[esp+68], edi
	mov	DWORD PTR __$EHRec$[esp+76], 1
	test	edi, edi
	je	$LN33@LoadFromSt
	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T189094[esp+68], eax
	mov	BYTE PTR __$EHRec$[esp+76], 2
	test	eax, eax
	je	SHORT $LN29@LoadFromSt
	cmp	DWORD PTR [ebx+408], 16			; 00000010H
	jb	SHORT $LN68@LoadFromSt
	mov	ecx, DWORD PTR [ebx+388]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	mov	esi, eax
	jmp	SHORT $LN30@LoadFromSt
$LN68@LoadFromSt:
	lea	ecx, DWORD PTR [ebx+388]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	mov	esi, eax
	jmp	SHORT $LN30@LoadFromSt
$LN29@LoadFromSt:
	xor	esi, esi
$LN30@LoadFromSt:
	push	8
	mov	BYTE PTR __$EHRec$[esp+80], 1
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T189098[esp+68], eax
	mov	BYTE PTR __$EHRec$[esp+76], 3
	test	eax, eax
	je	SHORT $LN31@LoadFromSt
	cmp	DWORD PTR [ebx+380], 16			; 00000010H
	jb	SHORT $LN74@LoadFromSt
	mov	ecx, DWORD PTR [ebx+360]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	jmp	SHORT $LN32@LoadFromSt
$LN74@LoadFromSt:
	lea	ecx, DWORD PTR [ebx+360]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	jmp	SHORT $LN32@LoadFromSt
$LN31@LoadFromSt:
	xor	eax, eax
$LN32@LoadFromSt:
	push	0
	push	esi
	push	eax
	mov	eax, DWORD PTR $T189079[esp+80]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+92], 1
	call	??0PDFDoc@@QAE@PAVBaseStream@@PAVGString@@1PAX@Z ; PDFDoc::PDFDoc
	jmp	SHORT $LN34@LoadFromSt
$LN33@LoadFromSt:
	xor	eax, eax
$LN34@LoadFromSt:
	mov	DWORD PTR __$EHRec$[esp+76], -1
	mov	DWORD PTR [ebx+332], eax
	xor	edi, edi
$LN5@LoadFromSt:

; 778  : #ifdef PDFLIBNET_ORIGINAL
; 779  : 					m_OwnerPassword.ReleaseBuffer();
; 780  : 					m_UserPassword.ReleaseBuffer();
; 781  : #endif
; 782  : 				}
; 783  : 			} 
; 784  : 			if (!m_PDFDoc->isOk())

	mov	ecx, DWORD PTR [ebx+332]
	cmp	DWORD PTR [ecx+36], edi
	je	$LN87@LoadFromSt
	mov	edx, ecx
	cmp	DWORD PTR [edx+36], edi
	je	$LL9@LoadFromSt
$LN8@LoadFromSt:

; 792  : 			}
; 793  : 			
; 794  : 		}
; 795  : 		m_LastOpenedFile.clear(); //No se especifico nombre dearchivo, habra que usar el metodo MakeSubstream del stream para el momento de exportar jpgs

	lea	ecx, DWORD PTR [ebx+228]
	call	?clear@GString@@QAEPAV1@XZ		; GString::clear

; 796  : //		m_LastOpenedFile.insert((int)0,FileName,strlen(FileName));
; 797  : 		//El archivo se cargo correctamente
; 798  : 		m_Outline = m_PDFDoc->getOutline();

	mov	ecx, DWORD PTR [ebx+332]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [ebx+348], edx

; 799  : 
; 800  : 		m_LastPageRendered = -1;

	mov	DWORD PTR [ebx+508], -1

; 801  : 		m_CurrentPage = 0;

	mov	DWORD PTR [ebx+504], edi

; 802  : 		m_SearchPage = 0;

	mov	DWORD PTR [ebx+512], edi

; 803  : 		
; 804  : 		return S_OK;

	xor	eax, eax

; 805  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
$LN86@LoadFromSt:

; 764  : 					delete m_PDFDoc;

	mov	esi, DWORD PTR [ebx+332]
	cmp	esi, edi
	je	SHORT $LN27@LoadFromSt
	mov	ecx, esi
	call	??1PDFDoc@@QAE@XZ			; PDFDoc::~PDFDoc
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@LoadFromSt:

; 765  : 					m_PDFDoc=NULL;

	mov	DWORD PTR [ebx+332], edi

; 766  : 					return errEncrypted;

	mov	eax, 4

; 805  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
$LN87@LoadFromSt:

; 785  : 			{
; 786  : 				//En caso de error, regresamos el codigo de error
; 787  : 				int errCode = m_PDFDoc->getErrorCode();

	mov	eax, ecx
	mov	esi, DWORD PTR [eax+40]

; 788  : 				fprintf(stderr,"Error File (%d)",errCode);

	push	esi
	push	OFFSET ??_C@_0BA@NCBBEIAC@Error?5File?5?$CI?$CFd?$CJ?$AA@
	call	DWORD PTR __imp____iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf

; 789  : 				delete m_PDFDoc;

	mov	edi, DWORD PTR [ebx+332]
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN35@LoadFromSt
	mov	ecx, edi
	call	??1PDFDoc@@QAE@XZ			; PDFDoc::~PDFDoc
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@LoadFromSt:

; 790  : 				m_PDFDoc=NULL;

	mov	DWORD PTR [ebx+332], 0

; 791  : 				return errCode;

	mov	eax, esi

; 805  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z$1:
	mov	eax, DWORD PTR $T189084[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z$2:
	mov	eax, DWORD PTR $T189092[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z$3:
	mov	eax, DWORD PTR $T189094[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z$4:
	mov	eax, DWORD PTR $T189098[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-52]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadFromStream@AFPDFDoc@@QAEJPAXJPAD1@Z ENDP		; AFPDFDoc::LoadFromStream
PUBLIC	?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z	; AFPDFDoc::createDoc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$6
__ehfuncinfo$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z
_TEXT	SEGMENT
$T189236 = -52						; size = 4
$T189232 = -52						; size = 4
$T189228 = -52						; size = 4
$T189214 = -52						; size = 4
$T189210 = -52						; size = 4
$T189226 = -48						; size = 4
$T189216 = -48						; size = 4
_obj$85702 = -44					; size = 24
__$EHRec$ = -12						; size = 12
_FileName$ = 8						; size = 4
_this$ = 8						; size = 4
?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z PROC		; AFPDFDoc::createDoc, COMDAT

; 645  : 	PDFDoc *AFPDFDoc::createDoc(char *FileName){

	push	-1
	push	__ehhandler$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _this$[esp+68]

; 646  : 		PDFDoc *pdfDoc;
; 647  : 		if(FileName==NULL)
; 648  : 			FileName=m_LastOpenedFile.getCString();
; 649  : 		//Intentamos abrir el documento sin clave
; 650  : 		if(m_LastOpenedFile.getLength()==0 && this->m_LastOpenedStream!=0){

	mov	eax, DWORD PTR [ebp+228]
	mov	edi, DWORD PTR [ebp+232]
	xor	ecx, ecx
	mov	DWORD PTR _FileName$[esp+68], edi
	cmp	eax, ecx
	jne	SHORT $LN11@createDoc
	cmp	DWORD PTR [ebp+236], ecx
	je	SHORT $LN11@createDoc

; 651  : 			Object obj;
; 652  : 			obj.initNull();
; 653  : 			pdfDoc = new PDFDoc((BaseStream *)m_LastOpenedStream->makeSubStream(0,0,((StreamCallback *)m_LastOpenedStream)->getLength(),&obj));

	push	48					; 00000030H
	mov	DWORD PTR _obj$85702[esp+76], ecx
	mov	DWORD PTR _obj$85702[esp+80], ecx
	mov	DWORD PTR _obj$85702[esp+84], 5
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T189210[esp+72], edi
	mov	DWORD PTR __$EHRec$[esp+80], 0
	test	edi, edi
	je	$LN19@createDoc
	mov	eax, DWORD PTR [ebp+236]
	mov	esi, DWORD PTR [eax]
	push	0
	push	0
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	push	0
	lea	edx, DWORD PTR _obj$85702[esp+84]
	push	edx
	mov	edx, DWORD PTR [eax+88]
	add	esi, 72					; 00000048H
	call	edx
	mov	ecx, DWORD PTR [ebp+236]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	0
	push	0
	call	eax
	push	eax
	mov	ecx, edi
	call	??0PDFDoc@@QAE@PAVBaseStream@@PAVGString@@1PAX@Z ; PDFDoc::PDFDoc
	jmp	SHORT $LN20@createDoc
$LN11@createDoc:

; 654  : 		}
; 655  : 		else
; 656  : 			pdfDoc = new PDFDoc(new GString(FileName), NULL,NULL);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T189214[esp+72], esi
	mov	ebx, 1
	mov	DWORD PTR __$EHRec$[esp+80], ebx
	test	esi, esi
	je	SHORT $LN19@createDoc
	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T189216[esp+72], eax
	mov	BYTE PTR __$EHRec$[esp+80], 2
	test	eax, eax
	je	SHORT $LN17@createDoc
	push	edi
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	jmp	SHORT $LN18@createDoc
$LN17@createDoc:
	xor	eax, eax
$LN18@createDoc:
	push	0
	push	0
	push	0
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+96], bl
	call	??0PDFDoc@@QAE@PAVGString@@00PAX@Z	; PDFDoc::PDFDoc
	jmp	SHORT $LN20@createDoc
$LN19@createDoc:
	xor	eax, eax
$LN20@createDoc:
	mov	esi, eax
	mov	DWORD PTR __$EHRec$[esp+80], -1

; 657  : 
; 658  : 		//Esperamos a que se carge correctamente, o que ocurra un error
; 659  : 		while (!pdfDoc->isOk()) 

	cmp	DWORD PTR [esi+36], 0
	jne	$LN81@createDoc
	npad	5
$LL9@createDoc:

; 660  : 		{
; 661  : 			//En caso de que este encriptado con clave
; 662  : 			if (pdfDoc->getErrorCode() == errEncrypted)

	cmp	DWORD PTR [esi+40], 4
	jne	$LN5@createDoc

; 663  : 			{
; 664  : 				//Si no se especifico clave salimos
; 665  : 				if(m_OwnerPassword.size()<=0 && m_UserPassword.size()<=0) {

	mov	eax, DWORD PTR [ebp+376]
	test	eax, eax
	ja	SHORT $LN6@createDoc
	cmp	DWORD PTR [ebp+404], 0
	ja	SHORT $LN4@createDoc

; 666  : 					delete pdfDoc;

	mov	ecx, esi
	call	??1PDFDoc@@QAE@XZ			; PDFDoc::~PDFDoc
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 667  : 					pdfDoc=NULL;

	xor	esi, esi

; 668  : 				}else{

	jmp	$LN5@createDoc
$LN6@createDoc:

; 669  : 					//Si no se especifico una de las claves, usamos la misma para ambos
; 670  : 					if(m_UserPassword.size()<=0){

	cmp	DWORD PTR [ebp+404], 0
	ja	SHORT $LN4@createDoc

; 671  : 						m_UserPassword=m_OwnerPassword;

	lea	ecx, DWORD PTR [ebp+356]
	push	ecx
	lea	ecx, DWORD PTR [ebp+384]
	jmp	SHORT $LN84@createDoc
$LN4@createDoc:

; 672  : 					}else if(m_OwnerPassword.size()<=0){

	test	eax, eax
	ja	SHORT $LN2@createDoc

; 673  : 						m_OwnerPassword = m_UserPassword;

	lea	edx, DWORD PTR [ebp+384]
	push	edx
	lea	ecx, DWORD PTR [ebp+356]
$LN84@createDoc:
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN2@createDoc:

; 674  : 					}				
; 675  : 					//Intentamos abrir con clave
; 676  : 					pdfDoc = new PDFDoc(new GString(FileName), 
; 677  : 							new GString(const_cast<char*>(m_OwnerPassword.c_str())), 
; 678  : 							new GString(const_cast<char*>(m_UserPassword.c_str())));

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T189226[esp+72], ebx
	mov	DWORD PTR __$EHRec$[esp+80], 3
	test	ebx, ebx
	je	$LN29@createDoc
	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T189228[esp+72], eax
	mov	BYTE PTR __$EHRec$[esp+80], 4
	test	eax, eax
	je	SHORT $LN23@createDoc
	cmp	DWORD PTR [ebp+408], 16			; 00000010H
	jb	SHORT $LN67@createDoc
	mov	ecx, DWORD PTR [ebp+388]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	mov	edi, eax
	jmp	SHORT $LN24@createDoc
$LN67@createDoc:
	lea	ecx, DWORD PTR [ebp+388]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	mov	edi, eax
	jmp	SHORT $LN24@createDoc
$LN23@createDoc:
	xor	edi, edi
$LN24@createDoc:
	push	8
	mov	BYTE PTR __$EHRec$[esp+84], 3
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T189232[esp+72], eax
	mov	BYTE PTR __$EHRec$[esp+80], 5
	test	eax, eax
	je	SHORT $LN25@createDoc
	cmp	DWORD PTR [ebp+380], 16			; 00000010H
	jb	SHORT $LN73@createDoc
	mov	ecx, DWORD PTR [ebp+360]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	mov	esi, eax
	jmp	SHORT $LN26@createDoc
$LN73@createDoc:
	lea	ecx, DWORD PTR [ebp+360]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	mov	esi, eax
	jmp	SHORT $LN26@createDoc
$LN25@createDoc:
	xor	esi, esi
$LN26@createDoc:
	push	8
	mov	BYTE PTR __$EHRec$[esp+84], 3
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T189236[esp+72], eax
	mov	BYTE PTR __$EHRec$[esp+80], 6
	test	eax, eax
	je	SHORT $LN27@createDoc
	mov	ecx, DWORD PTR _FileName$[esp+68]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	jmp	SHORT $LN28@createDoc
$LN27@createDoc:
	xor	eax, eax
$LN28@createDoc:
	push	0
	push	edi
	push	esi
	push	eax
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+96], 3
	call	??0PDFDoc@@QAE@PAVGString@@00PAX@Z	; PDFDoc::PDFDoc
	jmp	SHORT $LN30@createDoc
$LN29@createDoc:
	xor	eax, eax
$LN30@createDoc:
	mov	DWORD PTR __$EHRec$[esp+80], -1
	mov	esi, eax
$LN5@createDoc:

; 679  : #ifdef PDFLIBNET_ORIGINAL
; 680  : 					m_OwnerPassword.ReleaseBuffer();
; 681  : 					m_UserPassword.ReleaseBuffer();
; 682  : #endif
; 683  : 				}
; 684  : 			} 
; 685  : 			if (!pdfDoc->isOk())

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN81@createDoc

; 686  : 			{
; 687  : 				//En caso de error, regresamos NULL
; 688  : 				delete pdfDoc;

	mov	ecx, esi
	call	??1PDFDoc@@QAE@XZ			; PDFDoc::~PDFDoc
	push	esi
	call	??3@YAXPAX@Z				; operator delete

; 689  : 				pdfDoc=NULL;

	xor	esi, esi
	add	esp, 4
	cmp	DWORD PTR [esi+36], esi
	je	$LL9@createDoc
$LN81@createDoc:

; 690  : 				//return PDFDoc->getErrorCode();
; 691  : 			}
; 692  : 			
; 693  : 		}
; 694  : 
; 695  : 		return pdfDoc;

	mov	eax, esi

; 696  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 52					; 00000034H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$0:
	mov	eax, DWORD PTR $T189210[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$1:
	mov	eax, DWORD PTR $T189214[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$2:
	mov	eax, DWORD PTR $T189216[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$3:
	mov	eax, DWORD PTR $T189226[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$4:
	mov	eax, DWORD PTR $T189228[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$5:
	mov	eax, DWORD PTR $T189232[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z$6:
	mov	eax, DWORD PTR $T189236[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-56]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z ENDP		; AFPDFDoc::createDoc
PUBLIC	?RenderThreadFinished@AFPDFDoc@@AAEHPAVAuxOutputDev@@H_N@Z ; AFPDFDoc::RenderThreadFinished
; Function compile flags: /Ogtpy
;	COMDAT ?RenderThreadFinished@AFPDFDoc@@AAEHPAVAuxOutputDev@@H_N@Z
_TEXT	SEGMENT
_byThread$ = -21					; size = 1
_box_right$85953 = -20					; size = 4
_bmHeight$ = -20					; size = 4
_box_top$85952 = -16					; size = 4
_bmWidth$ = -16						; size = 4
_box_bottom$85954 = -12					; size = 4
_clientDC$ = -12					; size = 4
_box_left$85951 = -8					; size = 4
_bmpMem$ = -8						; size = 4
tv591 = -4						; size = 4
_this$ = 8						; size = 4
_out$ = 12						; size = 4
_page$ = 16						; size = 4
?RenderThreadFinished@AFPDFDoc@@AAEHPAVAuxOutputDev@@H_N@Z PROC ; AFPDFDoc::RenderThreadFinished, COMDAT

; 991  : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi

; 992  : 		//The process was cancelled!
; 993  : 		if(::InterlockedExchange(&this->g_lLocker,0)!=0)

	mov	edi, DWORD PTR _this$[ebp]
	xor	ebx, ebx
	push	ebx
	lea	eax, DWORD PTR [edi+164]
	push	eax
	call	DWORD PTR __imp__InterlockedExchange@8
	test	eax, eax

; 994  : 		{
; 995  : 			SetEvent(this->hRenderFinished);
; 996  : 			return 0;

	jne	$LN74@RenderThre

; 997  : 		}
; 998  : 		bool byThread=m_PageRenderedByThread;

	mov	dl, BYTE PTR [edi+168]

; 999  : 		m_PageRenderedByThread=false;
; 1000 : 
; 1001 : 		//Rendered bitmap by xpdf
; 1002 : 		//SplashBitmap * bitmap = out->getBitmap();
; 1003 : 		int bmWidth = (int)out->GetWidth();

	mov	esi, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edi+168], bl
	fld	QWORD PTR [esi+24]
	mov	BYTE PTR _byThread$[esp+64], dl
	call	__ftol2_sse

; 1004 : 		int bmHeight = (int)out->GetHeight();

	fld	QWORD PTR [esi+32]
	mov	DWORD PTR _bmWidth$[esp+64], eax
	call	__ftol2_sse

; 1005 : 		
; 1006 : 
; 1007 : 		HDC clientDC;
; 1008 : 		clientDC = GetWindowDC(NULL);

	push	ebx
	mov	DWORD PTR _bmHeight$[esp+68], eax
	call	DWORD PTR __imp__GetWindowDC@4
	lea	ecx, DWORD PTR [edi+80]
	mov	DWORD PTR _clientDC$[esp+64], eax

; 1009 : 
; 1010 : 		//Get from cache
; 1011 : 		PageMemory *bmpMem = this->GetBitmapCache(page);

	xor	eax, eax
	mov	DWORD PTR tv591[esp+64], ecx
$LL34@RenderThre:
	mov	edx, DWORD PTR _page$[ebp]
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN69@RenderThre
	inc	eax
	add	ecx, 4
	cmp	eax, 16					; 00000010H
	jl	SHORT $LL34@RenderThre

; 1038 : 		}
; 1039 : 		bool newThreadRunned=false;
; 1040 : 		//prerender next page
; 1041 : 		PageMemory *nextBmp = this->GetBitmapCache(page+1);

	jmp	SHORT $LN7@RenderThre
$LN69@RenderThre:

; 1009 : 
; 1010 : 		//Get from cache
; 1011 : 		PageMemory *bmpMem = this->GetBitmapCache(page);

	mov	ebx, DWORD PTR [edi+eax*4+12]

; 1012 : 		//Check if valid, if not create and add to cache
; 1013 : 		if(!bmpMem || (bmpMem && ( bmpMem->Width != bmWidth || bmpMem->Height != bmHeight)))

	test	ebx, ebx
	je	SHORT $LN76@RenderThre
	mov	eax, DWORD PTR _bmWidth$[esp+64]
	cmp	DWORD PTR [ebx+128], eax
	jne	SHORT $LN76@RenderThre
	mov	ecx, DWORD PTR _bmHeight$[esp+64]
	cmp	DWORD PTR [ebx+132], ecx
	je	SHORT $LN9@RenderThre
$LN76@RenderThre:
	xor	ebx, ebx
$LN7@RenderThre:

; 1014 : 		{
; 1015 : 			bmpMem = new PageMemory();

	push	136					; 00000088H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN13@RenderThre
	fld1
	mov	DWORD PTR [eax], ebx
	fst	DWORD PTR [eax+8]
	mov	DWORD PTR [eax+4], ebx
	fstp	DWORD PTR [eax+12]
	mov	DWORD PTR [eax+128], ebx
	fldz
	mov	DWORD PTR [eax+132], ebx
	fstp	QWORD PTR [eax+16]
	jmp	SHORT $LN14@RenderThre
$LN13@RenderThre:
	xor	eax, eax
$LN14@RenderThre:

; 1016 : 			bmpMem->Create(clientDC,bmWidth,bmHeight,m_renderDPI, out->getDefCTM(),out->getDefICTM());	

	fld	QWORD PTR [edi+536]
	mov	edx, DWORD PTR _bmHeight$[esp+64]
	mov	ecx, DWORD PTR _bmWidth$[esp+64]
	mov	edi, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR [esi+16]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	mov	edx, DWORD PTR _clientDC$[esp+76]
	push	ecx
	push	edx
	mov	esi, eax
	mov	DWORD PTR _bmpMem$[esp+84], eax
	call	?Create@PageMemory@@QAEHPAUHDC__@@HHNPAN1@Z ; PageMemory::Create
	mov	edi, DWORD PTR _this$[ebp]
	mov	ebx, esi
	mov	esi, DWORD PTR _out$[ebp]
$LN9@RenderThre:

; 1017 : 		}
; 1018 : 		//********START DIB
; 1019 : 		bmpMem->SetDimensions(bmWidth,bmHeight,m_renderDPI);

	fld	QWORD PTR [edi+536]
	mov	eax, DWORD PTR _bmWidth$[esp+64]
	fld1
	mov	ecx, DWORD PTR _bmHeight$[esp+64]
	fst	DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+128], eax

; 1020 : 		bmpMem->SetDIBits(clientDC,(void *)out->GetDataPtr());

	mov	eax, DWORD PTR _clientDC$[esp+64]
	fstp	DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx+132], ecx
	fstp	QWORD PTR [ebx+16]
	mov	edx, DWORD PTR [esi+8]
	push	edx
	push	eax
	mov	esi, ebx
	call	?SetDIBits@PageMemory@@QAEHPAUHDC__@@PBX@Z ; PageMemory::SetDIBits

; 1021 : 		//********END DIB
; 1022 : 		AddBitmapCache(bmpMem,page);

	mov	ecx, DWORD PTR _page$[ebp]
	push	ecx
	push	ebx
	mov	esi, edi
	call	?AddBitmapCache@AFPDFDoc@@AAEXPAVPageMemory@@H@Z ; AFPDFDoc::AddBitmapCache

; 1023 : 		//If was called by render current, then update the current Bitmap, if not just save in cache	
; 1024 : 		if(byThread){

	cmp	BYTE PTR _byThread$[esp+64], 0
	je	$LN6@RenderThre

; 1025 : 			m_PageHeight = bmHeight;

	mov	edx, DWORD PTR _bmHeight$[esp+64]

; 1026 : 			m_PageWidth  = bmWidth;

	mov	eax, DWORD PTR _bmWidth$[esp+64]
	mov	DWORD PTR [edi+516], edx

; 1027 : 			//Update current bitmap
; 1028 : 			m_Bitmap =bmpMem;
; 1029 : 
; 1030 : 			//Update page box
; 1031 : 			int box_left, box_top, box_right, box_bottom;
; 1032 : 			
; 1033 : 			out->getModRegion(&box_left, &box_top, &box_right, &box_bottom);

	lea	ecx, DWORD PTR _box_bottom$85954[esp+64]
	push	ecx
	mov	DWORD PTR [edi+520], eax
	lea	edx, DWORD PTR _box_right$85953[esp+68]
	push	edx
	mov	edx, DWORD PTR _out$[ebp]
	lea	eax, DWORD PTR _box_top$85952[esp+72]
	push	eax
	lea	ecx, DWORD PTR _box_left$85951[esp+76]
	mov	DWORD PTR [edi+352], ebx
	push	ecx
	mov	ecx, DWORD PTR [edx+12]
	call	?getModRegion@SplashOutputDev@@QAEXPAH000@Z ; SplashOutputDev::getModRegion

; 1034 : 			m_bbox = CRect(box_left, box_top, box_right, box_bottom);
; 1035 : 
; 1036 : 			m_LastRenderDPI = m_renderDPI;

	fld	QWORD PTR [edi+536]
	mov	ebx, DWORD PTR _box_right$85953[esp+64]
	fstp	QWORD PTR [edi+528]
	mov	edx, DWORD PTR _box_left$85951[esp+64]
	mov	esi, DWORD PTR _box_top$85952[esp+64]
	mov	ecx, DWORD PTR _box_bottom$85954[esp+64]
	mov	DWORD PTR [edi+412], edx
	mov	eax, ebx
	sub	eax, edx
	mov	edx, DWORD PTR _box_bottom$85954[esp+64]
	mov	DWORD PTR [edi+416], esi
	mov	DWORD PTR [edi+420], ebx
	mov	DWORD PTR [edi+424], edx
	mov	DWORD PTR [edi+428], eax

; 1037 : 			m_LastPageRendered=page;

	mov	eax, DWORD PTR _page$[ebp]
	sub	ecx, esi
	mov	DWORD PTR [edi+432], ecx
	mov	DWORD PTR [edi+508], eax
$LN6@RenderThre:

; 1038 : 		}
; 1039 : 		bool newThreadRunned=false;
; 1040 : 		//prerender next page
; 1041 : 		PageMemory *nextBmp = this->GetBitmapCache(page+1);

	mov	edx, DWORD PTR _page$[ebp]
	mov	ecx, DWORD PTR tv591[esp+64]
	xor	eax, eax
	inc	edx
$LL54@RenderThre:
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN70@RenderThre
	inc	eax
	add	ecx, 4
	cmp	eax, 16					; 00000010H
	jl	SHORT $LL54@RenderThre
$LN70@RenderThre:

; 1042 : 		if (0 && nextBmp==0 && (page+1 <= m_PDFDoc->getNumPages() && enablePreRender && byThread))
; 1043 : 		{   
; 1044 : 			m_PageToRenderByThread = page+1;
; 1045 : 			
; 1046 : 			//Establecemos el color del papel
; 1047 : 			SplashColor paperColor;
; 1048 : 			paperColor[0] = 0xff;
; 1049 : 			paperColor[1] = 0xff;
; 1050 : 			paperColor[2] = 0xff;
; 1051 : 
; 1052 : 			//Delete splash
; 1053 : 			if(m_splashOut>0){
; 1054 : 				delete m_splashOut;
; 1055 : 				m_splashOut=0;
; 1056 : 			}
; 1057 : 			
; 1058 : 			threadParam *tp = new threadParam(this,m_PageToRenderByThread);
; 1059 : 			tp->out=new AuxOutputDev(new SplashOutputDev(splashModeBGR8, 4, gFalse, paperColor,gTrue,globalParams->getAntialias()));
; 1060 : 			tp->out->startDoc(m_PDFDoc->getXRef());
; 1061 : 			tp->out->clearModRegion();
; 1062 : 			tp->pageToRender=m_PageToRenderByThread;
; 1063 : 			tp->enablePreRender=false;//Disable Prerender next page
; 1064 : 			newThreadRunned=true;
; 1065 : 
; 1066 : 			m_splashOut=tp->out;
; 1067 : 			ResetEvent(this->hRenderFinished);
; 1068 : 			
; 1069 : 			InterlockedExchange(&this->g_lLocker,0);
; 1070 : 			m_renderingThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)AFPDFDoc::RenderingThread,(LPVOID)tp,CREATE_SUSPENDED,0);
; 1071 : 			//SetThreadPriority(m_renderingThread,THREAD_PRIORITY_BELOW_NORMAL);
; 1072 : 			ResumeThread(m_renderingThread);	
; 1073 : 		}else{
; 1074 : 			m_renderingThread=0;
; 1075 : 		}
; 1076 : 		
; 1077 : 		if(this->m_RenderFinishHandle!=0 && byThread)

	mov	eax, DWORD PTR [edi+220]
	mov	DWORD PTR [edi+240], 0
	test	eax, eax
	je	SHORT $LN74@RenderThre
	cmp	BYTE PTR _byThread$[esp+64], 0
	je	SHORT $LN74@RenderThre

; 1078 : 			this->m_RenderFinishHandle();

	call	eax
$LN74@RenderThre:

; 1079 : 		
; 1080 : 		/*if(this->m_RenderNotifyFinishHandle)
; 1081 : 			this->m_RenderNotifyFinishHandle(page,byThread);*/
; 1082 : 		
; 1083 : 		if(!newThreadRunned)
; 1084 : 			SetEvent(this->hRenderFinished);

	mov	ecx, DWORD PTR [edi+176]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4

; 1085 : 		
; 1086 : 		return 0;
; 1087 : 	}

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?RenderThreadFinished@AFPDFDoc@@AAEHPAVAuxOutputDev@@H_N@Z ENDP ; AFPDFDoc::RenderThreadFinished
PUBLIC	__$ArrayPad$
PUBLIC	?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z		; AFPDFDoc::ExportingJpgThread
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z$2
__ehfuncinfo$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z
_TEXT	SEGMENT
_eError$ = -184						; size = 4
_paperColor$86833 = -180				; size = 3
_doc$ = -176						; size = 4
_bmi$86834 = -172					; size = 44
$T190235 = -128						; size = 4
_errMessage$ = -124					; size = 28
_fileName$ = -96					; size = 28
__$ArrayPad$ = -68					; size = 4
__$EHRec$ = -12						; size = 12
_param$ = 8						; size = 4
?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z PROC		; AFPDFDoc::ExportingJpgThread, COMDAT

; 2750 : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+244], eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+260]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _param$[ebp]

; 2751 : 		ExportParams *exp = (ExportParams *)param;
; 2752 : 		PDFDoc *doc;
; 2753 : 		
; 2754 : 		doc = exp->_this->createDoc(NULL);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?createDoc@AFPDFDoc@@IAEPAVPDFDoc@@PAD@Z ; AFPDFDoc::createDoc
	mov	ebx, eax

; 2755 : 		
; 2756 : 		SplashOutputDev	*splashOut=NULL;
; 2757 : 		int eError=0;

	xor	edi, edi

; 2758 : 		string_type errMessage;

	lea	ecx, DWORD PTR _errMessage$[esp+260]
	mov	DWORD PTR _doc$[esp+260], ebx
	mov	DWORD PTR _eError$[esp+260], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[esp+268], edi

; 2759 : 		string_type fileName(exp->fileName);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	lea	ecx, DWORD PTR _fileName$[esp+264]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+268], 1

; 2760 : 
; 2761 : 		if(doc!=NULL){

	cmp	ebx, edi
	je	$LN13@ExportingJ

; 2762 : 			SplashColor paperColor;
; 2763 : 			paperColor[0] = 0xff;
; 2764 : 			paperColor[1] = 0xff;
; 2765 : 			paperColor[2] = 0xff;
; 2766 : 
; 2767 : 			BITMAPINFO bmi;
; 2768 : 			ZeroMemory(&bmi,sizeof(bmi));

	push	44					; 0000002cH
	mov	al, 255					; 000000ffH
	lea	edx, DWORD PTR _bmi$86834[esp+264]
	push	edi
	push	edx
	mov	BYTE PTR _paperColor$86833[esp+272], al
	mov	BYTE PTR _paperColor$86833[esp+273], al
	mov	BYTE PTR _paperColor$86833[esp+274], al
	call	_memset
	add	esp, 12					; 0000000cH

; 2769 : 			bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
; 2770 : 			
; 2771 : 			bmi.bmiHeader.biPlanes=1;

	mov	eax, 1

; 2772 : 			bmi.bmiHeader.biBitCount=24;

	mov	ecx, 24					; 00000018H

; 2773 : 			bmi.bmiHeader.biCompression=BI_RGB;
; 2774 : 
; 2775 : 			bmi.bmiColors[0].rgbBlue = 0;
; 2776 : 			bmi.bmiColors[0].rgbGreen = 0;
; 2777 : 			bmi.bmiColors[0].rgbRed = 0;
; 2778 : 			bmi.bmiColors[0].rgbReserved = 0;
; 2779 : 			
; 2780 : 
; 2781 : 			splashOut = new SplashOutputDev(splashModeBGR8, 4, gFalse, paperColor,gTrue,globalParams->getAntialias());

	push	248					; 000000f8H
	mov	DWORD PTR _bmi$86834[esp+264], 40	; 00000028H
	mov	WORD PTR _bmi$86834[esp+276], ax
	mov	WORD PTR _bmi$86834[esp+278], cx
	mov	DWORD PTR _bmi$86834[esp+280], edi
	mov	BYTE PTR _bmi$86834[esp+304], 0
	mov	BYTE PTR _bmi$86834[esp+305], 0
	mov	BYTE PTR _bmi$86834[esp+306], 0
	mov	BYTE PTR _bmi$86834[esp+307], 0
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T190235[esp+260], ebx
	mov	BYTE PTR __$EHRec$[esp+268], 2
	cmp	ebx, edi
	je	SHORT $LN16@ExportingJ
	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	call	?getAntialias@GlobalParams@@QAEHXZ	; GlobalParams::getAntialias
	push	eax
	push	1
	lea	edx, DWORD PTR _paperColor$86833[esp+268]
	push	edx
	push	edi
	push	4
	push	3
	mov	ecx, ebx
	call	??0SplashOutputDev@@QAE@W4SplashColorMode@@HHPAEHH@Z ; SplashOutputDev::SplashOutputDev
	mov	edi, eax
$LN16@ExportingJ:
	mov	BYTE PTR __$EHRec$[esp+268], 1

; 2782 : 			splashOut->setVectorAntialias(globalParams->getVectorAntialias());

	mov	ebx, DWORD PTR [edi]
	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	add	ebx, 316				; 0000013cH
	call	?getVectorAntialias@GlobalParams@@QAEHXZ ; GlobalParams::getVectorAntialias
	push	eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, edi
	call	eax

; 2783 : 			splashOut->startDoc(doc->getXRef());

	mov	ecx, DWORD PTR _doc$[esp+260]
	mov	eax, DWORD PTR [ecx+24]
	push	eax
	mov	ecx, edi
	call	?startDoc@SplashOutputDev@@QAEXPAVXRef@@@Z ; SplashOutputDev::startDoc

; 2784 : 		
; 2785 : 			for(int page=exp->fromPage;page<=exp->toPage;page++){

	mov	ebx, DWORD PTR [esi+8]
	cmp	ebx, DWORD PTR [esi+12]
	jg	$LN4@ExportingJ
	npad	6
$LL12@ExportingJ:

; 2786 : 				DWORD waitRes = WaitForSingleObject(exp->_this->hExportJpgCancel,0);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+172]
	push	0
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 2787 : 				if(waitRes ==  WAIT_OBJECT_0){

	test	eax, eax
	je	$LN43@ExportingJ

; 2791 : 				}else{
; 2792 : 					if(exp->_this->m_ExportProgressHandle != 0){

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+212]
	test	ecx, ecx
	je	SHORT $LN6@ExportingJ

; 2793 : 						if(!exp->_this->m_ExportProgressHandle(exp->toPage-exp->fromPage+1,page-exp->fromPage+1) !=0){

	mov	eax, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, eax
	inc	edx
	push	edx
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	inc	edx
	push	edx
	call	ecx
	test	eax, eax
	je	$LN44@ExportingJ
$LN6@ExportingJ:

; 2797 : 						}
; 2798 : 					}
; 2799 : 
; 2800 : 					doc->displayPage(splashOut,page, 
; 2801 : 							exp->renderDPI, exp->renderDPI, exp->rotation, 
; 2802 : 							gFalse, gTrue, gFalse,0,0);

	mov	eax, DWORD PTR [esi+24]
	fld	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR _doc$[esp+260]
	push	0
	push	0
	push	0
	push	1
	push	0
	push	eax
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR [esi+20]
	fstp	QWORD PTR [esp]
	push	ebx
	push	edi
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 2803 : 			
; 2804 : 					bmi.bmiHeader.biWidth = splashOut->getBitmap()->getWidth();

	mov	eax, DWORD PTR [edi+180]
	mov	ecx, DWORD PTR [eax]

; 2805 : 					bmi.bmiHeader.biHeight = splashOut->getBitmap()->getHeight();

	mov	edx, DWORD PTR [eax+4]

; 2806 : 					
; 2807 : 					if(JpegFromDib((HANDLE)splashOut->getBitmap()->getDataPtr(),&bmi,exp->quality,fileName,errMessage)!=0){

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _bmi$86834[esp+264], ecx
	mov	DWORD PTR _bmi$86834[esp+268], edx
	lea	ecx, DWORD PTR _fileName$[esp+260]
	push	ecx
	lea	edx, DWORD PTR _bmi$86834[esp+264]
	push	edx
	mov	edx, DWORD PTR [esi+16]
	push	eax
	lea	ecx, DWORD PTR _errMessage$[esp+272]
	call	?JpegFromDib@@YAHPAXPAUtagBITMAPINFO@@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; JpegFromDib
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN45@ExportingJ
	inc	ebx
	cmp	ebx, DWORD PTR [esi+12]
	jle	$LL12@ExportingJ
$LN4@ExportingJ:

; 2818 : 			delete doc;

	mov	ebx, DWORD PTR _doc$[esp+260]
	mov	ecx, ebx
	call	??1PDFDoc@@QAE@XZ			; PDFDoc::~PDFDoc
	push	ebx
	call	??3@YAXPAX@Z				; operator delete

; 2819 : 		if(splashOut!=NULL)
; 2820 : 			delete splashOut;

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	add	esp, 4
	push	1
	mov	ecx, edi
	call	eax
	xor	edi, edi
$LN20@ExportingJ:

; 2821 : 		SetEvent(exp->_this->hExportJpgFinished); 

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	call	DWORD PTR __imp__SetEvent@4

; 2822 : 		if(exp->_this->m_ExportFinishHandle !=0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+216]
	cmp	eax, edi
	je	SHORT $LN1@ExportingJ

; 2823 : 			exp->_this->m_ExportFinishHandle();

	call	eax
$LN1@ExportingJ:

; 2824 : 		return eError;

	lea	ecx, DWORD PTR _fileName$[esp+260]
	mov	BYTE PTR __$EHRec$[esp+268], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _errMessage$[esp+260]
	mov	DWORD PTR __$EHRec$[esp+268], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _eError$[esp+260]

; 2825 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+260]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+244]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@ExportingJ:

; 2788 : 					SetEvent(exp->_this->hExportJpgCancelled);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+180]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4

; 2789 : 					eError=1;

	mov	DWORD PTR _eError$[esp+260], 1

; 2790 : 					break;//Process canceled

	jmp	$LN4@ExportingJ
$LN44@ExportingJ:

; 2794 : 							SetEvent(exp->_this->hExportJpgCancelled);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	call	DWORD PTR __imp__SetEvent@4

; 2795 : 							eError=4;

	mov	DWORD PTR _eError$[esp+260], 4

; 2796 : 							break;

	jmp	$LN4@ExportingJ
$LN45@ExportingJ:

; 2808 : 						eError=3;

	mov	DWORD PTR _eError$[esp+260], 3

; 2809 : 						break;
; 2810 : 					}
; 2811 : 					
; 2812 : 				}
; 2813 : 			}

	jmp	$LN4@ExportingJ
$LN13@ExportingJ:

; 2814 : 		}else{
; 2815 : 			eError=2;

	mov	DWORD PTR _eError$[esp+260], 2

; 2816 : 		}
; 2817 : 		if(doc!=NULL)

	jmp	$LN20@ExportingJ
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z$0:
	lea	ecx, DWORD PTR _errMessage$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z$1:
	lea	ecx, DWORD PTR _fileName$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z$2:
	mov	eax, DWORD PTR $T190235[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-244]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z ENDP		; AFPDFDoc::ExportingJpgThread
PUBLIC	__$ArrayPad$
PUBLIC	?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z		; AFPDFDoc::SaveJpg
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\auxoutputdev.cpp
xdata$x	SEGMENT
__unwindtable$?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z$1
__ehfuncinfo$?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z
_TEXT	SEGMENT
_exitcode$86800 = -124					; size = 4
_exitcode$86780 = -124					; size = 4
_bmi$86788 = -120					; size = 44
_dThread$86812 = -76					; size = 4
$T190298 = -72						; size = 28
_errmsg$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
_renderDPI$ = 12					; size = 4
_fromPage$ = 16						; size = 4
_toPage$ = 20						; size = 4
_quality$ = 24						; size = 4
_waitProc$ = 28						; size = 4
?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z PROC			; AFPDFDoc::SaveJpg, COMDAT
; _this$ = ecx

; 2647 : 	{

	push	-1
	push	__ehhandler$?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+124], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+144]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _fileName$[esp+140]
	mov	esi, ecx

; 2648 : 		string_type errmsg;

	lea	ecx, DWORD PTR _errmsg$[esp+144]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2649 : 		DWORD waitRes=0;
; 2650 : 		//If the current rendered page is the same requested
; 2651 : 		if(renderDPI ==  this->m_renderDPI
; 2652 : 			&& fromPage == this->m_LastPageRenderedByThread
; 2653 : 			&& toPage == fromPage){

	fld	DWORD PTR _renderDPI$[esp+140]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+152], ebx
	fcomp	QWORD PTR [esi+536]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN14@SaveJpg
	mov	eax, DWORD PTR _fromPage$[esp+140]
	cmp	eax, DWORD PTR [esi+160]
	jne	$LN14@SaveJpg
	cmp	DWORD PTR _toPage$[esp+140], eax
	jne	$LN14@SaveJpg

; 2654 : 
; 2655 : 			if (m_renderingThread!=0)

	mov	eax, DWORD PTR [esi+240]
	cmp	eax, ebx
	je	SHORT $LN13@SaveJpg

; 2656 : 			{
; 2657 : 				DWORD exitcode=0;
; 2658 : 				//hurry up!
; 2659 : 				
; 2660 : 				GetExitCodeThread(m_renderingThread,&exitcode);

	mov	edi, DWORD PTR __imp__GetExitCodeThread@8
	lea	ecx, DWORD PTR _exitcode$86780[esp+144]
	push	ecx
	push	eax
	mov	DWORD PTR _exitcode$86780[esp+152], ebx
	call	edi

; 2661 : 				if(exitcode==STILL_ACTIVE)

	cmp	DWORD PTR _exitcode$86780[esp+144], 259	; 00000103H
	jne	SHORT $LN10@SaveJpg

; 2662 : 					SetThreadPriority(m_renderingThread,THREAD_PRIORITY_ABOVE_NORMAL);

	mov	edx, DWORD PTR [esi+240]
	push	1
	push	edx
	call	DWORD PTR __imp__SetThreadPriority@8

; 2663 : 				while (exitcode==STILL_ACTIVE){

	cmp	DWORD PTR _exitcode$86780[esp+144], 259	; 00000103H
	jne	SHORT $LN10@SaveJpg
	npad	8
$LL11@SaveJpg:

; 2664 : 					
; 2665 : 					GetExitCodeThread(m_renderingThread,&exitcode);

	mov	ecx, DWORD PTR [esi+240]
	lea	eax, DWORD PTR _exitcode$86780[esp+144]
	push	eax
	push	ecx
	call	edi

; 2666 : 					Sleep(50);

	push	50					; 00000032H
	call	DWORD PTR __imp__Sleep@4
	cmp	DWORD PTR _exitcode$86780[esp+144], 259	; 00000103H
	je	SHORT $LL11@SaveJpg
$LN10@SaveJpg:

; 2667 : 				}
; 2668 : 				CloseHandle(m_renderingThread);

	mov	edx, DWORD PTR [esi+240]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 2669 : 				m_renderingThread=NULL;

	mov	DWORD PTR [esi+240], ebx
$LN13@SaveJpg:

; 2670 : 			}
; 2671 : 			SplashColor paperColor;
; 2672 : 			paperColor[0] = 0xff;
; 2673 : 			paperColor[1] = 0xff;
; 2674 : 			paperColor[2] = 0xff;
; 2675 : 
; 2676 : 			BITMAPINFO bmi;
; 2677 : 			ZeroMemory(&bmi,sizeof(bmi));

	push	44					; 0000002cH
	lea	eax, DWORD PTR _bmi$86788[esp+148]
	push	ebx
	push	eax
	call	_memset

; 2678 : 			bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
; 2679 : 			bmi.bmiHeader.biWidth = (long)m_splashOut->GetWidth();

	mov	edi, DWORD PTR [esi+344]
	fld	QWORD PTR [edi+24]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bmi$86788[esp+144], 40	; 00000028H
	call	__ftol2_sse

; 2680 : 			bmi.bmiHeader.biHeight = (long)m_splashOut->GetHeight();

	fld	QWORD PTR [edi+32]
	mov	DWORD PTR _bmi$86788[esp+148], eax
	call	__ftol2_sse

; 2681 : 			bmi.bmiHeader.biPlanes=1;

	mov	ecx, 1
	mov	WORD PTR _bmi$86788[esp+156], cx

; 2682 : 			bmi.bmiHeader.biBitCount=24;

	mov	edx, 24					; 00000018H

; 2683 : 			bmi.bmiHeader.biCompression=BI_RGB;
; 2684 : 
; 2685 : 			bmi.bmiColors[0].rgbBlue = 0;
; 2686 : 			bmi.bmiColors[0].rgbGreen = 0;
; 2687 : 			bmi.bmiColors[0].rgbRed = 0;
; 2688 : 			bmi.bmiColors[0].rgbReserved = 0;
; 2689 : 			
; 2690 : 			int ret = JpegFromDib((HANDLE)m_splashOut->GetDataPtr(),&bmi,quality,string_type(fileName),errmsg);

	push	ebp
	lea	ecx, DWORD PTR $T190298[esp+148]
	mov	DWORD PTR _bmi$86788[esp+156], eax
	mov	WORD PTR _bmi$86788[esp+162], dx
	mov	DWORD PTR _bmi$86788[esp+164], ebx
	mov	BYTE PTR _bmi$86788[esp+188], bl
	mov	BYTE PTR _bmi$86788[esp+189], bl
	mov	BYTE PTR _bmi$86788[esp+190], bl
	mov	BYTE PTR _bmi$86788[esp+191], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+152], 1
	mov	ecx, DWORD PTR [esi+344]
	mov	ecx, DWORD PTR [ecx+8]
	push	eax
	lea	edx, DWORD PTR _bmi$86788[esp+148]
	push	edx
	mov	edx, DWORD PTR _quality$[esp+148]
	push	ecx
	lea	ecx, DWORD PTR _errmsg$[esp+156]
	call	?JpegFromDib@@YAHPAXPAUtagBITMAPINFO@@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; JpegFromDib
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T190298[esp+144]
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[esp+152], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2691 : 			if(this->m_ExportProgressHandle != 0){

	mov	esi, DWORD PTR [esi+212]
	cmp	esi, ebx
	je	SHORT $LN8@SaveJpg

; 2692 : 				if(this->m_ExportProgressHandle(1,1) !=0){

	push	1
	push	1
	call	esi
$LN8@SaveJpg:

; 2693 : 				}
; 2694 : 			}
; 2695 : 
; 2696 : 			return ret;

	lea	ecx, DWORD PTR _errmsg$[esp+144]
	mov	DWORD PTR __$EHRec$[esp+152], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, edi
	jmp	$LN15@SaveJpg
$LN14@SaveJpg:

; 2697 : 			
; 2698 : 		}else{
; 2699 : 			if(m_exportJpgThread!=0){

	mov	eax, DWORD PTR [esi+244]
	cmp	eax, ebx
	je	SHORT $LN6@SaveJpg

; 2700 : 				DWORD exitcode=0;
; 2701 : 				GetExitCodeThread(m_exportJpgThread,&exitcode);

	lea	ecx, DWORD PTR _exitcode$86800[esp+144]
	push	ecx
	push	eax
	mov	DWORD PTR _exitcode$86800[esp+152], ebx
	call	DWORD PTR __imp__GetExitCodeThread@8

; 2702 : 				if (exitcode==STILL_ACTIVE){	

	cmp	DWORD PTR _exitcode$86800[esp+144], 259	; 00000103H
	jne	SHORT $LN5@SaveJpg

; 2703 : 					//Cancel event
; 2704 : 					SetEvent(this->hExportJpgCancel);

	mov	edx, DWORD PTR [esi+172]
	push	edx
	call	DWORD PTR __imp__SetEvent@4

; 2705 : 					//Wait for finished
; 2706 : 					WaitForSingleObject(this->hExportJpgFinished,INFINITE);

	mov	eax, DWORD PTR [esi+184]
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN5@SaveJpg:

; 2707 : 				}
; 2708 : 				CloseHandle(m_exportJpgThread);

	mov	ecx, DWORD PTR [esi+244]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 2709 : 				m_exportJpgThread=0;

	mov	DWORD PTR [esi+244], ebx
$LN6@SaveJpg:

; 2710 : 
; 2711 : 			}
; 2712 : 			
; 2713 : 			if(this->hExportJpgCancel ==0){

	cmp	DWORD PTR [esi+172], ebx
	jne	SHORT $LN4@SaveJpg

; 2714 : 				this->hExportJpgCancel = CreateEvent(NULL,TRUE,FALSE,TEXT("CancellEvent"));

	mov	edi, DWORD PTR __imp__CreateEventA@16
	push	OFFSET ??_C@_0N@IKAKOCOF@CancellEvent?$AA@
	push	ebx
	push	1
	push	ebx
	call	edi

; 2715 : 				this->hExportJpgCancelled = CreateEvent(NULL,TRUE,FALSE,TEXT("CancelledEvent"));

	push	OFFSET ??_C@_0P@NCLJFCBB@CancelledEvent?$AA@
	push	ebx
	push	1
	push	ebx
	mov	DWORD PTR [esi+172], eax
	call	edi

; 2716 : 				this->hExportJpgFinished = CreateEvent(NULL,TRUE,FALSE,TEXT("FinishedEvent"));

	push	OFFSET ??_C@_0O@MFHBPFDF@FinishedEvent?$AA@
	push	ebx
	push	1
	push	ebx
	mov	DWORD PTR [esi+180], eax
	call	edi
	mov	DWORD PTR [esi+184], eax
$LN4@SaveJpg:

; 2717 : 			}
; 2718 : 			ResetEvent(this->hExportJpgCancel);

	mov	edx, DWORD PTR [esi+172]
	mov	edi, DWORD PTR __imp__ResetEvent@4
	push	edx
	call	edi

; 2719 : 			ResetEvent(this->hExportJpgCancelled);

	mov	eax, DWORD PTR [esi+180]
	push	eax
	call	edi

; 2720 : 			ResetEvent(this->hExportJpgFinished);

	mov	ecx, DWORD PTR [esi+184]
	push	ecx
	call	edi

; 2721 : 			ExportParams *p=new ExportParams;

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax

; 2722 : 			p->_this = this;
; 2723 : 			p->fileName =new char[strlen(fileName)+1];

	mov	eax, ebp
	add	esp, 4
	mov	DWORD PTR [edi], esi
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL29@SaveJpg:
	mov	cl, BYTE PTR [eax]
	inc	eax
	cmp	cl, bl
	jne	SHORT $LL29@SaveJpg
	sub	eax, edx
	inc	eax
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 2724 : 			strcpy(p->fileName,fileName);

	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [edi+4], eax
	mov	ecx, ebp
	sub	edx, ebp
	npad	4
$LL17@SaveJpg:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx+ecx], al
	inc	ecx
	cmp	al, bl
	jne	SHORT $LL17@SaveJpg

; 2725 : 			p->rotation=m_Rotation;

	mov	edx, DWORD PTR [esi+524]

; 2726 : 			p->renderDPI = renderDPI;

	fld	DWORD PTR _renderDPI$[esp+140]

; 2727 : 			p->fromPage = fromPage;

	mov	eax, DWORD PTR _fromPage$[esp+140]
	fstp	DWORD PTR [edi+20]

; 2728 : 			p->toPage = toPage;

	mov	ecx, DWORD PTR _toPage$[esp+140]

; 2729 : 			p->quality =quality;
; 2730 : 			p->WaitTime = waitProc;

	mov	ebp, DWORD PTR _waitProc$[esp+140]
	mov	DWORD PTR [edi+8], eax

; 2731 : 			DWORD dThread;
; 2732 : 			m_exportJpgThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)AFPDFDoc::ExportingJpgThread,(LPVOID)p,THREAD_PRIORITY_NORMAL,&dThread);

	lea	eax, DWORD PTR _dThread$86812[esp+144]
	push	eax
	push	ebx
	push	edi
	push	OFFSET ?ExportingJpgThread@AFPDFDoc@@KAIPAX@Z ; AFPDFDoc::ExportingJpgThread
	mov	DWORD PTR [edi+24], edx
	mov	edx, DWORD PTR _quality$[esp+156]
	push	ebx
	push	ebx
	mov	DWORD PTR [edi+12], ecx
	mov	DWORD PTR [edi+16], edx
	mov	DWORD PTR [edi+28], ebp
	call	DWORD PTR __imp__CreateThread@24
	mov	DWORD PTR [esi+244], eax

; 2733 : 
; 2734 : //			m_exportJpgThread->m_bAutoDelete=false;
; 2735 : //			m_exportJpgThread->ResumeThread();
; 2736 : 			if(waitProc==-1){

	cmp	ebp, -1
	jne	SHORT $LN3@SaveJpg

; 2737 : 				::WaitForSingleObject(this->hExportJpgFinished,INFINITE);

	mov	ecx, DWORD PTR [esi+184]
	push	ebp
	push	ecx
	jmp	SHORT $LN34@SaveJpg
$LN3@SaveJpg:

; 2738 : 			}else if(waitProc>0){

	cmp	ebp, ebx
	jle	SHORT $LN1@SaveJpg

; 2739 : 				::WaitForSingleObject(this->hExportJpgFinished,waitProc);

	mov	edx, DWORD PTR [esi+184]
	push	ebp
	push	edx
$LN34@SaveJpg:
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN1@SaveJpg:

; 2740 : 			}
; 2741 : 
; 2742 : 			return waitRes;

	lea	ecx, DWORD PTR _errmsg$[esp+144]
	mov	DWORD PTR __$EHRec$[esp+152], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	eax, eax
$LN15@SaveJpg:

; 2743 : 		}
; 2744 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+144]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+124]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 124				; 0000007cH
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z$0:
	lea	ecx, DWORD PTR _errmsg$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z$1:
	lea	ecx, DWORD PTR $T190298[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-128]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SaveJpg@AFPDFDoc@@QAEHPADMHHHH@Z ENDP			; AFPDFDoc::SaveJpg
PUBLIC	__$ArrayPad$
PUBLIC	?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z		; AFPDFDoc::FindFirst
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\dynarray.h
xdata$x	SEGMENT
__unwindtable$?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z$1
__ehfuncinfo$?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z
_TEXT	SEGMENT
$T190430 = -312						; size = 4
_length$ = -312						; size = 4
_ucstring$190356 = -308					; size = 4
$T190432 = -304						; size = 4
_iFirstPageFound$ = -304				; size = 4
$T190431 = -300						; size = 4
_y0$ = -296						; size = 8
_x0$ = -288						; size = 8
_x1$ = -280						; size = 8
_y1$ = -272						; size = 8
_FindPage$ = -264					; size = 136
$T190341 = -124						; size = 28
_theString$ = -96					; size = 28
__$ArrayPad$ = -68					; size = 4
__$EHRec$ = -12						; size = 12
_SearchOrder$ = 8					; size = 4
_Backward$ = 12						; size = 1
_WholeWord$ = 16					; size = 1
?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z PROC		; AFPDFDoc::FindFirst, COMDAT
; _this$ = ecx
; _sText$ = edx

; 2429 : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+372], eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, eax

; 2430 : 		
; 2431 : 
; 2432 : 		double x0, y0, x1, y1;
; 2433 : 		x0=y0=x1=y1=0;

	fldz

; 2434 : 		long iFirstPageFound=0;

	xor	ebx, ebx

; 2435 : 		long searchPage=0;
; 2436 : 		GBool rc, startAtTop, startAtLast, backward;
; 2437 : 		Unicode * ucstring;
; 2438 : 		TextOutputDev FindPage(NULL, gTrue, gFalse, gFalse);

	push	ebx
	fst	QWORD PTR _y1$[esp+392]
	push	ebx
	fst	QWORD PTR _x1$[esp+396]
	push	1
	fst	QWORD PTR _y0$[esp+400]
	mov	esi, ecx
	fstp	QWORD PTR _x0$[esp+400]
	push	ebx
	lea	ecx, DWORD PTR _FindPage$[esp+404]
	mov	edi, edx
	mov	DWORD PTR _iFirstPageFound$[esp+404], ebx
	call	??0TextOutputDev@@QAE@PADHHH@Z		; TextOutputDev::TextOutputDev

; 2439 : 
; 2440 : #ifdef PDFLIBNET_ORIGINAL
; 2441 : 		CString theString(sText);
; 2442 : 		int length = theString.GetLength();
; 2443 : #else
; 2444 : 		std::basic_string<wchar_t> theString(sText);

	push	edi
	lea	ecx, DWORD PTR _theString$[esp+392]
	mov	DWORD PTR __$EHRec$[esp+400], ebx
	call	DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
	mov	BYTE PTR __$EHRec$[esp+396], 1

; 2445 : 		int length = theString.size();

	mov	eax, DWORD PTR _theString$[esp+408]
	mov	ebx, eax

; 2446 : #endif
; 2447 : 		
; 2448 : 		//Tratar de reservar la cadena
; 2449 : 		ucstring = GetUnicodeString(sText, length);

	xor	ecx, ecx
	inc	eax
	mov	edx, 4
	mul	edx
	seto	cl
	mov	DWORD PTR _length$[esp+388], ebx
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _ucstring$190356[esp+388], ecx
	test	ecx, ecx
	je	SHORT $LN74@FindFirst
	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN24@FindFirst
$LL26@FindFirst:
	movzx	edx, WORD PTR [edi+eax*2]
	mov	DWORD PTR [ecx+eax*4], edx
	inc	eax
	cmp	eax, ebx
	jl	SHORT $LL26@FindFirst
$LN24@FindFirst:

; 2453 : 		}
; 2454 : 
; 2455 : 		startAtTop = gTrue;
; 2456 : 		startAtLast = gFalse;
; 2457 : 		backward = Backward; 

	movzx	edi, BYTE PTR _Backward$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 2458 : 		m_SearchStarted = FALSE;

	mov	BYTE PTR [esi+546], 0

; 2459 : 		m_Selection.RemoveAll();

	mov	eax, DWORD PTR [esi+320]
	push	3584					; 00000e00H
	push	eax
	mov	DWORD PTR [esi+324], 0
	call	DWORD PTR __imp__realloc
	add	esp, 8

; 2460 : 
; 2461 : 		//Si se desea buscar desde el principio
; 2462 : 		if(SearchOrder==0)

	cmp	DWORD PTR _SearchOrder$[ebp], 0
	mov	DWORD PTR [esi+320], eax
	mov	DWORD PTR [esi+328], 128		; 00000080H

; 2463 : 			searchPage=1;

	mov	ebx, 1
	je	SHORT $LN15@FindFirst

; 2464 : 		else
; 2465 : 			searchPage=m_CurrentPage;

	mov	ebx, DWORD PTR [esi+504]
$LN15@FindFirst:

; 2466 : 
; 2467 : 		if(searchPage>this->GetPageCount())

	mov	ecx, DWORD PTR [esi+332]
	test	ecx, ecx
	je	SHORT $LN34@FindFirst
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN34@FindFirst
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+12]
	jmp	SHORT $LN36@FindFirst
$LN74@FindFirst:

; 2450 : 		if (ucstring == NULL) {
; 2451 : //			AfxMessageBox("Out of memory");
; 2452 : 			return FALSE;

	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
	xor	eax, eax
	jmp	$LN18@FindFirst

; 2466 : 
; 2467 : 		if(searchPage>this->GetPageCount())

$LN34@FindFirst:
	xor	eax, eax
$LN36@FindFirst:
	cmp	ebx, eax
	jle	SHORT $LN46@FindFirst

; 2468 : 			searchPage = this->GetPageCount();

	test	ecx, ecx
	je	SHORT $LN75@FindFirst
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN75@FindFirst
	mov	eax, DWORD PTR [ecx+28]
	mov	ebx, DWORD PTR [eax+12]
$LN46@FindFirst:

; 2469 : 		if(searchPage<1)

	cmp	ebx, 1
	jge	SHORT $LN13@FindFirst
$LN75@FindFirst:

; 2470 : 			searchPage=1;

	mov	ebx, 1
$LN13@FindFirst:

; 2471 : 
; 2472 : 		/* use fixed DPI and rotation, this would lead to somehwere
; 2473 : 		 * wrong positioning displaying more than 300 DPI document
; 2474 : 		 * don't think it's a problem thought
; 2475 : 		 */
; 2476 : 		m_PDFDoc->displayPage(&FindPage, searchPage,
; 2477 : 			FIND_DPI, FIND_DPI, 0, gFalse, gTrue, gFalse);

	fld	QWORD PTR __real@4052000000000000
	push	0
	push	0
	push	0
	push	1
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	lea	edx, DWORD PTR _FindPage$[esp+428]
	fstp	QWORD PTR [esp]
	push	ebx
	push	edx
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 2478 : 
; 2479 : 		if (!FindPage.isOk()) {

	cmp	DWORD PTR _FindPage$[esp+520], 0
	jne	SHORT $LN12@FindFirst

; 2480 : //			AfxMessageBox("Error al mostrar la pagina");
; 2481 : 			delete [] ucstring;

	mov	eax, DWORD PTR _ucstring$190356[esp+388]
	push	eax
$LN80@FindFirst:
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 2482 : 			return -1;

	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
	or	eax, -1
	jmp	$LN18@FindFirst
$LN12@FindFirst:

; 2483 : 		}
; 2484 : 		m_searchWholeWord = WholeWord;

	mov	cl, BYTE PTR _WholeWord$[ebp]
	mov	BYTE PTR [esi+152], cl
$LL11@FindFirst:

; 2485 : 		//Mientras haya que hacer
; 2486 : 		while(true) {
; 2487 : 			
; 2488 : 			if(WholeWord){

	cmp	BYTE PTR _WholeWord$[ebp], 0
	je	SHORT $LN9@FindFirst

; 2489 : 				//Make a whole word search!
; 2490 : 				rc = FindPage.findTextWholeWord(ucstring, length,
; 2491 : 					startAtTop, gTrue, startAtLast, gFalse,
; 2492 : 					(m_bCaseSensitive?gTrue:gFalse), backward,
; 2493 : 					&x0, &y0, &x1, &y1);

	lea	edx, DWORD PTR _y1$[esp+388]
	push	edx
	lea	eax, DWORD PTR _x1$[esp+392]
	push	eax
	xor	eax, eax
	cmp	BYTE PTR [esi+545], al
	lea	ecx, DWORD PTR _y0$[esp+396]
	push	ecx
	mov	ecx, DWORD PTR _length$[esp+400]
	setne	al
	lea	edx, DWORD PTR _x0$[esp+400]
	push	edx
	mov	edx, DWORD PTR _ucstring$190356[esp+404]
	push	edi
	push	eax
	push	0
	push	0
	push	1
	push	1
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _FindPage$[esp+436]
	call	?findTextWholeWord@TextOutputDev@@QAEHPAIHHHHHHHPAN111@Z ; TextOutputDev::findTextWholeWord

; 2494 : 			}else{

	jmp	SHORT $LN8@FindFirst
$LN9@FindFirst:

; 2495 : 				//Buscar el texto
; 2496 : 				rc = FindPage.findText(ucstring, length,
; 2497 : 					startAtTop, gTrue, startAtLast, gFalse,
; 2498 : 					(m_bCaseSensitive?gTrue:gFalse), backward,
; 2499 : 					&x0, &y0, &x1, &y1);

	lea	eax, DWORD PTR _y1$[esp+388]
	push	eax
	lea	ecx, DWORD PTR _x1$[esp+392]
	push	ecx
	xor	ecx, ecx
	cmp	BYTE PTR [esi+545], cl
	lea	edx, DWORD PTR _y0$[esp+396]
	push	edx
	mov	edx, DWORD PTR _length$[esp+400]
	setne	cl
	lea	eax, DWORD PTR _x0$[esp+400]
	push	eax
	mov	eax, DWORD PTR _ucstring$190356[esp+404]
	push	edi
	push	ecx
	push	0
	push	0
	push	1
	push	1
	push	edx
	push	eax
	lea	ecx, DWORD PTR _FindPage$[esp+436]
	call	?findText@TextOutputDev@@QAEHPAIHHHHHHHPAN111@Z ; TextOutputDev::findText
$LN8@FindFirst:

; 2500 : 			}
; 2501 : 			//Si existen resultados, agregamos esta coincidencia a la lista
; 2502 : 			if (rc) {

	test	eax, eax
	jne	SHORT $LN70@FindFirst

; 2507 : 				break;
; 2508 : 			}
; 2509 : 
; 2510 : 			// Ir a la siguiente pagina
; 2511 : 			startAtTop = gTrue;
; 2512 : 			startAtLast = gFalse;
; 2513 : 
; 2514 : 			if (backward)	//Buscar hacia atras

	test	edi, edi
	je	SHORT $LN6@FindFirst

; 2515 : 				searchPage--;

	dec	ebx

; 2516 : 			else

	jmp	SHORT $LN5@FindFirst
$LN6@FindFirst:

; 2517 : 				searchPage++;

	inc	ebx
$LN5@FindFirst:

; 2518 : 
; 2519 : 			//Si ya no hay paginas para buscar
; 2520 : 			if (searchPage < 1 || searchPage > m_PDFDoc->getNumPages()) {

	cmp	ebx, 1
	jl	$LN78@FindFirst
	mov	ecx, DWORD PTR [esi+332]
	mov	edx, DWORD PTR [ecx+28]
	cmp	ebx, DWORD PTR [edx+12]
	jg	$LN78@FindFirst

; 2521 : 				/*delete [] ucstring;
; 2522 : 				m_SearchPage=iFirstPageFound;
; 2523 : 				return m_Selection.GetCount();
; 2524 : 				*/
; 2525 : 				break;
; 2526 : 			}
; 2527 : 			//Dibujar la siguiente pagina
; 2528 : 			m_PDFDoc->displayPage(&FindPage, searchPage,
; 2529 : 				FIND_DPI, FIND_DPI, 0, gFalse, gTrue, gFalse);

	fld	QWORD PTR __real@4052000000000000
	push	0
	push	0
	push	0
	push	1
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	lea	eax, DWORD PTR _FindPage$[esp+428]
	fstp	QWORD PTR [esp]
	push	ebx
	push	eax
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 2530 : 
; 2531 : 			if (!FindPage.isOk()) {

	cmp	DWORD PTR _FindPage$[esp+520], 0
	jne	$LL11@FindFirst

; 2532 : //				AfxMessageBox("Error al mostrar la pagina");
; 2533 : 				delete [] ucstring;

	mov	ecx, DWORD PTR _ucstring$190356[esp+388]
	push	ecx

; 2534 : 				return -1;	//No hay resultados

	jmp	$LN80@FindFirst
$LN70@FindFirst:

; 2503 : 				m_Selection.Add(CPDFSearchResult(CRect((int)x0, (int)y0, (int)x1, (int)y1),searchPage));

	fld	QWORD PTR _y1$[esp+388]
	call	__ftol2_sse
	fld	QWORD PTR _x1$[esp+388]
	mov	edi, eax
	mov	DWORD PTR $T190432[esp+388], edi
	call	__ftol2_sse
	fld	QWORD PTR _y0$[esp+388]
	mov	DWORD PTR $T190431[esp+388], eax
	call	__ftol2_sse
	fld	QWORD PTR _x0$[esp+388]
	mov	DWORD PTR $T190430[esp+388], eax
	call	__ftol2_sse
	mov	edx, DWORD PTR $T190431[esp+388]
	sub	edi, DWORD PTR $T190430[esp+388]
	push	ebx
	sub	edx, eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR $T190430[esp+416]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR $T190431[esp+416]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR $T190432[esp+416]
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], edx
	lea	eax, DWORD PTR $T190341[esp+416]
	mov	DWORD PTR [ecx+20], edi
	call	??0CPDFSearchResult@@QAE@VCRect@@J@Z	; CPDFSearchResult::CPDFSearchResult
	push	eax
	lea	eax, DWORD PTR [esi+320]
	call	?Add@?$DynArray@VCPDFSearchResult@@@@QAEXABVCPDFSearchResult@@@Z ; DynArray<CPDFSearchResult>::Add

; 2504 : 				__x0=x0;

	fld	QWORD PTR _x0$[esp+388]
	fstp	QWORD PTR [esi+464]

; 2505 : 				__y0=y0;
; 2506 : 				iFirstPageFound =searchPage;

	mov	eax, ebx
	fld	QWORD PTR _y0$[esp+388]
	fstp	QWORD PTR [esi+472]

; 2535 : 			}
; 2536 : 		}
; 2537 : 		if(iFirstPageFound>0)

	test	ebx, ebx
	jle	SHORT $LN1@FindFirst

; 2538 : 			m_SearchStarted=true;

	mov	BYTE PTR [esi+546], 1
	jmp	SHORT $LN1@FindFirst
$LN78@FindFirst:
	mov	eax, DWORD PTR _iFirstPageFound$[esp+388]
$LN1@FindFirst:

; 2539 : 		
; 2540 : 		//Establecer la pagina de busqueda en la primer pagina
; 2541 : 		m_SearchPage=iFirstPageFound;
; 2542 : 		delete [] ucstring;

	mov	edx, DWORD PTR _ucstring$190356[esp+388]
	push	edx
	mov	DWORD PTR [esi+512], eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 2543 : 		return m_Selection.GetCount();

	mov	esi, DWORD PTR [esi+324]
	add	esp, 4
	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
	mov	eax, esi
$LN18@FindFirst:

; 2544 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z$0:
	lea	ecx, DWORD PTR _FindPage$[ebp]
	jmp	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
__unwindfunclet$?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z$1:
	lea	ecx, DWORD PTR _theString$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
__ehhandler$?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-372]
	mov	ecx, DWORD PTR [edx-376]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindFirst@AFPDFDoc@@QAEJPB_WJ_N1@Z ENDP		; AFPDFDoc::FindFirst
PUBLIC	__$ArrayPad$
PUBLIC	?FindPrior@AFPDFDoc@@QAEJPB_W@Z			; AFPDFDoc::FindPrior
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\dynarray.h
xdata$x	SEGMENT
__unwindtable$?FindPrior@AFPDFDoc@@QAEJPB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPrior@AFPDFDoc@@QAEJPB_W@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FindPrior@AFPDFDoc@@QAEJPB_W@Z$1
__ehfuncinfo$?FindPrior@AFPDFDoc@@QAEJPB_W@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindPrior@AFPDFDoc@@QAEJPB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?FindPrior@AFPDFDoc@@QAEJPB_W@Z
_TEXT	SEGMENT
$T190512 = -316						; size = 4
_length$ = -316						; size = 4
_searchPage$ = -312					; size = 4
$T190513 = -308						; size = 4
_y0$ = -304						; size = 8
_x0$ = -296						; size = 8
$T190514 = -284						; size = 4
_x1$ = -280						; size = 8
_y1$ = -272						; size = 8
_FindPage$ = -264					; size = 136
$T190481 = -124						; size = 28
_theString$ = -96					; size = 28
__$ArrayPad$ = -68					; size = 4
__$EHRec$ = -12						; size = 12
?FindPrior@AFPDFDoc@@QAEJPB_W@Z PROC			; AFPDFDoc::FindPrior, COMDAT
; _this$ = ecx
; _sText$ = edx

; 2303 : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$?FindPrior@AFPDFDoc@@QAEJPB_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+372], eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 2304 : 		
; 2305 : 
; 2306 : 		if (!m_SearchStarted)

	cmp	BYTE PTR [ebx+546], 0
	mov	edi, edx

; 2307 : 			return 0;

	je	$LN47@FindPrior

; 2308 : 
; 2309 : 		//Comenzar desde donde se quedo la ultima bsqueda
; 2310 : 		double x0=__x0, y0=__y0, x1, y1;

	fld	QWORD PTR [ebx+464]

; 2311 : 		long iFirstPageFound=0, searchPage=0;
; 2312 : 		searchPage=m_SearchPage;

	mov	eax, DWORD PTR [ebx+512]

; 2313 : 		GBool rc, startAtTop, startAtLast;
; 2314 : 		Unicode * ucstring;
; 2315 : 		TextOutputDev FindPage(NULL, gTrue, gFalse, gFalse);

	push	0
	fstp	QWORD PTR _x0$[esp+392]
	fld	QWORD PTR [ebx+472]
	push	0
	push	1
	fstp	QWORD PTR _y0$[esp+400]
	push	0
	lea	ecx, DWORD PTR _FindPage$[esp+404]
	mov	DWORD PTR _searchPage$[esp+404], eax
	call	??0TextOutputDev@@QAE@PADHHH@Z		; TextOutputDev::TextOutputDev

; 2316 : 
; 2317 : #ifdef PDFLIBNET_ORIGINAL
; 2318 : 		CString theString(sText);
; 2319 : 		int length = theString.GetLength();
; 2320 : #else
; 2321 : 		std::basic_string<wchar_t> theString(sText);

	push	edi
	lea	ecx, DWORD PTR _theString$[esp+392]
	mov	DWORD PTR __$EHRec$[esp+400], 0
	call	DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
	mov	BYTE PTR __$EHRec$[esp+396], 1

; 2322 : 		int length = theString.size();

	mov	esi, DWORD PTR _theString$[esp+408]
	mov	DWORD PTR _length$[esp+388], esi

; 2323 : #endif
; 2324 : 		
; 2325 : 		//Tratar de reservar la cadena
; 2326 : 		ucstring = GetUnicodeString(sText, length);

	call	?GetUnicodeString@@YAPAIPB_WH@Z		; GetUnicodeString
	mov	edi, eax

; 2327 : 		if (ucstring == NULL) {

	xor	esi, esi
	cmp	edi, esi
	jne	SHORT $LN11@FindPrior

; 2328 : //			AfxMessageBox("Out of memory");
; 2329 : 			return FALSE;

	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
$LN47@FindPrior:
	xor	eax, eax
	jmp	$LN13@FindPrior
$LN11@FindPrior:

; 2330 : 		}
; 2331 : 		//Comenzar en xMin, yMin
; 2332 : 		startAtTop = gFalse;
; 2333 : 		startAtLast = gFalse;
; 2334 : 		m_SearchStarted = FALSE;

	mov	BYTE PTR [ebx+546], 0

; 2335 : 		m_Selection.RemoveAll();

	mov	ecx, DWORD PTR [ebx+320]
	push	3584					; 00000e00H
	push	ecx
	mov	DWORD PTR [ebx+324], esi
	call	DWORD PTR __imp__realloc

; 2336 : 		
; 2337 : 		/* use fixed DPI and rotation, this would lead to somehwere
; 2338 : 		 * wrong positioning displaying more than 300 DPI document
; 2339 : 		 * don't think it's a problem thought
; 2340 : 		 */
; 2341 : 		m_PDFDoc->displayPage(&FindPage, searchPage,
; 2342 : 			FIND_DPI, FIND_DPI, 0, gFalse, gTrue, gFalse);

	fld	QWORD PTR __real@4052000000000000
	mov	edx, DWORD PTR _searchPage$[esp+396]
	add	esp, 8
	push	0
	push	0
	push	0
	push	1
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	mov	DWORD PTR [ebx+320], eax
	fstp	QWORD PTR [esp]
	push	edx
	lea	eax, DWORD PTR _FindPage$[esp+432]
	mov	DWORD PTR [ebx+328], 128		; 00000080H
	mov	ecx, DWORD PTR [ebx+332]
	push	eax
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 2343 : 
; 2344 : 		if (!FindPage.isOk()) {

	cmp	DWORD PTR _FindPage$[esp+520], esi
$LN48@FindPrior:
	jne	SHORT $LL9@FindPrior

; 2345 : //			AfxMessageBox("Error al mostrar la pagina");
; 2346 : 			delete [] ucstring;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 2347 : 			return -1;

	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
	or	eax, -1
	jmp	$LN13@FindPrior
	npad	11
$LL9@FindPrior:

; 2348 : 		}
; 2349 : 
; 2350 : 		//Mientras haya que hacer
; 2351 : 		while(true) {
; 2352 : 			if(m_searchWholeWord){

	cmp	BYTE PTR [ebx+152], 0

; 2353 : 				//Buscar el texto
; 2354 : 				rc = FindPage.findTextWholeWord(ucstring, length,
; 2355 : 					startAtTop, gTrue, startAtLast, gFalse,
; 2356 : 					m_bCaseSensitive,gTrue,
; 2357 : 					&x0, &y0, &x1, &y1);

	lea	ecx, DWORD PTR _y1$[esp+388]
	push	ecx
	lea	edx, DWORD PTR _x1$[esp+392]
	push	edx
	movzx	edx, BYTE PTR [ebx+545]
	lea	eax, DWORD PTR _y0$[esp+396]
	push	eax
	mov	eax, DWORD PTR _length$[esp+400]
	lea	ecx, DWORD PTR _x0$[esp+400]
	push	ecx
	push	1
	push	edx
	push	0
	push	0
	push	1
	push	esi
	push	eax
	lea	ecx, DWORD PTR _FindPage$[esp+432]
	push	edi
	je	SHORT $LN7@FindPrior
	call	?findTextWholeWord@TextOutputDev@@QAEHPAIHHHHHHHPAN111@Z ; TextOutputDev::findTextWholeWord

; 2358 : 			}else{

	jmp	SHORT $LN6@FindPrior
$LN7@FindPrior:

; 2359 : 				//Buscar el texto
; 2360 : 				rc = FindPage.findText(ucstring, length,
; 2361 : 					startAtTop, gTrue, startAtLast, gFalse,
; 2362 : 					m_bCaseSensitive,gTrue,
; 2363 : 					&x0, &y0, &x1, &y1);

	call	?findText@TextOutputDev@@QAEHPAIHHHHHHHPAN111@Z ; TextOutputDev::findText
$LN6@FindPrior:

; 2364 : 			}
; 2365 : 
; 2366 : 			//Si existen resultados, agregamos esta coincidencia a la lista
; 2367 : 			if (rc) {

	test	eax, eax
	jne	SHORT $LN42@FindPrior

; 2371 : 				__y0=y0;
; 2372 : 				iFirstPageFound =searchPage;
; 2373 : 				break;
; 2374 : 			}else{
; 2375 : 				// Ir a la pagina sigueinte
; 2376 : 				startAtTop = gTrue;

	lea	esi, DWORD PTR [eax+1]

; 2377 : 				startAtLast = gFalse;
; 2378 : 				searchPage--;	

	mov	eax, DWORD PTR _searchPage$[esp+388]
	dec	eax

; 2379 : 				//Si ya no hay paginas para buscar
; 2380 : 				if (searchPage < 1 || searchPage > m_PDFDoc->getNumPages()) {

	cmp	eax, esi
	mov	DWORD PTR _searchPage$[esp+388], eax
	jl	$LN2@FindPrior
	mov	ecx, DWORD PTR [ebx+332]
	mov	edx, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+12]
	jg	$LN2@FindPrior

; 2384 : 				}
; 2385 : 				//Dibujar la siguiente pagina
; 2386 : 				m_PDFDoc->displayPage(&FindPage, searchPage,
; 2387 : 					FIND_DPI, FIND_DPI, 0, gFalse, gTrue, gFalse);

	fld	QWORD PTR __real@4052000000000000
	push	0
	push	0
	push	0
	push	esi
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	eax
	lea	eax, DWORD PTR _FindPage$[esp+432]
	push	eax
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 2388 : 				//Si no se mostro correctamente, salir
; 2389 : 				if (!FindPage.isOk()) {

	cmp	DWORD PTR _FindPage$[esp+520], 0

; 2390 : //					AfxMessageBox("Error al mostrar la pagina");
; 2391 : 					delete [] ucstring;
; 2392 : 					return -1;	//No hay resultados
; 2393 : 				}
; 2394 : 			}
; 2395 : 		}

	jmp	$LN48@FindPrior
$LN42@FindPrior:

; 2368 : 				m_Selection.Add(CPDFSearchResult(CRect((int)x0, (int)y0, (int)x1, (int)y1),searchPage));

	fld	QWORD PTR _y1$[esp+388]
	call	__ftol2_sse
	fld	QWORD PTR _x1$[esp+388]
	mov	esi, eax
	mov	DWORD PTR $T190514[esp+388], esi
	call	__ftol2_sse
	fld	QWORD PTR _y0$[esp+388]
	mov	DWORD PTR $T190513[esp+388], eax
	call	__ftol2_sse
	fld	QWORD PTR _x0$[esp+388]
	mov	DWORD PTR $T190512[esp+388], eax
	call	__ftol2_sse
	mov	ecx, DWORD PTR _searchPage$[esp+388]
	mov	edx, DWORD PTR $T190513[esp+388]
	sub	esi, DWORD PTR $T190512[esp+388]
	push	ecx
	sub	edx, eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR $T190512[esp+416]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR $T190513[esp+416]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR $T190514[esp+416]
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], edx
	lea	eax, DWORD PTR $T190481[esp+416]
	mov	DWORD PTR [ecx+20], esi
	call	??0CPDFSearchResult@@QAE@VCRect@@J@Z	; CPDFSearchResult::CPDFSearchResult
	push	eax
	lea	eax, DWORD PTR [ebx+320]
	call	?Add@?$DynArray@VCPDFSearchResult@@@@QAEXABVCPDFSearchResult@@@Z ; DynArray<CPDFSearchResult>::Add

; 2369 : 				//La primer pagina en donde se encontro
; 2370 : 				__x0=x0;

	fld	QWORD PTR _x0$[esp+388]

; 2396 : 		
; 2397 : 		
; 2398 : 		//Establecer la pagina de busqueda en la primer ocurrencia
; 2399 : 		m_SearchPage=iFirstPageFound;

	mov	ecx, DWORD PTR _searchPage$[esp+388]
	fstp	QWORD PTR [ebx+464]
	fld	QWORD PTR _y0$[esp+388]

; 2400 : 		m_SearchStarted = true;
; 2401 : 		delete [] ucstring;

	push	edi
	fstp	QWORD PTR [ebx+472]
	mov	DWORD PTR [ebx+512], ecx
	mov	BYTE PTR [ebx+546], 1
	call	??_V@YAXPAX@Z				; operator delete[]

; 2402 : 		return m_Selection.GetCount();

	jmp	SHORT $LN46@FindPrior
$LN2@FindPrior:

; 2381 : 					delete [] ucstring;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]

; 2382 : 					m_SearchPage=iFirstPageFound;

	mov	DWORD PTR [ebx+512], 0
$LN46@FindPrior:

; 2383 : 					return m_Selection.GetCount();

	mov	ebx, DWORD PTR [ebx+324]
	add	esp, 4
	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
	mov	eax, ebx
$LN13@FindPrior:

; 2403 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindPrior@AFPDFDoc@@QAEJPB_W@Z$0:
	lea	ecx, DWORD PTR _FindPage$[ebp]
	jmp	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
__unwindfunclet$?FindPrior@AFPDFDoc@@QAEJPB_W@Z$1:
	lea	ecx, DWORD PTR _theString$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
__ehhandler$?FindPrior@AFPDFDoc@@QAEJPB_W@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-372]
	mov	ecx, DWORD PTR [edx-376]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindPrior@AFPDFDoc@@QAEJPB_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindPrior@AFPDFDoc@@QAEJPB_W@Z ENDP			; AFPDFDoc::FindPrior
PUBLIC	__$ArrayPad$
PUBLIC	?FindNext@AFPDFDoc@@QAEJPB_W@Z			; AFPDFDoc::FindNext
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\dynarray.h
xdata$x	SEGMENT
__unwindtable$?FindNext@AFPDFDoc@@QAEJPB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindNext@AFPDFDoc@@QAEJPB_W@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FindNext@AFPDFDoc@@QAEJPB_W@Z$1
__ehfuncinfo$?FindNext@AFPDFDoc@@QAEJPB_W@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindNext@AFPDFDoc@@QAEJPB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?FindNext@AFPDFDoc@@QAEJPB_W@Z
_TEXT	SEGMENT
$T190598 = -316						; size = 4
_length$ = -316						; size = 4
_searchPage$ = -312					; size = 4
$T190599 = -308						; size = 4
_y0$ = -304						; size = 8
_x0$ = -296						; size = 8
$T190600 = -284						; size = 4
_x1$ = -280						; size = 8
_y1$ = -272						; size = 8
_FindPage$ = -264					; size = 136
$T190567 = -124						; size = 28
_theString$ = -96					; size = 28
__$ArrayPad$ = -68					; size = 4
__$EHRec$ = -12						; size = 12
?FindNext@AFPDFDoc@@QAEJPB_W@Z PROC			; AFPDFDoc::FindNext, COMDAT
; _this$ = ecx
; _sText$ = edx

; 2199 : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$?FindNext@AFPDFDoc@@QAEJPB_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+372], eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 2200 : 		
; 2201 : 
; 2202 : 		if (!m_SearchStarted)

	cmp	BYTE PTR [ebx+546], 0
	mov	edi, edx

; 2203 : 			return 0;

	je	$LN47@FindNext

; 2204 : 
; 2205 : 		//Comenzar desde donde se quedo la ultima bsqueda
; 2206 : 		double x0=__x0, y0=__y0, x1, y1;

	fld	QWORD PTR [ebx+464]

; 2207 : 		long iFirstPageFound=0, searchPage=0;
; 2208 : 		searchPage=m_SearchPage;

	mov	eax, DWORD PTR [ebx+512]

; 2209 : 		GBool rc, startAtTop, startAtLast;
; 2210 : 		Unicode * ucstring;
; 2211 : 		TextOutputDev FindPage(NULL, gTrue, gFalse, gFalse);

	push	0
	fstp	QWORD PTR _x0$[esp+392]
	fld	QWORD PTR [ebx+472]
	push	0
	push	1
	fstp	QWORD PTR _y0$[esp+400]
	push	0
	lea	ecx, DWORD PTR _FindPage$[esp+404]
	mov	DWORD PTR _searchPage$[esp+404], eax
	call	??0TextOutputDev@@QAE@PADHHH@Z		; TextOutputDev::TextOutputDev

; 2212 : 
; 2213 : #ifdef PDFLIBNET_ORIGINAL
; 2214 : 		CString theString(sText);
; 2215 : 		int length = theString.GetLength();
; 2216 : #else
; 2217 : 		std::basic_string<wchar_t> theString(sText);

	push	edi
	lea	ecx, DWORD PTR _theString$[esp+392]
	mov	DWORD PTR __$EHRec$[esp+400], 0
	call	DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
	mov	BYTE PTR __$EHRec$[esp+396], 1

; 2218 : 		int length = theString.size();

	mov	esi, DWORD PTR _theString$[esp+408]
	mov	DWORD PTR _length$[esp+388], esi

; 2219 : #endif
; 2220 : 		
; 2221 : 		//Tratar de reservar la cadena
; 2222 : 		ucstring = GetUnicodeString(sText, length);

	call	?GetUnicodeString@@YAPAIPB_WH@Z		; GetUnicodeString
	mov	edi, eax

; 2223 : 		if (ucstring == NULL) {

	xor	esi, esi
	cmp	edi, esi
	jne	SHORT $LN11@FindNext

; 2224 : //			AfxMessageBox("Out of memory");
; 2225 : 			return FALSE;

	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
$LN47@FindNext:
	xor	eax, eax
	jmp	$LN13@FindNext
$LN11@FindNext:

; 2226 : 		}
; 2227 : 		//Comenzar en xMin, yMin
; 2228 : 		startAtTop = gFalse;
; 2229 : 		startAtLast = gFalse;
; 2230 : 		m_SearchStarted = FALSE;

	mov	BYTE PTR [ebx+546], 0

; 2231 : 		m_Selection.RemoveAll();

	mov	ecx, DWORD PTR [ebx+320]
	push	3584					; 00000e00H
	push	ecx
	mov	DWORD PTR [ebx+324], esi
	call	DWORD PTR __imp__realloc

; 2232 : 		
; 2233 : 		/* use fixed DPI and rotation, this would lead to somehwere
; 2234 : 		 * wrong positioning displaying more than 300 DPI document
; 2235 : 		 * don't think it's a problem thought
; 2236 : 		 */
; 2237 : 		m_PDFDoc->displayPage(&FindPage, searchPage,
; 2238 : 			FIND_DPI, FIND_DPI, 0, gFalse, gTrue, gFalse);

	fld	QWORD PTR __real@4052000000000000
	mov	edx, DWORD PTR _searchPage$[esp+396]
	add	esp, 8
	push	0
	push	0
	push	0
	push	1
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	mov	DWORD PTR [ebx+320], eax
	fstp	QWORD PTR [esp]
	push	edx
	lea	eax, DWORD PTR _FindPage$[esp+432]
	mov	DWORD PTR [ebx+328], 128		; 00000080H
	mov	ecx, DWORD PTR [ebx+332]
	push	eax
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 2239 : 
; 2240 : 		if (!FindPage.isOk()) {

	cmp	DWORD PTR _FindPage$[esp+520], esi
$LN48@FindNext:
	jne	SHORT $LL9@FindNext

; 2241 : //			AfxMessageBox("Error al mostrar la pagina");
; 2242 : 			delete [] ucstring;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 2243 : 			return -1;

	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
	or	eax, -1
	jmp	$LN13@FindNext
	npad	11
$LL9@FindNext:

; 2244 : 		}
; 2245 : 
; 2246 : 		//Mientras haya que hacer
; 2247 : 		while(true) {
; 2248 : 			if(m_searchWholeWord){

	cmp	BYTE PTR [ebx+152], 0

; 2249 : 					//Buscar el texto
; 2250 : 				rc = FindPage.findTextWholeWord(ucstring, length,
; 2251 : 					startAtTop, gTrue, startAtLast, gFalse,
; 2252 : 					m_bCaseSensitive, gFalse,
; 2253 : 					&x0, &y0, &x1, &y1);

	lea	ecx, DWORD PTR _y1$[esp+388]
	push	ecx
	lea	edx, DWORD PTR _x1$[esp+392]
	push	edx
	movzx	edx, BYTE PTR [ebx+545]
	lea	eax, DWORD PTR _y0$[esp+396]
	push	eax
	mov	eax, DWORD PTR _length$[esp+400]
	lea	ecx, DWORD PTR _x0$[esp+400]
	push	ecx
	push	0
	push	edx
	push	0
	push	0
	push	1
	push	esi
	push	eax
	lea	ecx, DWORD PTR _FindPage$[esp+432]
	push	edi
	je	SHORT $LN7@FindNext
	call	?findTextWholeWord@TextOutputDev@@QAEHPAIHHHHHHHPAN111@Z ; TextOutputDev::findTextWholeWord

; 2254 : 			}else{

	jmp	SHORT $LN6@FindNext
$LN7@FindNext:

; 2255 : 
; 2256 : 				//Buscar el texto
; 2257 : 				rc = FindPage.findText(ucstring, length,
; 2258 : 					startAtTop, gTrue, startAtLast, gFalse,
; 2259 : 					m_bCaseSensitive, gFalse,
; 2260 : 					&x0, &y0, &x1, &y1);

	call	?findText@TextOutputDev@@QAEHPAIHHHHHHHPAN111@Z ; TextOutputDev::findText
$LN6@FindNext:

; 2261 : 			}
; 2262 : 
; 2263 : 			//Si existen resultados, agregamos esta coincidencia a la lista
; 2264 : 			if (rc) {

	test	eax, eax
	jne	SHORT $LN42@FindNext

; 2268 : 				__y0=y0;
; 2269 : 				iFirstPageFound =searchPage;
; 2270 : 				break;
; 2271 : 			}else{
; 2272 : 				// Ir a la pagina sigueinte
; 2273 : 				startAtTop = gTrue;

	lea	esi, DWORD PTR [eax+1]

; 2274 : 				startAtLast = gFalse;
; 2275 : 				searchPage++;	

	mov	eax, DWORD PTR _searchPage$[esp+388]
	inc	eax

; 2276 : 				//Si ya no hay paginas para buscar
; 2277 : 				if (searchPage < 1 || searchPage > m_PDFDoc->getNumPages()) {

	cmp	eax, esi
	mov	DWORD PTR _searchPage$[esp+388], eax
	jl	$LN2@FindNext
	mov	ecx, DWORD PTR [ebx+332]
	mov	edx, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+12]
	jg	$LN2@FindNext

; 2281 : 				}
; 2282 : 				//Dibujar la siguiente pagina
; 2283 : 				m_PDFDoc->displayPage(&FindPage, searchPage,
; 2284 : 					FIND_DPI, FIND_DPI, 0, gFalse, gTrue, gFalse);

	fld	QWORD PTR __real@4052000000000000
	push	0
	push	0
	push	0
	push	esi
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	eax
	lea	eax, DWORD PTR _FindPage$[esp+432]
	push	eax
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 2285 : 				//Si no se mostro correctamente, salir
; 2286 : 				if (!FindPage.isOk()) {

	cmp	DWORD PTR _FindPage$[esp+520], 0

; 2287 : //					AfxMessageBox("Error al mostrar la pagina");
; 2288 : 					delete [] ucstring;
; 2289 : 					return -1;	//No hay resultados
; 2290 : 				}
; 2291 : 			}
; 2292 : 		}

	jmp	$LN48@FindNext
$LN42@FindNext:

; 2265 : 				m_Selection.Add(CPDFSearchResult(CRect((int)x0, (int)y0, (int)x1, (int)y1),searchPage));

	fld	QWORD PTR _y1$[esp+388]
	call	__ftol2_sse
	fld	QWORD PTR _x1$[esp+388]
	mov	esi, eax
	mov	DWORD PTR $T190600[esp+388], esi
	call	__ftol2_sse
	fld	QWORD PTR _y0$[esp+388]
	mov	DWORD PTR $T190599[esp+388], eax
	call	__ftol2_sse
	fld	QWORD PTR _x0$[esp+388]
	mov	DWORD PTR $T190598[esp+388], eax
	call	__ftol2_sse
	mov	ecx, DWORD PTR _searchPage$[esp+388]
	mov	edx, DWORD PTR $T190599[esp+388]
	sub	esi, DWORD PTR $T190598[esp+388]
	push	ecx
	sub	edx, eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR $T190598[esp+416]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR $T190599[esp+416]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR $T190600[esp+416]
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], edx
	lea	eax, DWORD PTR $T190567[esp+416]
	mov	DWORD PTR [ecx+20], esi
	call	??0CPDFSearchResult@@QAE@VCRect@@J@Z	; CPDFSearchResult::CPDFSearchResult
	push	eax
	lea	eax, DWORD PTR [ebx+320]
	call	?Add@?$DynArray@VCPDFSearchResult@@@@QAEXABVCPDFSearchResult@@@Z ; DynArray<CPDFSearchResult>::Add

; 2266 : 				//La primer pagina en donde se encontro
; 2267 : 				__x0=x0;

	fld	QWORD PTR _x0$[esp+388]

; 2293 : 		
; 2294 : 		
; 2295 : 		//Establecer la pagina de busqueda en la primer ocurrencia
; 2296 : 		m_SearchPage=iFirstPageFound;

	mov	ecx, DWORD PTR _searchPage$[esp+388]
	fstp	QWORD PTR [ebx+464]
	fld	QWORD PTR _y0$[esp+388]

; 2297 : 		m_SearchStarted = true;
; 2298 : 		delete [] ucstring;

	push	edi
	fstp	QWORD PTR [ebx+472]
	mov	DWORD PTR [ebx+512], ecx
	mov	BYTE PTR [ebx+546], 1
	call	??_V@YAXPAX@Z				; operator delete[]

; 2299 : 		return m_Selection.GetCount();

	jmp	SHORT $LN46@FindNext
$LN2@FindNext:

; 2278 : 					delete [] ucstring;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]

; 2279 : 					m_SearchPage=iFirstPageFound;

	mov	DWORD PTR [ebx+512], 0
$LN46@FindNext:

; 2280 : 					return m_Selection.GetCount();

	mov	ebx, DWORD PTR [ebx+324]
	add	esp, 4
	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
	mov	eax, ebx
$LN13@FindNext:

; 2300 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindNext@AFPDFDoc@@QAEJPB_W@Z$0:
	lea	ecx, DWORD PTR _FindPage$[ebp]
	jmp	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
__unwindfunclet$?FindNext@AFPDFDoc@@QAEJPB_W@Z$1:
	lea	ecx, DWORD PTR _theString$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
__ehhandler$?FindNext@AFPDFDoc@@QAEJPB_W@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-372]
	mov	ecx, DWORD PTR [edx-376]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindNext@AFPDFDoc@@QAEJPB_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindNext@AFPDFDoc@@QAEJPB_W@Z ENDP			; AFPDFDoc::FindNext
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z	; AFPDFDoc::FindTextA
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\dynarray.h
xdata$x	SEGMENT
__unwindtable$?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z$1
__ehfuncinfo$?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z
_TEXT	SEGMENT
_searchPage$ = -316					; size = 4
_this$GSCopy$ = -312					; size = 4
_ucstring$190672 = -308					; size = 4
_iFirstPageFound$ = -304				; size = 4
_length$ = -300						; size = 4
_y1$ = -296						; size = 8
_x0$ = -288						; size = 8
_y0$ = -280						; size = 8
_x1$ = -272						; size = 8
$T190653 = -260						; size = 28
_FindPage$ = -232					; size = 136
_theString$ = -96					; size = 28
__$ArrayPad$ = -68					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_iPage$ = 12						; size = 4
_SearchOrder$ = 16					; size = 4
_bCaseSensitive$ = 20					; size = 1
_bBackward$ = 24					; size = 1
_bWholeDoc$ = 28					; size = 1
_bWholeWord$ = 32					; size = 1
_stopOnFirstPageResults$ = 36				; size = 1
?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z PROC		; AFPDFDoc::FindTextA, COMDAT
; _sText$ = ecx

; 2083 : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+372], eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, eax

; 2127 : 
; 2128 : 		if (!FindPage.isOk()) {

	mov	eax, DWORD PTR _this$[ebp]
	xor	esi, esi
	push	esi
	push	esi
	push	1
	mov	edi, ecx
	push	esi
	lea	ecx, DWORD PTR _FindPage$[esp+404]
	mov	DWORD PTR _this$GSCopy$[esp+404], eax
	mov	DWORD PTR _iFirstPageFound$[esp+404], esi
	call	??0TextOutputDev@@QAE@PADHHH@Z		; TextOutputDev::TextOutputDev
	push	edi
	lea	ecx, DWORD PTR _theString$[esp+392]
	mov	DWORD PTR __$EHRec$[esp+400], esi
	call	DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
	mov	BYTE PTR __$EHRec$[esp+396], 1
	mov	eax, DWORD PTR _theString$[esp+408]
	mov	ebx, eax
	xor	ecx, ecx
	inc	eax
	mov	edx, 4
	mul	edx
	seto	cl
	mov	DWORD PTR _length$[esp+388], ebx
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _ucstring$190672[esp+388], esi
	test	esi, esi
	je	SHORT $LN77@FindTextA
	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN27@FindTextA

; 2084 : 		
; 2085 : 
; 2086 : 		double x0, y0, x1, y1;
; 2087 : 		long iFirstPageFound=0;
; 2088 : 		long searchPage=0;
; 2089 : 		GBool rc, startAtTop, startAtLast, backward;
; 2090 : 		Unicode * ucstring;
; 2091 : 		TextOutputDev FindPage(NULL, gTrue, gFalse, gFalse);
; 2092 : 		
; 2093 : #ifdef PDFLIBNET_ORIGINAL
; 2094 : 		CString theString(sText);
; 2095 : 		int length = theString.GetLength();
; 2096 : #else
; 2097 : 		std::basic_string<wchar_t> theString(sText);
; 2098 : 		int length = theString.size();
; 2099 : #endif
; 2100 : 		
; 2101 : 		//Tratar de reservar la cadena
; 2102 : 		ucstring = GetUnicodeString(sText, length);

$LL29@FindTextA:
	movzx	ecx, WORD PTR [edi+eax*2]
	mov	DWORD PTR [esi+eax*4], ecx
	inc	eax
	cmp	eax, ebx
	jl	SHORT $LL29@FindTextA
$LN27@FindTextA:
	mov	DWORD PTR [esi+eax*4], 0

; 2106 : 		}
; 2107 : 
; 2108 : 		m_SearchStarted=false;
; 2109 : 		startAtTop = gTrue;
; 2110 : 		startAtLast = gFalse;
; 2111 : 		backward = bBackward; 
; 2112 : 		m_SearchStarted = FALSE;

	mov	eax, DWORD PTR _this$GSCopy$[esp+388]
	xor	ebx, ebx
	mov	BYTE PTR [eax+546], bl

; 2113 : 		m_Selection.RemoveAll();

	mov	edx, DWORD PTR [eax+320]
	push	3584					; 00000e00H
	push	edx
	mov	edi, 1
	mov	DWORD PTR [eax+324], ebx
	call	DWORD PTR __imp__realloc
	mov	ecx, DWORD PTR _this$GSCopy$[esp+396]
	add	esp, 8
	mov	DWORD PTR [ecx+320], eax
	mov	DWORD PTR [ecx+328], 128		; 00000080H

; 2114 : 
; 2115 : 		//Si se desea buscar desde el principio
; 2116 : 		if(SearchOrder==0)

	cmp	DWORD PTR _SearchOrder$[ebp], ebx
	jne	SHORT $LN19@FindTextA

; 2117 : 			searchPage=1;

	mov	DWORD PTR _searchPage$[esp+388], edi

; 2118 : 		else

	jmp	SHORT $LN18@FindTextA
$LN77@FindTextA:

; 2103 : 		if (ucstring == NULL) {
; 2104 : //			AfxMessageBox("Out of memory");
; 2105 : 			return FALSE;

	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
	xor	eax, eax
	jmp	$LN21@FindTextA
$LN19@FindTextA:

; 2119 : 			searchPage=iPage;

	mov	eax, DWORD PTR _iPage$[ebp]
	mov	DWORD PTR _searchPage$[esp+388], eax
$LN18@FindTextA:

; 2120 : 
; 2121 : 		/* use fixed DPI and rotation, this would lead to somehwere
; 2122 : 		 * wrong positioning displaying more than 300 DPI document
; 2123 : 		 * don't think it's a problem thought
; 2124 : 		 */
; 2125 : 		m_PDFDoc->displayPage(&FindPage, searchPage,
; 2126 : 			FIND_DPI, FIND_DPI, 0, gFalse, gTrue, gFalse);

	fld	QWORD PTR __real@4052000000000000
	mov	edx, DWORD PTR _searchPage$[esp+388]
	mov	ecx, DWORD PTR [ecx+332]
	push	0
	push	0
	push	0
	push	1
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	lea	eax, DWORD PTR _FindPage$[esp+428]
	fstp	QWORD PTR [esp]
	push	edx
	push	eax
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 2127 : 
; 2128 : 		if (!FindPage.isOk()) {

	cmp	DWORD PTR _FindPage$[esp+520], ebx
	jne	SHORT $LN16@FindTextA

; 2129 : //			AfxMessageBox("Error al mostrar la pagina");
; 2130 : 			delete [] ucstring;

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 2131 : 			return -1;

	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], bl
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
	or	eax, -1
	jmp	$LN21@FindTextA
$LN16@FindTextA:

; 2132 : 		}
; 2133 : 
; 2134 : 		//Mientras haya que hacer
; 2135 : 		while(true) {
; 2136 : 			//Buscar el texto
; 2137 : 			if(bWholeWord)

	cmp	BYTE PTR _bWholeWord$[ebp], 0

; 2138 : 					rc = FindPage.findTextWholeWord(ucstring, length,
; 2139 : 				startAtTop, gTrue, startAtLast, gFalse,
; 2140 : 				bCaseSensitive, backward,
; 2141 : 				&x0, &y0, &x1, &y1);

	movzx	esi, BYTE PTR _bBackward$[ebp]
	je	SHORT $LN14@FindTextA
	lea	ecx, DWORD PTR _y1$[esp+388]
	push	ecx
	lea	edx, DWORD PTR _x1$[esp+392]
	push	edx
	movzx	edx, BYTE PTR _bCaseSensitive$[ebp]
	lea	eax, DWORD PTR _y0$[esp+396]
	push	eax
	mov	eax, DWORD PTR _length$[esp+400]
	lea	ecx, DWORD PTR _x0$[esp+400]
	push	ecx
	mov	ecx, DWORD PTR _ucstring$190672[esp+404]
	push	esi
	push	edx
	push	0
	push	ebx
	push	1
	push	edi
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _FindPage$[esp+436]
	call	?findTextWholeWord@TextOutputDev@@QAEHPAIHHHHHHHPAN111@Z ; TextOutputDev::findTextWholeWord

; 2142 : 			else

	jmp	SHORT $LN13@FindTextA
$LN14@FindTextA:

; 2143 : 				rc = FindPage.findText(ucstring, length,
; 2144 : 					startAtTop, gTrue, startAtLast, gFalse,
; 2145 : 					bCaseSensitive, backward,
; 2146 : 					&x0, &y0, &x1, &y1);

	lea	edx, DWORD PTR _y1$[esp+388]
	push	edx
	lea	eax, DWORD PTR _x1$[esp+392]
	push	eax
	movzx	eax, BYTE PTR _bCaseSensitive$[ebp]
	lea	ecx, DWORD PTR _y0$[esp+396]
	push	ecx
	mov	ecx, DWORD PTR _length$[esp+400]
	lea	edx, DWORD PTR _x0$[esp+400]
	push	edx
	mov	edx, DWORD PTR _ucstring$190672[esp+404]
	push	esi
	push	eax
	push	0
	push	ebx
	push	1
	push	edi
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _FindPage$[esp+436]
	call	?findText@TextOutputDev@@QAEHPAIHHHHHHHPAN111@Z ; TextOutputDev::findText
$LN13@FindTextA:

; 2147 : 			//Si existen resultados, agregamos esta coincidencia a la lista
; 2148 : 			if (rc) {

	test	eax, eax
	je	$LN12@FindTextA

; 2149 : 				m_Selection.Add(CPDFSearchResult(CRect((int)x0, (int)y0, (int)x1, (int)y1),searchPage));

	fld	QWORD PTR _y1$[esp+388]
	call	__ftol2_sse
	fld	QWORD PTR _x1$[esp+388]
	mov	esi, eax
	call	__ftol2_sse
	fld	QWORD PTR _y0$[esp+388]
	mov	edi, eax
	call	__ftol2_sse
	fld	QWORD PTR _x0$[esp+388]
	mov	ebx, eax
	call	__ftol2_sse
	mov	DWORD PTR $T190653[esp+388], eax
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, DWORD PTR _searchPage$[esp+388]
	mov	DWORD PTR $T190653[esp+412], eax
	mov	eax, DWORD PTR _this$GSCopy$[esp+388]
	mov	DWORD PTR $T190653[esp+404], ecx
	mov	edx, esi
	lea	ecx, DWORD PTR $T190653[esp+388]
	sub	edx, ebx
	push	ecx
	add	eax, 320				; 00000140H
	mov	DWORD PTR $T190653[esp+396], ebx
	mov	DWORD PTR $T190653[esp+400], edi
	mov	DWORD PTR $T190653[esp+404], esi
	mov	DWORD PTR $T190653[esp+412], edx
	call	?Add@?$DynArray@VCPDFSearchResult@@@@QAEXABVCPDFSearchResult@@@Z ; DynArray<CPDFSearchResult>::Add

; 2150 : 				startAtTop = gFalse;

	xor	edi, edi

; 2151 : 				startAtLast = gTrue;

	lea	ebx, DWORD PTR [edi+1]

; 2152 : 				if(iFirstPageFound==0) //La primer pagina en donde se encontro

	cmp	DWORD PTR _iFirstPageFound$[esp+388], edi
	jne	$LN16@FindTextA

; 2153 : 					iFirstPageFound =searchPage;

	mov	edx, DWORD PTR _searchPage$[esp+388]
	mov	DWORD PTR _iFirstPageFound$[esp+388], edx

; 2154 : 				continue;

	jmp	$LN16@FindTextA
$LN12@FindTextA:

; 2155 : 			}
; 2156 : 
; 2157 : 			if(!bWholeDoc)	//Si no se desea buscar en todo el documento, salimos

	mov	al, BYTE PTR _bWholeDoc$[ebp]

; 2158 : 				if (m_Selection.GetCount() > 0)

	mov	ecx, DWORD PTR _this$GSCopy$[esp+388]
	test	al, al
	jne	SHORT $LN9@FindTextA
	cmp	DWORD PTR [ecx+324], 0
	ja	$LN72@FindTextA
$LN9@FindTextA:

; 2159 : 					break;
; 2160 : 
; 2161 : 			// Ir a la siguiente pagina
; 2162 : 			startAtTop = gTrue;
; 2163 : 			startAtLast = gFalse;

	xor	ebx, ebx
	mov	edi, 1

; 2164 : 
; 2165 : 			// Si se desea buscar en todo el documento
; 2166 : 			if(bWholeDoc || m_Selection.GetCount()==0)

	test	al, al
	jne	SHORT $LN7@FindTextA
	cmp	DWORD PTR [ecx+324], 0
	jne	SHORT $LN4@FindTextA
$LN7@FindTextA:

; 2167 : 			{
; 2168 : 				if(m_Selection.GetCount()>0 && stopOnFirstPageResults)

	cmp	DWORD PTR [ecx+324], 0
	jbe	SHORT $LN6@FindTextA
	cmp	BYTE PTR _stopOnFirstPageResults$[ebp], 0
	jne	$LN72@FindTextA
$LN6@FindTextA:

; 2169 : 					break;
; 2170 : 				if (backward)	//Buscar hacia atras

	test	esi, esi
	je	SHORT $LN5@FindTextA

; 2171 : 					searchPage--;

	dec	DWORD PTR _searchPage$[esp+388]

; 2172 : 				else

	jmp	SHORT $LN4@FindTextA
$LN5@FindTextA:

; 2173 : 					searchPage++;

	inc	DWORD PTR _searchPage$[esp+388]
$LN4@FindTextA:

; 2174 : 			}	
; 2175 : 
; 2176 : 			//Si ya no hay paginas para buscar
; 2177 : 			if (searchPage < 1 || searchPage > m_PDFDoc->getNumPages()) {

	mov	eax, DWORD PTR _searchPage$[esp+388]
	cmp	eax, 1
	jl	$LN2@FindTextA
	mov	ecx, DWORD PTR [ecx+332]
	mov	edx, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+12]
	jg	$LN2@FindTextA

; 2181 : 			}
; 2182 : 			//Dibujar la siguiente pagina
; 2183 : 			m_PDFDoc->displayPage(&FindPage, searchPage,
; 2184 : 				FIND_DPI, FIND_DPI, 0, gFalse, gTrue, gFalse);

	fld	QWORD PTR __real@4052000000000000
	push	0
	push	0
	push	0
	push	1
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	eax
	lea	eax, DWORD PTR _FindPage$[esp+432]
	push	eax
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 2185 : 
; 2186 : 			if (!FindPage.isOk()) {

	cmp	DWORD PTR _FindPage$[esp+520], 0
	jne	$LN16@FindTextA

; 2187 : //				AfxMessageBox("Error al mostrar la pagina");
; 2188 : 				delete [] ucstring;

	mov	edx, DWORD PTR _ucstring$190672[esp+388]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 2189 : 				return -1;	//No hay resultados

	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
	or	eax, -1
	jmp	SHORT $LN21@FindTextA
$LN72@FindTextA:

; 2190 : 			}
; 2191 : 		}
; 2192 : 		//Establecer la pagina de busqueda en la primer pagina
; 2193 : 		m_SearchPage=iFirstPageFound;
; 2194 : 		delete [] ucstring;

	mov	eax, DWORD PTR _ucstring$190672[esp+388]
	mov	edx, DWORD PTR _iFirstPageFound$[esp+388]
	push	eax
	mov	DWORD PTR [ecx+512], edx
	call	??_V@YAXPAX@Z				; operator delete[]

; 2195 : 		return m_Selection.GetCount();

	mov	ecx, DWORD PTR _this$GSCopy$[esp+392]
	mov	esi, DWORD PTR [ecx+324]
	jmp	SHORT $LN85@FindTextA
$LN2@FindTextA:

; 2178 : 				delete [] ucstring;

	mov	eax, DWORD PTR _ucstring$190672[esp+388]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 2179 : 				m_SearchPage=iFirstPageFound;

	mov	eax, DWORD PTR _this$GSCopy$[esp+392]
	mov	ecx, DWORD PTR _iFirstPageFound$[esp+392]

; 2180 : 				return m_Selection.GetCount();

	mov	esi, DWORD PTR [eax+324]
	mov	DWORD PTR [eax+512], ecx
$LN85@FindTextA:
	add	esp, 4
	lea	ecx, DWORD PTR _theString$[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 0
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _FindPage$[esp+388]
	mov	DWORD PTR __$EHRec$[esp+396], -1
	call	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
	mov	eax, esi
$LN21@FindTextA:

; 2196 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+388]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z$0:
	lea	ecx, DWORD PTR _FindPage$[ebp]
	jmp	??1TextOutputDev@@UAE@XZ		; TextOutputDev::~TextOutputDev
__unwindfunclet$?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z$1:
	lea	ecx, DWORD PTR _theString$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
__ehhandler$?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-372]
	mov	ecx, DWORD PTR [edx-376]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindTextA@AFPDFDoc@@QAEJPB_WJJ_N11111@Z ENDP		; AFPDFDoc::FindTextA
PUBLIC	?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z		; AFPDFDoc::SaveTxt
;	COMDAT xdata$x
; File c:\projects\pdflibnet\xpdfwin\goo\gstring.h
xdata$x	SEGMENT
__unwindtable$?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z$1
__ehfuncinfo$?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z
_TEXT	SEGMENT
$T191311 = -96						; size = 4
$T191310 = -96						; size = 4
$T191315 = -92						; size = 4
_info$ = -88						; size = 24
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_fileName$ = 12						; size = 4
_firstPage$ = 16					; size = 4
_lastPage$ = 20						; size = 4
_htmlMeta$ = 24						; size = 1
_physLayout$ = 28					; size = 1
_rawOrder$ = 32						; size = 1
?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z PROC			; AFPDFDoc::SaveTxt, COMDAT

; 2983 : 	int AFPDFDoc::SaveTxt(char *fileName,int firstPage, int lastPage, bool htmlMeta, bool physLayout, bool rawOrder){

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, eax

; 2984 : 		  TextOutputDev *textOut;
; 2985 : 		  FILE *f;
; 2986 : 		  Object info;

	xor	ebx, ebx

; 2987 : //		  GBool ok;
; 2988 : 		  GString *textFileName = new GString(fileName);

	push	8
	mov	DWORD PTR _info$[esp+136], ebx
	mov	DWORD PTR _info$[esp+140], ebx
	mov	DWORD PTR _info$[esp+144], 13		; 0000000dH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T191311[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], ebx
	cmp	eax, ebx
	je	SHORT $LN19@SaveTxt
	mov	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	mov	esi, eax
	mov	DWORD PTR $T191310[esp+132], esi
	jmp	SHORT $LN20@SaveTxt
$LN19@SaveTxt:
	mov	DWORD PTR $T191310[esp+132], ebx
	mov	esi, ebx
$LN20@SaveTxt:

; 2989 : 		 // check for copy permission
; 2990 : 		  if (!m_PDFDoc->okToCopy()) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	mov	eax, DWORD PTR [edx+332]
	mov	ecx, DWORD PTR [eax+24]
	push	ebx
	call	?okToCopy@XRef@@QAEHH@Z			; XRef::okToCopy
	test	eax, eax
	jne	SHORT $LN16@SaveTxt

; 2991 : //			error(-1, "Copying of text from this document is not allowed.");
; 2992 : 			return 10003;

	mov	eax, 10003				; 00002713H

; 3096 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN16@SaveTxt:

; 2993 : 		  }
; 2994 : 			UnicodeMap *uMap;
; 2995 : 			if (!(uMap = globalParams->getTextEncoding())) {

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	call	?getTextEncoding@GlobalParams@@QAEPAVUnicodeMap@@XZ ; GlobalParams::getTextEncoding
	mov	edi, eax
	cmp	edi, ebx
	jne	SHORT $LN15@SaveTxt

; 2996 : 				return 10004;

	mov	eax, 10004				; 00002714H

; 3096 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN15@SaveTxt:

; 2997 : 			}
; 2998 : 
; 2999 : 		  // write HTML header
; 3000 : 		  if (htmlMeta) {

	cmp	BYTE PTR _htmlMeta$[ebp], 0
	je	$LN61@SaveTxt

; 3001 : 			if (!textFileName->cmp("-")) {

	push	OFFSET ??_C@_01JOAMLHOP@?9?$AA@
	mov	ecx, esi
	call	?cmp@GString@@QAEHPBD@Z			; GString::cmp
	test	eax, eax
	jne	$LN13@SaveTxt

; 3002 : 			  f = stdout;

	call	DWORD PTR __imp____iob_func
	mov	esi, eax
	add	esi, 32					; 00000020H
$LN11@SaveTxt:

; 3007 : 			  }
; 3008 : 			}
; 3009 : 			fputs("<html>\n", f);

	mov	ebx, DWORD PTR __imp__fputs
	push	esi
	push	OFFSET ??_C@_07KEBNPAKG@?$DMhtml?$DO?6?$AA@
	call	ebx

; 3010 : 			fputs("<head>\n", f);

	push	esi
	push	OFFSET ??_C@_07GMNDOEHG@?$DMhead?$DO?6?$AA@
	call	ebx

; 3011 : 			m_PDFDoc->getDocInfo(&info);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+332]
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR _info$[esp+132]
	push	ecx
	mov	ecx, DWORD PTR [eax+24]
	call	?getDocInfo@XRef@@QAEPAVObject@@PAV2@@Z	; XRef::getDocInfo

; 3012 : 			if (info.isDict()) {

	cmp	DWORD PTR _info$[esp+140], 7
	jne	$LN10@SaveTxt

; 3013 : 			  printInfoString(f, info.getDict(), "Title", "<title>", "</title>\n",
; 3014 : 					  uMap);

	mov	ecx, DWORD PTR _info$[esp+148]
	push	edi
	push	OFFSET ??_C@_07NBINAAM@?$DMtitle?$DO?$AA@
	push	OFFSET ??_C@_05PABKJLOM@Title?$AA@
	mov	edx, OFFSET ??_C@_09BBFFNMKL@?$DM?1title?$DO?6?$AA@
	mov	ebx, esi
	call	?printInfoString@@YAXPAU_iobuf@@PAVDict@@PAD22PAVUnicodeMap@@@Z ; printInfoString

; 3015 : 			  printInfoString(f, info.getDict(), "Subject",
; 3016 : 					  "<meta name=\"Subject\" content=\"", "\">\n", uMap);

	mov	ecx, DWORD PTR _info$[esp+160]
	add	esp, 12					; 0000000cH
	push	edi
	push	OFFSET ??_C@_0BP@HAMJGHOB@?$DMmeta?5name?$DN?$CCSubject?$CC?5content?$DN?$CC?$AA@
	push	OFFSET ??_C@_07GEKACEDI@Subject?$AA@
	mov	edx, OFFSET ??_C@_03JKGHEG@?$CC?$DO?6?$AA@
	call	?printInfoString@@YAXPAU_iobuf@@PAVDict@@PAD22PAVUnicodeMap@@@Z ; printInfoString

; 3017 : 			  printInfoString(f, info.getDict(), "Keywords",
; 3018 : 					  "<meta name=\"Keywords\" content=\"", "\">\n", uMap);

	mov	ecx, DWORD PTR _info$[esp+160]
	add	esp, 12					; 0000000cH
	push	edi
	push	OFFSET ??_C@_0CA@EAHKABAB@?$DMmeta?5name?$DN?$CCKeywords?$CC?5content?$DN?$CC?$AA@
	push	OFFSET ??_C@_08CDHFLBJH@Keywords?$AA@
	mov	edx, OFFSET ??_C@_03JKGHEG@?$CC?$DO?6?$AA@
	call	?printInfoString@@YAXPAU_iobuf@@PAVDict@@PAD22PAVUnicodeMap@@@Z ; printInfoString

; 3019 : 			  printInfoString(f, info.getDict(), "Author",
; 3020 : 					  "<meta name=\"Author\" content=\"", "\">\n", uMap);

	mov	ecx, DWORD PTR _info$[esp+160]
	add	esp, 12					; 0000000cH
	push	edi
	push	OFFSET ??_C@_0BO@NOGKHONE@?$DMmeta?5name?$DN?$CCAuthor?$CC?5content?$DN?$CC?$AA@
	push	OFFSET ??_C@_06HHECMMLE@Author?$AA@
	mov	edx, OFFSET ??_C@_03JKGHEG@?$CC?$DO?6?$AA@
	call	?printInfoString@@YAXPAU_iobuf@@PAVDict@@PAD22PAVUnicodeMap@@@Z ; printInfoString

; 3021 : 			  printInfoString(f, info.getDict(), "Creator",
; 3022 : 					  "<meta name=\"Creator\" content=\"", "\">\n", uMap);

	mov	ecx, DWORD PTR _info$[esp+160]
	add	esp, 12					; 0000000cH
	push	edi
	push	OFFSET ??_C@_0BP@IPGFALCO@?$DMmeta?5name?$DN?$CCCreator?$CC?5content?$DN?$CC?$AA@
	push	OFFSET ??_C@_07IMEECM@Creator?$AA@
	mov	edx, OFFSET ??_C@_03JKGHEG@?$CC?$DO?6?$AA@
	call	?printInfoString@@YAXPAU_iobuf@@PAVDict@@PAD22PAVUnicodeMap@@@Z ; printInfoString

; 3023 : 			  printInfoString(f, info.getDict(), "Producer",
; 3024 : 					  "<meta name=\"Producer\" content=\"", "\">\n", uMap);

	mov	ecx, DWORD PTR _info$[esp+160]
	add	esp, 12					; 0000000cH
	push	edi
	push	OFFSET ??_C@_0CA@DCFLJP@?$DMmeta?5name?$DN?$CCProducer?$CC?5content?$DN?$CC?$AA@
	push	OFFSET ??_C@_08CAPOGIGH@Producer?$AA@
	mov	edx, OFFSET ??_C@_03JKGHEG@?$CC?$DO?6?$AA@
	call	?printInfoString@@YAXPAU_iobuf@@PAVDict@@PAD22PAVUnicodeMap@@@Z ; printInfoString

; 3025 : 			  printInfoDate(f, info.getDict(), "CreationDate",
; 3026 : 					"<meta name=\"CreationDate\" content=\"%s\">\n");

	mov	edx, DWORD PTR _info$[esp+160]
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0CJ@PGCBBAGD@?$DMmeta?5name?$DN?$CCCreationDate?$CC?5conten@
	push	edx
	push	esi
	mov	ecx, OFFSET ??_C@_0N@GPGLEEKJ@CreationDate?$AA@
	call	?printInfoDate@@YAXPAU_iobuf@@PAVDict@@PAD2@Z ; printInfoDate

; 3027 : 			  printInfoDate(f, info.getDict(), "LastModifiedDate",
; 3028 : 					"<meta name=\"ModDate\" content=\"%s\">\n");

	mov	eax, DWORD PTR _info$[esp+160]
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0CE@CEKGHJIK@?$DMmeta?5name?$DN?$CCModDate?$CC?5content?$DN?$CC?$CFs@
	push	eax
	push	esi
	mov	ecx, OFFSET ??_C@_0BB@CPLAAHOH@LastModifiedDate?$AA@
	call	?printInfoDate@@YAXPAU_iobuf@@PAVDict@@PAD2@Z ; printInfoDate
	mov	ebx, DWORD PTR __imp__fputs
	add	esp, 12					; 0000000cH
$LN10@SaveTxt:

; 3029 : 			}
; 3030 : 			info.free();

	lea	ecx, DWORD PTR _info$[esp+132]
	call	?free@Object@@QAEXXZ			; Object::free

; 3031 : /*
; 3032 : 			fputs("<ul>\n",f);
; 3033 : 
; 3034 : 			USES_CONVERSION;
; 3035 : 			for(int itOutline=0;itOutline <  m_PDFDoc->getOutline()->getItems()->getLength();itOutline++){
; 3036 : 				OutlineItem *ol = (OutlineItem *) m_PDFDoc->getOutline()->getItems()->get(itOutline);
; 3037 : 				wchar_t *title =GetTitle(uMap,ol);
; 3038 : 				fprintf(f,"<li>%s</li>\n",W2A(title));
; 3039 : 			}
; 3040 : 			fputs("<\ul>\n",f);
; 3041 : */
; 3042 : 			fputs("</head>\n", f);

	push	esi
	push	OFFSET ??_C@_08NFMJCKLP@?$DM?1head?$DO?6?$AA@
	call	ebx

; 3043 : 			fputs("<body>\n", f);

	push	esi
	push	OFFSET ??_C@_07DKLJIGM@?$DMbody?$DO?6?$AA@
	call	ebx

; 3044 : 			fputs("<pre>\n", f);

	push	esi
	push	OFFSET ??_C@_06FNICHGOI@?$DMpre?$DO?6?$AA@
	call	ebx
	add	esp, 24					; 00000018H

; 3045 : 			if (f != stdout) {

	call	DWORD PTR __imp____iob_func
	add	eax, 32					; 00000020H
	cmp	esi, eax
	je	SHORT $LN9@SaveTxt

; 3046 : 			  fclose(f);

	push	esi
	call	DWORD PTR __imp__fclose
	add	esp, 4
	jmp	SHORT $LN9@SaveTxt
$LN13@SaveTxt:

; 3003 : 			} else {
; 3004 : 			  if (!(f = fopen(textFileName->getCString(), "wb"))) {

	mov	eax, DWORD PTR [esi+4]
	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	eax
	call	DWORD PTR __imp__fopen
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	$LN11@SaveTxt
$LN64@SaveTxt:

; 3005 : //			error(-1, "Couldn't open text file '%s'", textFileName->getCString());
; 3006 : 			return 20002;

	mov	eax, 20002				; 00004e22H

; 3096 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN61@SaveTxt:

; 3046 : 			  fclose(f);

	mov	ebx, DWORD PTR __imp__fputs
$LN9@SaveTxt:

; 3047 : 			}
; 3048 : 		  }else{
; 3049 : 				/*if (!(f = fopen(textFileName->getCString(), "wb"))) {
; 3050 : 					return 20002;
; 3051 : 				}
; 3052 : 				
; 3053 : 				USES_CONVERSION;
; 3054 : 				for(int itOutline=0;itOutline <  m_PDFDoc->getOutline()->getItems()->getLength();itOutline++)
; 3055 : 				{
; 3056 : 					OutlineItem *ol = (OutlineItem *) m_PDFDoc->getOutline()->getItems()->get(itOutline);
; 3057 : 					wchar_t *title =GetTitle(uMap,ol);
; 3058 : 					fprintf(f,"%s\n",W2A(title));					
; 3059 : 				}
; 3060 : 				
; 3061 : 				fclose(f);
; 3062 : */
; 3063 : 		  }
; 3064 : 
; 3065 : 		  // write text file
; 3066 : 		  textOut = new TextOutputDev(textFileName->getCString(),
; 3067 : 			  physLayout?1:0, rawOrder?1:0, htmlMeta?1:0);

	push	136					; 00000088H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T191315[esp+132], esi
	mov	DWORD PTR __$EHRec$[esp+140], 1
	test	esi, esi
	je	SHORT $LN21@SaveTxt
	mov	ecx, DWORD PTR $T191310[esp+132]
	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	cmp	BYTE PTR _htmlMeta$[ebp], al
	setne	al
	xor	ecx, ecx
	cmp	BYTE PTR _rawOrder$[ebp], cl
	setne	cl
	push	eax
	xor	eax, eax
	cmp	BYTE PTR _physLayout$[ebp], al
	setne	al
	push	ecx
	mov	ecx, esi
	push	eax
	push	edx
	call	??0TextOutputDev@@QAE@PADHHH@Z		; TextOutputDev::TextOutputDev
	mov	esi, eax
	jmp	SHORT $LN22@SaveTxt
$LN21@SaveTxt:
	xor	esi, esi
$LN22@SaveTxt:
	mov	DWORD PTR __$EHRec$[esp+140], -1

; 3068 : 		  if (textOut->isOk()) {

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+320]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	$LN7@SaveTxt

; 3069 : 			m_PDFDoc->displayPages(textOut, firstPage, lastPage, 72, 72, 0,
; 3070 : 					  gFalse, gTrue, gFalse);

	fld	QWORD PTR __real@4052000000000000
	mov	ecx, DWORD PTR _lastPage$[ebp]
	mov	edx, DWORD PTR _firstPage$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	push	0
	push	0
	push	0
	push	1
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	ecx
	mov	ecx, DWORD PTR [eax+332]
	push	edx
	push	esi
	call	?displayPages@PDFDoc@@QAEXPAVOutputDev@@HHNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPages

; 3074 : 		  }
; 3075 : 		  delete textOut;

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax

; 3076 : 
; 3077 : 		  // write end of HTML file
; 3078 : 		  if (htmlMeta) {

	cmp	BYTE PTR _htmlMeta$[ebp], 0
	je	SHORT $LN1@SaveTxt

; 3079 : 			if (!textFileName->cmp("-")) {

	mov	esi, DWORD PTR $T191310[esp+132]
	push	OFFSET ??_C@_01JOAMLHOP@?9?$AA@
	mov	ecx, esi
	call	?cmp@GString@@QAEHPBD@Z			; GString::cmp
	test	eax, eax
	jne	SHORT $LN4@SaveTxt

; 3080 : 			  f = stdout;

	call	DWORD PTR __imp____iob_func
	mov	esi, eax
	add	esi, 32					; 00000020H

; 3081 : 			} else {

	jmp	SHORT $LN2@SaveTxt
$LN4@SaveTxt:

; 3082 : 			  if (!(f = fopen(textFileName->getCString(), "ab"))) {

	mov	eax, DWORD PTR [esi+4]
	push	OFFSET ??_C@_02BOGAIONP@ab?$AA@
	push	eax
	call	DWORD PTR __imp__fopen
	mov	esi, eax
	add	esp, 8
	test	esi, esi

; 3083 : 			//error(-1, "Couldn't open text file '%s'", textFileName->getCString());
; 3084 : 			return 20002;

	je	$LN64@SaveTxt
$LN2@SaveTxt:

; 3085 : 			  }
; 3086 : 			}
; 3087 : 			fputs("</pre>\n", f);

	push	esi
	push	OFFSET ??_C@_07CBJILGJO@?$DM?1pre?$DO?6?$AA@
	call	ebx

; 3088 : 			fputs("</body>\n", f);

	push	esi
	push	OFFSET ??_C@_08LKLBFGKF@?$DM?1body?$DO?6?$AA@
	call	ebx

; 3089 : 			fputs("</html>\n", f);

	push	esi
	push	OFFSET ??_C@_08BNAHDOGP@?$DM?1html?$DO?6?$AA@
	call	ebx
	add	esp, 24					; 00000018H

; 3090 : 			if (f != stdout) {

	call	DWORD PTR __imp____iob_func
	add	eax, 32					; 00000020H
	cmp	esi, eax
	je	SHORT $LN1@SaveTxt

; 3091 : 			  fclose(f);

	push	esi
	call	DWORD PTR __imp__fclose
	add	esp, 4
$LN1@SaveTxt:

; 3092 : 			}
; 3093 : 		  }
; 3094 : 
; 3095 : 		  return 0;

	xor	eax, eax

; 3096 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN7@SaveTxt:

; 3071 : 		  } else {
; 3072 : 			delete textOut;

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax

; 3073 : 			return 2;

	mov	eax, 2

; 3096 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z$0:
	mov	eax, DWORD PTR $T191311[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z$1:
	mov	eax, DWORD PTR $T191315[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-116]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SaveTxt@AFPDFDoc@@QAEHPADHH_N11@Z ENDP			; AFPDFDoc::SaveTxt
PUBLIC	__real@4062c00000000000
PUBLIC	?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z		; AFPDFDoc::PrintToFile
;	COMDAT __real@4062c00000000000
; File c:\projects\pdflibnet\xpdfwin\xpdf\pdfdoc.h
CONST	SEGMENT
__real@4062c00000000000 DQ 04062c00000000000r	; 150
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z$0
__ehfuncinfo$?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
$T191400 = 12						; size = 4
_fromPage$ = 12						; size = 4
?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z PROC			; AFPDFDoc::PrintToFile, COMDAT
; _this$ = edi
; _toPage$ = ebx

; 2413 : 	long AFPDFDoc::PrintToFile(LPCTSTR fileName, int fromPage, int toPage){

	push	-1
	push	__ehhandler$?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebp
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _fromPage$[esp+20]

; 2414 : 		if(!m_PDFDoc->okToPrint())

	mov	eax, DWORD PTR [edi+332]
	mov	ecx, DWORD PTR [eax+24]
	xor	esi, esi
	push	esi
	call	?okToPrint@XRef@@QAEHH@Z		; XRef::okToPrint
	test	eax, eax
	jne	SHORT $LN2@PrintToFil

; 2415 : 			return -1;

	or	eax, -1

; 2426 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
$LN2@PrintToFil:

; 2416 : 				
; 2417 : 		PSOutputDev *psOut =new PSOutputDev((char *)fileName,m_PDFDoc->getXRef(),m_PDFDoc->getCatalog(),fromPage,toPage,psModePS);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T191400[esp+20], eax
	mov	DWORD PTR __$EHRec$[esp+32], esi
	cmp	eax, esi
	je	SHORT $LN5@PrintToFil
	mov	edx, DWORD PTR [edi+332]
	mov	esi, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _fileName$[esp+20]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	ebx
	push	ebp
	push	esi
	push	edx
	push	ecx
	mov	ecx, eax
	call	??0PSOutputDev@@QAE@PADPAVXRef@@PAVCatalog@@HHW4PSOutMode@@HHHHH@Z ; PSOutputDev::PSOutputDev
	mov	esi, eax
$LN5@PrintToFil:
	mov	DWORD PTR __$EHRec$[esp+32], -1

; 2418 : 		if(!psOut->isOk()){

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+320]
	mov	ecx, esi
	call	eax
	test	eax, eax
	jne	SHORT $LN1@PrintToFil

; 2419 : 			delete psOut;

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax

; 2420 : 			return -2;

	mov	eax, -2					; fffffffeH

; 2426 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
$LN1@PrintToFil:

; 2421 : 		}
; 2422 : 		m_PDFDoc->displayPages(psOut,fromPage,toPage,PRINT_DPI,PRINT_DPI,0,gTrue,globalParams->getPSCrop(),gTrue);

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	0
	push	0
	push	1
	call	?getPSCrop@GlobalParams@@QAEHXZ		; GlobalParams::getPSCrop
	fld	QWORD PTR __real@4062c00000000000
	mov	ecx, DWORD PTR [edi+332]
	push	eax
	push	1
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	ebx
	push	ebp
	push	esi
	call	?displayPages@PDFDoc@@QAEXPAVOutputDev@@HHNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPages

; 2423 : 
; 2424 : 		delete psOut;

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax

; 2425 : 		return 0;

	xor	eax, eax

; 2426 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z$0:
	mov	eax, DWORD PTR $T191400[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PrintToFile@AFPDFDoc@@QAEJPBDHH@Z ENDP			; AFPDFDoc::PrintToFile
; Function compile flags: /Ogtpy
;	COMDAT ??_GmupdfEngine@@QAEPAXI@Z
_TEXT	SEGMENT
??_GmupdfEngine@@QAEPAXI@Z PROC				; mupdfEngine::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@scalar@13
	mov	eax, DWORD PTR [eax+40]
	test	eax, eax
	je	SHORT $LN5@scalar@13
	push	eax
	call	_pdf_dropstore
	add	esp, 4
$LN5@scalar@13:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+40], 0
	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	_pdf_closexref
	add	esp, 4
$LN6@scalar@13:
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@scalar@13
	push	eax
	call	_fz_droprenderer
	add	esp, 4
$LN4@scalar@13:
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	ret	0
??_GmupdfEngine@@QAEPAXI@Z ENDP				; mupdfEngine::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z		; AFPDFDoc::LoadFromFile
;	COMDAT xdata$x
; File c:\projects\pdflibnet\xpdfwin\xpdf\pdfdoc.h
xdata$x	SEGMENT
__unwindtable$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$5
__ehfuncinfo$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z
_TEXT	SEGMENT
_exitcode$85819 = -24					; size = 4
$T191708 = -20						; size = 4
$T191704 = -20						; size = 4
$T191700 = -20						; size = 4
$T191686 = -20						; size = 4
$T191698 = -16						; size = 4
$T191688 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_FileName$ = 8						; size = 4
?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z PROC		; AFPDFDoc::LoadFromFile, COMDAT
; _this$ = edi
; _user_password$ = ecx

; 807  : 	{		

	push	-1
	push	__ehhandler$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 808  : 		
; 809  : 		//Wait for previous threads and delete them
; 810  : 		if (m_renderingThread!=0)

	mov	eax, DWORD PTR [edi+240]
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN17@LoadFromFi

; 811  : 		{					
; 812  : 			DWORD exitcode=0;
; 813  : 			GetExitCodeThread(m_renderingThread,&exitcode);

	lea	ecx, DWORD PTR _exitcode$85819[esp+40]
	push	ecx
	push	eax
	mov	DWORD PTR _exitcode$85819[esp+48], ebx
	call	DWORD PTR __imp__GetExitCodeThread@8

; 814  : 			if(exitcode==STILL_ACTIVE){

	cmp	DWORD PTR _exitcode$85819[esp+40], 259	; 00000103H
	jne	SHORT $LN16@LoadFromFi

; 815  : 				::InterlockedExchange(&this->g_lLocker,1);

	push	1
	lea	edx, DWORD PTR [edi+164]
	push	edx
	call	DWORD PTR __imp__InterlockedExchange@8

; 816  : 				WaitForSingleObject(this->hRenderFinished,INFINITE);

	mov	eax, DWORD PTR [edi+176]
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN16@LoadFromFi:

; 817  : 			}
; 818  : 			CloseHandle(m_renderingThread);

	mov	ecx, DWORD PTR [edi+240]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 819  : 			m_renderingThread=NULL;

	mov	DWORD PTR [edi+240], ebx
$LN17@LoadFromFi:

; 820  : 		}
; 821  : 
; 822  : 		InvalidateBitmapCache();

	mov	eax, edi
	call	?InvalidateBitmapCache@AFPDFDoc@@AAEXXZ	; AFPDFDoc::InvalidateBitmapCache

; 823  : 
; 824  : 		if(user_password!=NULL)

	cmp	esi, ebx
	je	SHORT $LN14@LoadFromFi

; 825  : 			m_UserPassword = user_password;

	push	esi
	lea	ecx, DWORD PTR [edi+384]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN14@LoadFromFi:

; 826  : 		if(owner_password!=NULL)
; 827  : 			m_OwnerPassword = owner_password;
; 828  : 		//Si la existia lo eliminamos
; 829  : 		if (m_splashOut!=NULL){

	mov	esi, DWORD PTR [edi+344]
	cmp	esi, ebx
	je	SHORT $LN13@LoadFromFi

; 830  : 			delete m_splashOut;

	call	??_GAuxOutputDev@@QAEPAXI@Z

; 831  : 			m_splashOut=0;

	mov	DWORD PTR [edi+344], ebx
$LN13@LoadFromFi:

; 832  : 		}
; 833  : 		//Si ya existia la eliminamos
; 834  : 		if (m_PDFDoc!=0){

	mov	esi, DWORD PTR [edi+332]
	cmp	esi, ebx
	je	SHORT $LN12@LoadFromFi

; 835  : 			delete m_PDFDoc;

	mov	ecx, esi
	call	??1PDFDoc@@QAE@XZ			; PDFDoc::~PDFDoc
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 836  : 			m_PDFDoc=0;

	mov	DWORD PTR [edi+332], ebx
$LN12@LoadFromFi:

; 837  : 		}
; 838  : 		if(_mupdf!=0){

	mov	esi, DWORD PTR [edi+8]
	cmp	esi, ebx
	je	SHORT $LN11@LoadFromFi

; 839  : 			delete _mupdf;

	call	??_GmupdfEngine@@QAEPAXI@Z

; 840  : 			_mupdf=0;

	mov	DWORD PTR [edi+8], ebx
$LN11@LoadFromFi:

; 841  : 		}
; 842  : 		
; 843  : 		//Establecemos el color del papel
; 844  : 		/*SplashColor paperColor;
; 845  : 		paperColor[0] = 0xff;
; 846  : 		paperColor[1] = 0xff;
; 847  : 		paperColor[2] = 0xff;*/
; 848  : 		
; 849  : 		//logInfo("Create SplashOutputDev");
; 850  : 		//Note: the alignment is given by GDI requirements: bitmaps have to be 16-bit aligned.
; 851  : 		//m_splashOut = new SplashOutputDev(splashModeBGR8, 4, gFalse, paperColor,gTrue,globalParams->getAntialias());
; 852  : 		//m_splashOut->setVectorAntialias(globalParams->getVectorAntialias());
; 853  : 		
; 854  : 		//Intentamos abrir el documento sin clave
; 855  : 		m_PDFDoc = new PDFDoc(new GString(FileName), NULL,NULL);		

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T191686[esp+40], esi
	mov	DWORD PTR __$EHRec$[esp+48], ebx
	cmp	esi, ebx
	je	SHORT $LN28@LoadFromFi
	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T191688[esp+40], eax
	mov	BYTE PTR __$EHRec$[esp+48], 1
	cmp	eax, ebx
	je	SHORT $LN26@LoadFromFi
	mov	edx, DWORD PTR _FileName$[esp+36]
	push	edx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	jmp	SHORT $LN27@LoadFromFi
$LN26@LoadFromFi:
	xor	eax, eax
$LN27@LoadFromFi:
	push	ebx
	push	ebx
	push	ebx
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+64], 0
	call	??0PDFDoc@@QAE@PAVGString@@00PAX@Z	; PDFDoc::PDFDoc
	jmp	SHORT $LN29@LoadFromFi
$LN28@LoadFromFi:
	xor	eax, eax
$LN29@LoadFromFi:
	mov	DWORD PTR __$EHRec$[esp+48], -1
	mov	DWORD PTR [edi+332], eax

; 856  : 
; 857  : 		//Esperamos a que se carge correctamente, o que ocurra un error
; 858  : 		while (!m_PDFDoc->isOk()) 

	cmp	DWORD PTR [eax+36], ebx
	jne	$LN9@LoadFromFi
$LN10@LoadFromFi:

; 859  : 		{
; 860  : 
; 861  : 			//En caso de que este encriptado con clave
; 862  : 			if (m_PDFDoc->getErrorCode() == errEncrypted)

	mov	eax, DWORD PTR [edi+332]
	cmp	DWORD PTR [eax+40], 4
	jne	$LN6@LoadFromFi

; 863  : 			{
; 864  : 				//Si no se especifico clave salimos
; 865  : 				if(m_OwnerPassword.size()<=0 && m_UserPassword.size()<=0) {

	mov	eax, DWORD PTR [edi+376]
	cmp	eax, ebx
	ja	SHORT $LN7@LoadFromFi
	cmp	DWORD PTR [edi+404], ebx
	jbe	$LN90@LoadFromFi
$LN7@LoadFromFi:

; 869  : 				}else{
; 870  : 					//Si no se especifico una de las claves, usamos la misma para ambos
; 871  : 					if(m_UserPassword.size()<=0){

	cmp	DWORD PTR [edi+404], ebx
	ja	SHORT $LN5@LoadFromFi

; 872  : 						m_UserPassword=m_OwnerPassword;

	lea	ecx, DWORD PTR [edi+356]
	push	ecx
	lea	ecx, DWORD PTR [edi+384]
	jmp	SHORT $LN97@LoadFromFi
$LN5@LoadFromFi:

; 873  : 					}else if(m_OwnerPassword.size()<=0){

	cmp	eax, ebx
	ja	SHORT $LN3@LoadFromFi

; 874  : 						m_OwnerPassword = m_UserPassword;

	lea	edx, DWORD PTR [edi+384]
	push	edx
	lea	ecx, DWORD PTR [edi+356]
$LN97@LoadFromFi:
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN3@LoadFromFi:

; 875  : 					}				
; 876  : 					//Intentamos abrir con clave
; 877  : 					m_PDFDoc = new PDFDoc(new GString(FileName), 
; 878  : 							new GString(const_cast<char*>(m_OwnerPassword.c_str())), 
; 879  : 							new GString(const_cast<char*>(m_UserPassword.c_str())));

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T191698[esp+40], ebx
	mov	DWORD PTR __$EHRec$[esp+48], 2
	test	ebx, ebx
	je	$LN38@LoadFromFi
	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T191700[esp+40], eax
	mov	BYTE PTR __$EHRec$[esp+48], 3
	test	eax, eax
	je	SHORT $LN32@LoadFromFi
	cmp	DWORD PTR [edi+408], 16			; 00000010H
	jb	SHORT $LN72@LoadFromFi
	mov	ecx, DWORD PTR [edi+388]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	mov	ebp, eax
	jmp	SHORT $LN33@LoadFromFi
$LN72@LoadFromFi:
	lea	ecx, DWORD PTR [edi+388]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	mov	ebp, eax
	jmp	SHORT $LN33@LoadFromFi
$LN32@LoadFromFi:
	xor	ebp, ebp
$LN33@LoadFromFi:
	push	8
	mov	BYTE PTR __$EHRec$[esp+52], 2
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T191704[esp+40], eax
	mov	BYTE PTR __$EHRec$[esp+48], 4
	test	eax, eax
	je	SHORT $LN34@LoadFromFi
	cmp	DWORD PTR [edi+380], 16			; 00000010H
	jb	SHORT $LN78@LoadFromFi
	mov	ecx, DWORD PTR [edi+360]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	mov	esi, eax
	jmp	SHORT $LN35@LoadFromFi
$LN78@LoadFromFi:
	lea	ecx, DWORD PTR [edi+360]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	mov	esi, eax
	jmp	SHORT $LN35@LoadFromFi
$LN34@LoadFromFi:
	xor	esi, esi
$LN35@LoadFromFi:
	push	8
	mov	BYTE PTR __$EHRec$[esp+52], 2
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T191708[esp+40], eax
	mov	BYTE PTR __$EHRec$[esp+48], 5
	test	eax, eax
	je	SHORT $LN36@LoadFromFi
	mov	ecx, DWORD PTR _FileName$[esp+36]
	push	ecx
	mov	ecx, eax
	call	??0GString@@QAE@PBD@Z			; GString::GString
	jmp	SHORT $LN37@LoadFromFi
$LN36@LoadFromFi:
	xor	eax, eax
$LN37@LoadFromFi:
	push	0
	push	ebp
	push	esi
	push	eax
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+64], 2
	call	??0PDFDoc@@QAE@PAVGString@@00PAX@Z	; PDFDoc::PDFDoc
	jmp	SHORT $LN39@LoadFromFi
$LN38@LoadFromFi:
	xor	eax, eax
$LN39@LoadFromFi:
	mov	DWORD PTR __$EHRec$[esp+48], -1
	mov	DWORD PTR [edi+332], eax
	xor	ebx, ebx
$LN6@LoadFromFi:

; 880  : #ifdef PDFLIBNET_ORIGINAL
; 881  : 					m_OwnerPassword.ReleaseBuffer();
; 882  : 					m_UserPassword.ReleaseBuffer();
; 883  : #endif
; 884  : 				}
; 885  : 			} 
; 886  : 			if (!m_PDFDoc->isOk())

	mov	edx, DWORD PTR [edi+332]
	cmp	DWORD PTR [edx+36], ebx
	je	$LN91@LoadFromFi
	mov	eax, edx
	cmp	DWORD PTR [eax+36], ebx
	je	$LN10@LoadFromFi
$LN9@LoadFromFi:

; 894  : 			}
; 895  : 			
; 896  : 		}
; 897  : 		if(m_LastOpenedStream){

	mov	ecx, DWORD PTR [edi+236]
	cmp	ecx, ebx
	je	SHORT $LN1@LoadFromFi

; 898  : 			m_LastOpenedStream->close();

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 899  : 			delete m_LastOpenedStream;

	mov	ecx, DWORD PTR [edi+236]
	cmp	ecx, ebx
	je	SHORT $LN42@LoadFromFi
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN42@LoadFromFi:

; 900  : 			m_LastOpenedStream = 0;

	mov	DWORD PTR [edi+236], ebx
$LN1@LoadFromFi:

; 901  : 		}
; 902  : 		m_LastOpenedFile.clear();

	lea	esi, DWORD PTR [edi+228]
	mov	ecx, esi
	call	?clear@GString@@QAEPAV1@XZ		; GString::clear

; 903  : 		m_LastOpenedFile.insert((int)0,FileName,(int)strlen(FileName));

	mov	ebp, DWORD PTR _FileName$[esp+36]
	mov	eax, ebp
	lea	edx, DWORD PTR [eax+1]
$LL92@LoadFromFi:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL92@LoadFromFi
	sub	eax, edx
	push	eax
	push	ebp
	push	ebx
	mov	ecx, esi
	call	?insert@GString@@QAEPAV1@HPBDH@Z	; GString::insert

; 904  : 		//El archivo se cargo correctamente
; 905  : 		m_Outline = m_PDFDoc->getOutline();

	mov	ecx, DWORD PTR [edi+332]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [edi+348], edx

; 906  : 
; 907  : 		m_LastPageRendered = -1;

	mov	DWORD PTR [edi+508], -1

; 908  : 		m_CurrentPage = 0;

	mov	DWORD PTR [edi+504], ebx

; 909  : 		m_SearchPage = 0;

	mov	DWORD PTR [edi+512], ebx

; 910  : 		
; 911  : 		return S_OK;

	xor	eax, eax

; 912  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN90@LoadFromFi:

; 866  : 					delete m_PDFDoc;

	mov	esi, DWORD PTR [edi+332]
	cmp	esi, ebx
	je	SHORT $LN30@LoadFromFi
	mov	ecx, esi
	call	??1PDFDoc@@QAE@XZ			; PDFDoc::~PDFDoc
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN30@LoadFromFi:

; 867  : 					m_PDFDoc=NULL;

	mov	DWORD PTR [edi+332], ebx

; 868  : 					return errEncrypted;

	mov	eax, 4

; 912  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN91@LoadFromFi:

; 887  : 			{
; 888  : 				//En caso de error, regresamos el codigo de error
; 889  : 				int errCode = m_PDFDoc->getErrorCode();

	mov	ecx, edx
	mov	esi, DWORD PTR [ecx+40]

; 890  : 				fprintf(stderr,"Error File (%d)",errCode);

	push	esi
	push	OFFSET ??_C@_0BA@NCBBEIAC@Error?5File?5?$CI?$CFd?$CJ?$AA@
	call	DWORD PTR __imp____iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf

; 891  : 				delete m_PDFDoc;

	mov	ebp, DWORD PTR [edi+332]
	add	esp, 12					; 0000000cH
	cmp	ebp, ebx
	je	SHORT $LN40@LoadFromFi
	mov	ecx, ebp
	call	??1PDFDoc@@QAE@XZ			; PDFDoc::~PDFDoc
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN40@LoadFromFi:

; 892  : 				m_PDFDoc=NULL;

	mov	DWORD PTR [edi+332], ebx

; 893  : 				return errCode;

	mov	eax, esi

; 912  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$0:
	mov	eax, DWORD PTR $T191686[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$1:
	mov	eax, DWORD PTR $T191688[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$2:
	mov	eax, DWORD PTR $T191698[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$3:
	mov	eax, DWORD PTR $T191700[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$4:
	mov	eax, DWORD PTR $T191704[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z$5:
	mov	eax, DWORD PTR $T191708[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-24]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z ENDP		; AFPDFDoc::LoadFromFile
PUBLIC	?LoadFromFile@AFPDFDoc@@QAEJPAD0@Z		; AFPDFDoc::LoadFromFile
; Function compile flags: /Ogtpy
;	COMDAT ?LoadFromFile@AFPDFDoc@@QAEJPAD0@Z
_TEXT	SEGMENT
?LoadFromFile@AFPDFDoc@@QAEJPAD0@Z PROC			; AFPDFDoc::LoadFromFile, COMDAT
; _this$ = edi
; _FileName$ = eax
; _user_password$ = ecx

; 634  : 		return this->LoadFromFile(FileName,user_password,NULL);

	push	eax
	call	?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z	; AFPDFDoc::LoadFromFile

; 635  : 	}

	ret	0
?LoadFromFile@AFPDFDoc@@QAEJPAD0@Z ENDP			; AFPDFDoc::LoadFromFile
_TEXT	ENDS
PUBLIC	?LoadFromFile@AFPDFDoc@@QAEJPAD@Z		; AFPDFDoc::LoadFromFile
; Function compile flags: /Ogtpy
;	COMDAT ?LoadFromFile@AFPDFDoc@@QAEJPAD@Z
_TEXT	SEGMENT
?LoadFromFile@AFPDFDoc@@QAEJPAD@Z PROC			; AFPDFDoc::LoadFromFile, COMDAT
; _this$ = edi
; _FileName$ = eax

; 631  : 		return this->LoadFromFile(FileName,NULL,NULL);

	push	eax
	xor	ecx, ecx
	call	?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z	; AFPDFDoc::LoadFromFile

; 632  : 	}

	ret	0
?LoadFromFile@AFPDFDoc@@QAEJPAD@Z ENDP			; AFPDFDoc::LoadFromFile
PUBLIC	?LoadFromFile2@AFPDFDoc@@QAEJPAD@Z		; AFPDFDoc::LoadFromFile2
; Function compile flags: /Ogtpy
;	COMDAT ?LoadFromFile2@AFPDFDoc@@QAEJPAD@Z
_TEXT	SEGMENT
?LoadFromFile2@AFPDFDoc@@QAEJPAD@Z PROC			; AFPDFDoc::LoadFromFile2, COMDAT
; _this$ = edi
; _FileName$ = eax

; 1737 : 		
; 1738 : 		return LoadFromFile(FileName);

	push	eax
	xor	ecx, ecx
	call	?LoadFromFile@AFPDFDoc@@QAEJPAD00@Z	; AFPDFDoc::LoadFromFile

; 1739 : 	}

	ret	0
?LoadFromFile2@AFPDFDoc@@QAEJPAD@Z ENDP			; AFPDFDoc::LoadFromFile2
_TEXT	ENDS
PUBLIC	?LoadFromMuPDF@AFPDFDoc@@QAE_NXZ		; AFPDFDoc::LoadFromMuPDF
; Function compile flags: /Ogtpy
;	COMDAT ?LoadFromMuPDF@AFPDFDoc@@QAE_NXZ
_TEXT	SEGMENT
?LoadFromMuPDF@AFPDFDoc@@QAE_NXZ PROC			; AFPDFDoc::LoadFromMuPDF, COMDAT
; _this$ = ebx

; 1547 : 	bool AFPDFDoc::LoadFromMuPDF(){

	push	ebp

; 1548 : #ifdef _MUPDF
; 1549 : 		if(_mupdf == NULL){

	xor	ebp, ebp
	cmp	DWORD PTR [ebx+8], ebp
	jne	SHORT $LN1@LoadFromMu
	push	esi

; 1550 : 			_mupdf = new mupdfEngine();

	mov	esi, 16					; 00000010H
	push	esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN5@LoadFromMu
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	jmp	SHORT $LN6@LoadFromMu
$LN5@LoadFromMu:
	xor	eax, eax
$LN6@LoadFromMu:
	mov	DWORD PTR [ebx+8], eax

; 1551 : 			if(this->_mupdf->LoadFile(this->m_LastOpenedFile.getCString(),const_cast<char*>(m_OwnerPassword.c_str()),const_cast<char*>(m_UserPassword.c_str()))){

	cmp	DWORD PTR [ebx+408], esi
	jb	SHORT $LN16@LoadFromMu
	mov	edx, DWORD PTR [ebx+388]
	jmp	SHORT $LN17@LoadFromMu
$LN16@LoadFromMu:
	lea	edx, DWORD PTR [ebx+388]
$LN17@LoadFromMu:
	cmp	DWORD PTR [ebx+380], esi
	jb	SHORT $LN22@LoadFromMu
	mov	ecx, DWORD PTR [ebx+360]
	jmp	SHORT $LN23@LoadFromMu
$LN22@LoadFromMu:
	lea	ecx, DWORD PTR [ebx+360]
$LN23@LoadFromMu:
	push	edi
	mov	edi, DWORD PTR [ebx+232]
	push	edx
	push	ecx
	mov	esi, eax
	call	?LoadFile@mupdfEngine@@QAEHPAD00@Z	; mupdfEngine::LoadFile
	pop	edi
	test	eax, eax
	je	SHORT $LN26@LoadFromMu

; 1552 : 				delete _mupdf;

	mov	esi, DWORD PTR [ebx+8]
	cmp	esi, ebp
	je	SHORT $LN7@LoadFromMu
	call	??_GmupdfEngine@@QAEPAXI@Z
$LN7@LoadFromMu:

; 1553 : 				_mupdf=NULL;

	mov	DWORD PTR [ebx+8], ebp
$LN26@LoadFromMu:
	pop	esi
$LN1@LoadFromMu:

; 1554 : 			}
; 1555 : #ifdef PDFLIBNET_ORIGINAL
; 1556 : 			m_OwnerPassword.ReleaseBuffer();
; 1557 : 			m_UserPassword.ReleaseBuffer();
; 1558 : #endif
; 1559 : 		}
; 1560 : 		return _mupdf!=NULL;

	xor	eax, eax
	cmp	DWORD PTR [ebx+8], ebp
	pop	ebp
	setne	al

; 1561 : #else
; 1562 : 		return false;
; 1563 : #endif
; 1564 : 
; 1565 : 	}

	ret	0
?LoadFromMuPDF@AFPDFDoc@@QAE_NXZ ENDP			; AFPDFDoc::LoadFromMuPDF
PUBLIC	?RenderingThread@AFPDFDoc@@KAIPAX@Z		; AFPDFDoc::RenderingThread
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\auxoutputdev.h
xdata$x	SEGMENT
__sehtable$?RenderingThread@AFPDFDoc@@KAIPAX@Z DD 0fffffffeH
	DD	00H
	DD	0ffffff64H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN17@RenderingT
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?RenderingThread@AFPDFDoc@@KAIPAX@Z
_TEXT	SEGMENT
_ictm$86190 = -140					; size = 48
_ctm$86189 = -92					; size = 48
$T192611 = -44						; size = 8
_renderDPI$86181 = -44					; size = 8
_param$ = -36						; size = 4
_pdfDoc$ = -32						; size = 4
_render$86180 = -25					; size = 1
__$SEHRec$ = -24					; size = 24
tv646 = 8						; size = 4
tv644 = 8						; size = 4
_value$ = 8						; size = 4
?RenderingThread@AFPDFDoc@@KAIPAX@Z PROC		; AFPDFDoc::RenderingThread, COMDAT

; 1471 : 	{

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?RenderingThread@AFPDFDoc@@KAIPAX@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax

; 1472 : 		threadParam *param =(threadParam *)value;

	mov	esi, DWORD PTR _value$[ebp]
	mov	DWORD PTR _param$[ebp], esi

; 1473 : 		AFPDFDoc *pdfDoc =(AFPDFDoc *)param->doc;

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _pdfDoc$[ebp], ebx

; 1474 : 
; 1475 : 		//Add a mutex?
; 1476 : 		::gLockMutex(&pdfDoc->hgMutex);

	lea	eax, DWORD PTR [ebx+188]
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 1477 : 		__try {

	fwait
	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 1478 : 			bool render = true;

	mov	BYTE PTR _render$86180[ebp], 1

; 1479 : 			double renderDPI =pdfDoc->m_renderDPI;

	fld	QWORD PTR [ebx+536]
	fst	QWORD PTR _renderDPI$86181[ebp]

; 1480 : 			int page = pdfDoc->m_PageToRenderByThread;

	mov	edi, DWORD PTR [ebx+156]

; 1481 : 		
; 1482 : 			//Verificar los valores de variables
; 1483 : 			renderDPI=IFZERO(renderDPI,72);

	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@RenderingT
	fld	QWORD PTR __real@4052000000000000
	fstp	QWORD PTR _renderDPI$86181[ebp]
$LN12@RenderingT:

; 1484 : 			page=MAX(1,page);

	cmp	edi, 1
	jge	SHORT $LN14@RenderingT
	mov	edi, 1
$LN14@RenderingT:

; 1485 : 			
; 1486 : 			//globalParams->setPrintCommands(gTrue);
; 1487 : 			pdfDoc->m_LastPageRenderedByThread=page;

	mov	DWORD PTR [ebx+160], edi

; 1488 : 
; 1489 : #ifdef _MUPDF
; 1490 : 			if(pdfDoc->SupportsMuPDF() && pdfDoc->GetUseMuPDF()){

	mov	eax, ebx
	call	?SupportsMuPDF@AFPDFDoc@@QAE_NXZ	; AFPDFDoc::SupportsMuPDF
	test	al, al
	je	$LN6@RenderingT
	cmp	BYTE PTR [ebx+154], 0
	je	$LN6@RenderingT

; 1491 : 				if(pdfDoc->LoadFromMuPDF())

	call	?LoadFromMuPDF@AFPDFDoc@@QAE_NXZ	; AFPDFDoc::LoadFromMuPDF
	test	al, al
	je	$LN6@RenderingT

; 1492 : 				{
; 1493 : 					fz_pixmap *im = pdfDoc->_mupdf->display(param->out,page,pdfDoc->m_Rotation,renderDPI/72,callbackAbortDisplay,pdfDoc);

	fld	QWORD PTR _renderDPI$86181[ebp]
	fdiv	QWORD PTR __real@4052000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR [ebx+524]
	push	ecx
	mov	edx, DWORD PTR [esi+4]
	push	edx
	mov	eax, edi
	mov	ecx, DWORD PTR [ebx+8]
	call	?display@mupdfEngine@@QAEPAUfz_pixmap_s@@PAVAuxOutputDev@@HHNP6AHPAX@Z1@Z ; mupdfEngine::display

; 1494 : 					if(im!=NULL){

	test	eax, eax
	je	$LN6@RenderingT

; 1495 : 						param->out->SetDataPtr((void *)im->samples);

	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+8], ecx

; 1496 : 						param->out->setSize(im->w,im->h);

	mov	ecx, DWORD PTR [esi+4]
	fild	DWORD PTR [eax+12]
	fild	DWORD PTR [eax+8]
	fstp	QWORD PTR [ecx+24]
	fstp	QWORD PTR [ecx+32]

; 1497 : 						param->out->setPixmap(im);

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+44], eax

; 1498 : 						
; 1499 : 						Page *p = pdfDoc->m_PDFDoc->getCatalog()->getPage(page);

	mov	eax, DWORD PTR [ebx+332]
	mov	eax, DWORD PTR [eax+28]
	mov	ecx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+edi*4-4]

; 1500 : 						double ctm[6];
; 1501 : 						double ictm[6];
; 1502 : 						p->getDefaultCTM(ctm,renderDPI,renderDPI,pdfDoc->m_Rotation,gFalse,gTrue);

	push	1
	push	0
	mov	edx, DWORD PTR [ebx+524]
	push	edx
	sub	esp, 16					; 00000010H
	fld	QWORD PTR _renderDPI$86181[ebp]
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	lea	eax, DWORD PTR _ctm$86189[ebp]
	push	eax
	mov	ecx, edi
	call	?getDefaultCTM@Page@@QAEXPANNNHHH@Z	; Page::getDefaultCTM

; 1503 : 						param->out->setDefCTM(ctm);

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR _ctm$86189[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1504 : 						//Invert CTM
; 1505 : 						double det = 1 / (ctm[0] * ctm[3] - ctm[1] * ctm[2]);

	fld	QWORD PTR _ctm$86189[ebp+24]
	fld	ST(0)
	fld	QWORD PTR _ctm$86189[ebp]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _ctm$86189[ebp+16]
	fld	ST(0)
	fld	QWORD PTR _ctm$86189[ebp+8]
	fmul	ST(1), ST(0)
	fxch	ST(4)
	fsubrp	ST(1), ST(0)
	fld1
	fdivrp	ST(1), ST(0)

; 1506 : 						ictm[0] = ctm[3] * det;

	fld	ST(4)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _ictm$86190[ebp]

; 1507 : 						ictm[1] = -ctm[1] * det;

	fld	ST(3)
	fmul	ST(0), ST(1)
	fchs
	fstp	QWORD PTR _ictm$86190[ebp+8]

; 1508 : 						ictm[2] = -ctm[2] * det;

	fld	ST(1)
	fmul	ST(0), ST(1)
	fchs
	fstp	QWORD PTR _ictm$86190[ebp+16]

; 1509 : 						ictm[3] = ctm[0] * det;

	fld	ST(2)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _ictm$86190[ebp+24]

; 1510 : 						ictm[4] = (ctm[2] * ctm[5] - ctm[3] * ctm[4]) * det;

	fld	QWORD PTR _ctm$86189[ebp+40]
	fld	ST(0)
	fmulp	ST(3), ST(0)
	fld	QWORD PTR _ctm$86189[ebp+32]
	fld	ST(0)
	fmulp	ST(7), ST(0)
	fxch	ST(3)
	fsubrp	ST(6), ST(0)
	fxch	ST(5)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _ictm$86190[ebp+32]

; 1511 : 						ictm[5] = (ctm[1] * ctm[4] - ctm[0] * ctm[5]) * det;

	fxch	ST(1)
	fmulp	ST(3), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR _ictm$86190[ebp+40]

; 1512 : 						param->out->setDefICTM(ictm);

	mov	esi, DWORD PTR [esi+4]
	lea	edx, DWORD PTR _ictm$86190[ebp]
	mov	DWORD PTR [esi+20], edx

; 1513 : 						render =false;

	mov	BYTE PTR _render$86180[ebp], 0

; 1514 : 					}
; 1515 : 				}
; 1516 : 			}
; 1517 : #endif
; 1518 : 			if(render){

	jmp	$LN79@RenderingT
$LN6@RenderingT:

; 1519 : 				if(pdfDoc->m_sliceBox.NotEmpty()){

	lea	eax, DWORD PTR [ebx+436]
	call	?NotEmpty@CRect@@QAE_NXZ		; CRect::NotEmpty
	test	al, al
	je	SHORT $LN4@RenderingT

; 1520 : 					pdfDoc->m_PDFDoc->displayPageSlice(param->out->getSplash(),page,
; 1521 : 												renderDPI,renderDPI, pdfDoc->m_Rotation,
; 1522 : 												gFalse,gTrue,gFalse,
; 1523 : 												pdfDoc->m_sliceBox.left ,pdfDoc->m_sliceBox.top,
; 1524 : 												pdfDoc->m_sliceBox.width,pdfDoc->m_sliceBox.height,callbackAbortDisplay,pdfDoc);					

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	push	ebx
	push	OFFSET ?callbackAbortDisplay@AFPDFDoc@@KAHPAX@Z ; AFPDFDoc::callbackAbortDisplay
	mov	ecx, DWORD PTR [ebx+456]
	push	ecx
	mov	edx, DWORD PTR [ebx+452]
	push	edx
	mov	ecx, DWORD PTR [ebx+440]
	push	ecx
	mov	edx, DWORD PTR [ebx+436]
	push	edx
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR [ebx+524]
	push	ecx
	sub	esp, 16					; 00000010H
	fld	QWORD PTR _renderDPI$86181[ebp]
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	edi
	push	eax
	mov	ecx, DWORD PTR [ebx+332]
	call	?displayPageSlice@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPageSlice

; 1525 : 				}else{

	jmp	$LN79@RenderingT
$LN4@RenderingT:

; 1526 : 					if(pdfDoc->m_PDFDoc->getCatalog() && pdfDoc->m_PDFDoc->getCatalog()->isOk()){

	mov	edx, DWORD PTR [ebx+332]
	mov	edx, DWORD PTR [edx+28]
	test	edx, edx
	je	$LN79@RenderingT
	cmp	DWORD PTR [edx+176], 0
	je	$LN79@RenderingT

; 1527 : 						Page *p = pdfDoc->m_PDFDoc->getCatalog()->getPage(page);

	mov	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [eax+edi*4-4]

; 1528 : 						if(p && p->isOk()){

	test	edi, edi
	je	$LN79@RenderingT
	cmp	DWORD PTR [edi+64], 0
	je	$LN79@RenderingT

; 1529 : 							p->display(param->out->getSplash(),renderDPI, renderDPI, pdfDoc->m_Rotation, 
; 1530 : 												gFalse, gTrue, gFalse,pdfDoc->m_PDFDoc->getCatalog(),
; 1531 : 												callbackAbortDisplay,pdfDoc);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+12]
	push	ebx
	push	OFFSET ?callbackAbortDisplay@AFPDFDoc@@KAHPAX@Z ; AFPDFDoc::callbackAbortDisplay
	push	edx
	push	0
	push	1
	push	0
	mov	edx, DWORD PTR [ebx+524]
	push	edx
	sub	esp, 16					; 00000010H
	fld	QWORD PTR _renderDPI$86181[ebp]
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	eax
	mov	ecx, edi
	call	?display@Page@@QAEXPAVOutputDev@@NNHHHHPAVCatalog@@P6AHPAX@Z2@Z ; Page::display

; 1532 : 							param->out->SetDataPtr(param->out->getSplash()->getBitmap()->getDataPtr());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [ecx+180]
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+8], ecx

; 1533 : 							param->out->setDefCTM(param->out->getSplash()->getDefCTM());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 8
	mov	DWORD PTR [eax+16], ecx

; 1534 : 							param->out->setDefICTM(param->out->getSplash()->getDefICTM());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 56					; 00000038H
	mov	DWORD PTR [eax+20], ecx

; 1535 : 							param->out->setSize(param->out->getSplash()->getBitmapWidth(),param->out->getSplash()->getBitmapHeight());

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+12]
	mov	ecx, edi
	call	?getBitmapWidth@SplashOutputDev@@QAEHXZ	; SplashOutputDev::getBitmapWidth
	mov	DWORD PTR tv646[ebp], eax
	fild	DWORD PTR tv646[ebp]
	fstp	QWORD PTR $T192611[ebp]
	mov	ecx, edi
	call	?getBitmapHeight@SplashOutputDev@@QAEHXZ ; SplashOutputDev::getBitmapHeight
	mov	DWORD PTR tv644[ebp], eax
	fild	DWORD PTR tv644[ebp]
	fld	QWORD PTR $T192611[ebp]
	fstp	QWORD PTR [esi+24]
	fstp	QWORD PTR [esi+32]
$LN79@RenderingT:

; 1536 : 						}
; 1537 : 					}
; 1538 : 				}
; 1539 : 			}
; 1540 : 		}__finally{

	fwait
	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	call	$LN19@RenderingT
$LN20@RenderingT:

; 1543 : 		}
; 1544 : 		return true;

	mov	eax, 1

; 1545 : 	}

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@RenderingT:
$LN85@RenderingT:

; 1536 : 						}
; 1537 : 					}
; 1538 : 				}
; 1539 : 			}
; 1540 : 		}__finally{

	mov	ebx, DWORD PTR _pdfDoc$[ebp]
$LN19@RenderingT:

; 1541 : 			pdfDoc->RenderThreadFinished(param->out,param->pageToRender, param->enablePreRender);

	mov	eax, DWORD PTR _param$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ebx
	call	?RenderThreadFinished@AFPDFDoc@@AAEHPAVAuxOutputDev@@H_N@Z ; AFPDFDoc::RenderThreadFinished

; 1542 : 			::gUnlockMutex(&pdfDoc->hgMutex);

	add	ebx, 188				; 000000bcH
	push	ebx
	call	DWORD PTR __imp__LeaveCriticalSection@4
$LN18@RenderingT:
$LN84@RenderingT:
	ret	0
?RenderingThread@AFPDFDoc@@KAIPAX@Z ENDP		; AFPDFDoc::RenderingThread
_TEXT	ENDS
PUBLIC	__real@4032000000000000
PUBLIC	?RenderingThreadThumb@AFPDFDoc@@KAIPAX@Z	; AFPDFDoc::RenderingThreadThumb
;	COMDAT __real@4032000000000000
; File c:\projects\pdflibnet\libafpdflib\pagememory.cpp
CONST	SEGMENT
__real@4032000000000000 DQ 04032000000000000r	; 18
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
CONST	ENDS
;	COMDAT ?RenderingThreadThumb@AFPDFDoc@@KAIPAX@Z
_TEXT	SEGMENT
_render$ = -125						; size = 1
tv950 = -124						; size = 4
tv947 = -124						; size = 4
_bmHeight$86160 = -124					; size = 4
_doc$ = -124						; size = 4
_page$ = -120						; size = 4
_lpParam$86144 = -116					; size = 4
$T192766 = -112						; size = 8
_bmWidth$86159 = -112					; size = 4
_renderDPI$ = -104					; size = 8
_ctm$86153 = -96					; size = 48
_ictm$86154 = -48					; size = 48
_value$ = 8						; size = 4
?RenderingThreadThumb@AFPDFDoc@@KAIPAX@Z PROC		; AFPDFDoc::RenderingThreadThumb, COMDAT

; 1384 : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi

; 1385 : 		Queue *q=(Queue *)value;
; 1386 : 		PDFDoc *doc;
; 1387 : 		threadParamThumb *param;
; 1388 : 		double renderDPI=18;
; 1389 : 		PageMemory *bmpMem=0;
; 1390 : 		int page=0;
; 1391 : 		bool bSuccess =false;
; 1392 : 		bool render = true;

	mov	BYTE PTR _render$[esp+192], 1
$LL9@RenderingT@2:

; 1393 : 		while(true){
; 1394 : 			param=0;
; 1395 : 			LPVOID lpParam =q->RemoveHead();

	mov	eax, DWORD PTR _value$[ebp]
	call	?RemoveHead@Queue@@QAEPAXXZ		; Queue::RemoveHead
	mov	DWORD PTR _lpParam$86144[esp+192], eax

; 1396 : 			if(lpParam!=NULL){

	test	eax, eax
	je	SHORT $LL9@RenderingT@2

; 1397 : 				param = (threadParamThumb *)lpParam;
; 1398 : 				doc=(PDFDoc *)param->doc;

	mov	edi, eax

; 1399 : 				renderDPI =param->renderDPI;

	fld	QWORD PTR [edi]
	mov	eax, DWORD PTR [edi+16]

; 1400 : 				page = param->pageToRender;

	mov	esi, DWORD PTR [edi+44]
	fst	QWORD PTR _renderDPI$[esp+192]

; 1401 : 				renderDPI=IFZERO(renderDPI,18);

	fldz
	mov	DWORD PTR _doc$[esp+192], eax
	fucomp	ST(1)
	mov	DWORD PTR _page$[esp+192], esi
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@RenderingT@2
	fstp	ST(0)
	fld	QWORD PTR __real@4032000000000000
	fst	QWORD PTR _renderDPI$[esp+192]
$LN12@RenderingT@2:

; 1402 : 				page=MAX(1,page);

	cmp	esi, 1
	jge	SHORT $LN14@RenderingT@2
	mov	DWORD PTR _page$[esp+192], 1
	mov	esi, DWORD PTR _page$[esp+192]
$LN14@RenderingT@2:

; 1403 : #ifdef _MUPDF
; 1404 : 				if(param->pdfDoc->SupportsMuPDF() && param->pdfDoc->GetUseMuPDF()){

	mov	ebx, DWORD PTR [edi+40]
	cmp	DWORD PTR [ebx+228], 0
	jne	SHORT $LN22@RenderingT@2
	cmp	DWORD PTR [ebx+236], 0
	jne	$LN5@RenderingT@2
$LN22@RenderingT@2:
	cmp	BYTE PTR [ebx+154], 0
	je	$LN5@RenderingT@2
	fstp	ST(0)

; 1405 : 					if(param->pdfDoc->LoadFromMuPDF())

	call	?LoadFromMuPDF@AFPDFDoc@@QAE_NXZ	; AFPDFDoc::LoadFromMuPDF

; 1406 : 					{
; 1407 : 						fz_pixmap *im = param->pdfDoc->_mupdf->display(param->out,page,param->pdfDoc->m_Rotation,renderDPI/72,callbackAbortDisplay,param->pdfDoc);

	fld	QWORD PTR _renderDPI$[esp+192]
	test	al, al
	je	$LN5@RenderingT@2
	fdiv	QWORD PTR __real@4052000000000000
	mov	ecx, DWORD PTR [edi+40]
	mov	edx, DWORD PTR [ecx+524]
	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [ecx+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	push	eax
	mov	eax, esi
	call	?display@mupdfEngine@@QAEPAUfz_pixmap_s@@PAVAuxOutputDev@@HHNP6AHPAX@Z1@Z ; mupdfEngine::display

; 1408 : 						param->out->SetDataPtr((void *)im->samples);

	mov	edx, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [ecx+8], edx

; 1409 : 						param->out->setSize(im->w,im->h);

	fild	DWORD PTR [eax+12]
	fild	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [edi+28]

; 1410 : 						param->out->setPixmap(im);
; 1411 : 						Page *p = doc->getCatalog()->getPage(page);
; 1412 : 						double ctm[6];
; 1413 : 						double ictm[6];
; 1414 : 						p->getDefaultCTM(ctm,renderDPI,renderDPI,param->pdfDoc->m_Rotation,gFalse,gTrue);

	push	1
	push	0
	fstp	QWORD PTR [ecx+24]
	fstp	QWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edi+28]
	fld	QWORD PTR _renderDPI$[esp+200]
	mov	DWORD PTR [ecx+44], eax
	mov	edx, DWORD PTR [edi+40]
	mov	eax, DWORD PTR [edx+524]
	mov	edx, DWORD PTR _doc$[esp+200]
	push	eax
	mov	eax, DWORD PTR [edx+28]
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	lea	ecx, DWORD PTR _ctm$86153[esp+220]
	fstp	QWORD PTR [esp]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	call	?getDefaultCTM@Page@@QAEXPANNNHHH@Z	; Page::getDefaultCTM

; 1415 : 						param->out->setDefCTM(ctm);

	mov	edx, DWORD PTR [edi+28]
	lea	eax, DWORD PTR _ctm$86153[esp+192]
	mov	DWORD PTR [edx+16], eax

; 1416 : 						//Invert CTM
; 1417 : 						double det = 1 / (ctm[0] * ctm[3] - ctm[1] * ctm[2]);
; 1418 : 						ictm[0] = ctm[3] * det;
; 1419 : 						ictm[1] = -ctm[1] * det;
; 1420 : 						ictm[2] = -ctm[2] * det;
; 1421 : 						ictm[3] = ctm[0] * det;
; 1422 : 						ictm[4] = (ctm[2] * ctm[5] - ctm[3] * ctm[4]) * det;
; 1423 : 						ictm[5] = (ctm[1] * ctm[4] - ctm[0] * ctm[5]) * det;
; 1424 : 						param->out->setDefICTM(ictm);

	mov	ecx, DWORD PTR [edi+28]
	lea	edx, DWORD PTR _ictm$86154[esp+192]
	mov	DWORD PTR [ecx+20], edx

; 1425 : 						render =false;
; 1426 : 						render =false;

	mov	BYTE PTR _render$[esp+192], 0

; 1427 : 					}
; 1428 : 				}
; 1429 : #endif
; 1430 : 				if(render && doc->getCatalog() && doc->getCatalog()->isOk()){

	jmp	$LN83@RenderingT@2
$LN5@RenderingT@2:
	cmp	BYTE PTR _render$[esp+192], 0
	je	$LN137@RenderingT@2
	mov	eax, DWORD PTR _doc$[esp+192]
	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	je	$LN137@RenderingT@2
	cmp	DWORD PTR [eax+176], 0
	je	$LN137@RenderingT@2

; 1431 : 					Page *p = doc->getCatalog()->getPage(page);

	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+esi*4-4]

; 1432 : 					if(p && p->isOk()){

	test	ecx, ecx
	je	$LN137@RenderingT@2
	cmp	DWORD PTR [ecx+64], 0
	je	$LN137@RenderingT@2

; 1433 : 						p->display(param->out->getSplash(),renderDPI, renderDPI, 0,
; 1434 : 										gFalse, gTrue, gFalse,doc->getCatalog());

	mov	edx, DWORD PTR [edi+28]
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR [edx+12]
	push	0
	push	1
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	eax
	call	?display@Page@@QAEXPAVOutputDev@@NNHHHHPAVCatalog@@P6AHPAX@Z2@Z ; Page::display

; 1435 : 						param->out->SetDataPtr(param->out->getSplash()->getBitmap()->getDataPtr());

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+180]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+8], ecx

; 1436 : 							param->out->setDefCTM(param->out->getSplash()->getDefCTM());

	mov	eax, DWORD PTR [edi+28]
	mov	edx, DWORD PTR [eax+12]
	add	edx, 8
	mov	DWORD PTR [eax+16], edx

; 1437 : 							param->out->setDefICTM(param->out->getSplash()->getDefICTM());

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 56					; 00000038H
	mov	DWORD PTR [eax+20], ecx

; 1438 : 							param->out->setSize(param->out->getSplash()->getBitmapWidth(),param->out->getSplash()->getBitmapHeight());

	mov	esi, DWORD PTR [edi+28]
	mov	ebx, DWORD PTR [esi+12]
	mov	ecx, ebx
	call	?getBitmapWidth@SplashOutputDev@@QAEHXZ	; SplashOutputDev::getBitmapWidth
	mov	DWORD PTR tv950[esp+192], eax
	fild	DWORD PTR tv950[esp+192]
	mov	ecx, ebx
	fstp	QWORD PTR $T192766[esp+192]
	call	?getBitmapHeight@SplashOutputDev@@QAEHXZ ; SplashOutputDev::getBitmapHeight
	mov	DWORD PTR tv947[esp+192], eax
	fild	DWORD PTR tv947[esp+192]
	fld	QWORD PTR $T192766[esp+192]
	fstp	QWORD PTR [esi+24]
	fstp	QWORD PTR [esi+32]
	jmp	SHORT $LN83@RenderingT@2
$LN137@RenderingT@2:

; 1432 : 					if(p && p->isOk()){

	fstp	ST(0)

; 1438 : 							param->out->setSize(param->out->getSplash()->getBitmapWidth(),param->out->getSplash()->getBitmapHeight());

$LN83@RenderingT@2:

; 1439 : 					}
; 1440 : 				}				
; 1441 : 				
; 1442 : 				int bmWidth = param->out->GetWidth();

	mov	esi, DWORD PTR [edi+28]
	fld	QWORD PTR [esi+24]
	call	__ftol2_sse

; 1443 : 				int bmHeight = param->out->GetHeight();					

	fld	QWORD PTR [esi+32]
	mov	ebx, eax
	mov	DWORD PTR _bmWidth$86159[esp+192], ebx
	call	__ftol2_sse

; 1444 : 
; 1445 : 				PageMemory *bmpMem = new PageMemory();

	push	136					; 00000088H
	mov	DWORD PTR _bmHeight$86160[esp+196], eax
	call	??2@YAPAXI@Z				; operator new
	xor	esi, esi
	add	esp, 4
	cmp	eax, esi
	je	SHORT $LN16@RenderingT@2
	fld1
	mov	DWORD PTR [eax], esi
	fst	DWORD PTR [eax+8]
	mov	DWORD PTR [eax+4], esi
	fstp	DWORD PTR [eax+12]
	mov	DWORD PTR [eax+128], esi
	fldz
	mov	DWORD PTR [eax+132], esi
	fstp	QWORD PTR [eax+16]
	mov	esi, eax
$LN16@RenderingT@2:

; 1446 : 				bmpMem->Create(param->hDC,bmWidth,bmHeight,renderDPI, param->out->getDefCTM(),param->out->getDefICTM());	

	fld	QWORD PTR _renderDPI$[esp+192]
	mov	edx, DWORD PTR _bmHeight$86160[esp+192]
	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [edi+36]
	mov	edi, DWORD PTR [eax+20]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	push	ebx
	mov	ebx, DWORD PTR [eax+16]
	push	ecx
	call	?Create@PageMemory@@QAEHPAUHDC__@@HHNPAN1@Z ; PageMemory::Create

; 1447 : 
; 1448 : 				//********START DIB
; 1449 : 				bmpMem->SetDimensions(bmWidth,bmHeight,renderDPI);

	fld1
	mov	edx, DWORD PTR _bmHeight$86160[esp+192]
	fst	DWORD PTR [esi+8]
	mov	ebx, DWORD PTR _bmWidth$86159[esp+192]
	fstp	DWORD PTR [esi+12]
	fld	QWORD PTR _renderDPI$[esp+192]

; 1450 : 				bmpMem->SetDIBits(param->hDC,(void *)param->out->GetDataPtr());

	mov	edi, DWORD PTR _lpParam$86144[esp+192]
	fstp	QWORD PTR [esi+16]
	mov	DWORD PTR [esi+128], ebx
	mov	DWORD PTR [esi+132], edx
	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [edi+36]
	push	ecx
	push	edx
	call	?SetDIBits@PageMemory@@QAEHPAUHDC__@@PBX@Z ; PageMemory::SetDIBits

; 1451 : 
; 1452 : 				bmpMem->Draw(param->hDC,0,0,bmWidth,bmHeight,0,0);

	mov	eax, DWORD PTR _bmHeight$86160[esp+192]
	push	0
	push	0
	push	eax
	push	ebx
	mov	ebx, DWORD PTR [edi+36]
	push	0
	push	0
	call	?Draw@PageMemory@@QAEHPAUHDC__@@HHHHHH@Z ; PageMemory::Draw

; 1453 : 				
; 1454 : 				bmpMem->Dispose();

	mov	eax, DWORD PTR [esi+4]
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN99@RenderingT@2
	push	eax
	call	DWORD PTR __imp__DeleteObject@4
$LN99@RenderingT@2:

; 1455 : 				delete bmpMem;

	mov	eax, ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi], ebx
	cmp	eax, ebx
	je	SHORT $LN107@RenderingT@2
	push	eax
	call	DWORD PTR __imp__DeleteObject@4
$LN107@RenderingT@2:
	push	esi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi], ebx
	call	??3@YAXPAX@Z				; operator delete

; 1456 : 				bmpMem=0;
; 1457 : 				bSuccess=true;
; 1458 : 			}
; 1459 : 			if(param){
; 1460 : 				param->que->delQueue.Delete(0);

	mov	esi, DWORD PTR [edi+32]
	add	esp, 4
	add	esi, 56					; 00000038H
	call	?Delete@?$DynArray@PAX@@QAEXI@Z		; DynArray<void *>::Delete

; 1461 : 				if(param->finishNotify)

	mov	eax, DWORD PTR [edi+24]
	cmp	eax, ebx
	je	SHORT $LN1@RenderingT@2

; 1462 : 					 param->finishNotify(page,bSuccess);

	mov	ecx, DWORD PTR _page$[esp+192]
	push	1
	push	ecx
	call	eax
$LN1@RenderingT@2:

; 1463 : 				delete param;

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1464 : 				param=0;
; 1465 : 			}
; 1466 : 		}

	jmp	$LL9@RenderingT@2
?RenderingThreadThumb@AFPDFDoc@@KAIPAX@Z ENDP		; AFPDFDoc::RenderingThreadThumb
_TEXT	ENDS
PUBLIC	?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z		; AFPDFDoc::DrawPage
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\pagememory.cpp
xdata$x	SEGMENT
__unwindtable$?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z$1
__ehfuncinfo$?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z
_TEXT	SEGMENT
_paperColor$ = -128					; size = 3
$T193038 = -124						; size = 8
$T192854 = -124						; size = 4
_ctm$86111 = -116					; size = 48
_ictm$86112 = -68					; size = 48
__$EHRec$ = -12						; size = 12
_bmHeight$86118 = 8					; size = 4
_page$ = 8						; size = 4
_hdc$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
tv1021 = 24						; size = 4
tv1019 = 24						; size = 4
_bmWidth$86117 = 24					; size = 4
_doc$86101 = 24						; size = 4
_bThread$ = 24						; size = 1
_callback$ = 28						; size = 4
_page$86103 = 32					; size = 4
$T192858 = 32						; size = 4
_bAntialising$ = 32					; size = 1
_renderDPI$86102 = 36					; size = 8
_dpi$ = 36						; size = 8
?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z PROC		; AFPDFDoc::DrawPage, COMDAT
; _this$ = ecx

; 1267 : 	{

	push	-1
	push	__ehhandler$?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+152]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 1268 : 		//Establecemos el color del papel
; 1269 : 		SplashColor paperColor;
; 1270 : 		paperColor[0] = 0xff;
; 1271 : 		paperColor[1] = 0xff;
; 1272 : 		paperColor[2] = 0xff;
; 1273 : 
; 1274 : 		PDFDoc *doc = m_PDFDoc; //this->createDoc(NULL);

	mov	ebx, DWORD PTR [edi+332]
	mov	al, 255					; 000000ffH

; 1275 : 		
; 1276 : 		m_thumbOut = new SplashOutputDev(splashModeBGR8, 4, gFalse, paperColor,gTrue,bAntialising?1:0);

	push	248					; 000000f8H
	mov	BYTE PTR _paperColor$[esp+156], al
	mov	BYTE PTR _paperColor$[esp+157], al
	mov	BYTE PTR _paperColor$[esp+158], al
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T192854[esp+152], eax
	mov	DWORD PTR __$EHRec$[esp+160], 0
	test	eax, eax
	je	SHORT $LN15@DrawPage
	xor	ecx, ecx
	cmp	BYTE PTR _bAntialising$[esp+148], cl
	lea	edx, DWORD PTR _paperColor$[esp+152]
	setne	cl
	push	ecx
	push	1
	push	edx
	push	0
	push	4
	push	3
	mov	ecx, eax
	call	??0SplashOutputDev@@QAE@W4SplashColorMode@@HHPAEHH@Z ; SplashOutputDev::SplashOutputDev
	jmp	SHORT $LN16@DrawPage
$LN15@DrawPage:
	xor	eax, eax
$LN16@DrawPage:
	mov	DWORD PTR __$EHRec$[esp+160], -1

; 1277 : 		
; 1278 : 		if(bAntialising)

	cmp	BYTE PTR _bAntialising$[esp+148], 0
	mov	DWORD PTR [edi+336], eax

; 1279 : 			m_thumbOut->setVectorAntialias(gTrue);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+316]
	je	SHORT $LN12@DrawPage
	push	1

; 1280 : 		else

	jmp	SHORT $LN180@DrawPage
$LN12@DrawPage:

; 1281 : 			m_thumbOut->setVectorAntialias(gFalse);

	push	0
$LN180@DrawPage:
	call	eax

; 1282 : 		m_thumbOut->startDoc(doc->getXRef());

	mov	eax, DWORD PTR [ebx+24]
	mov	ecx, DWORD PTR [edi+336]
	push	eax
	call	?startDoc@SplashOutputDev@@QAEXPAVXRef@@@Z ; SplashOutputDev::startDoc

; 1283 : 	
; 1284 : 		SplashOutputDev *out=m_thumbOut;

	mov	ebp, DWORD PTR [edi+336]

; 1285 : 		out->clearModRegion();

	mov	ecx, ebp
	call	?clearModRegion@SplashOutputDev@@QAEXXZ	; SplashOutputDev::clearModRegion

; 1286 : 		
; 1287 : 		threadParamThumb *tp=new threadParamThumb((HDC)hdc,out,doc,page,&m_QueuedThumbs,callback);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T192858[esp+148], esi
	mov	DWORD PTR __$EHRec$[esp+160], 1
	test	esi, esi
	je	SHORT $LN17@DrawPage
	mov	ecx, DWORD PTR _callback$[esp+148]
	mov	eax, DWORD PTR _hdc$[esp+148]
	push	ecx
	lea	edx, DWORD PTR [edi+252]
	push	edx
	push	ebp
	push	eax
	mov	eax, DWORD PTR _page$[esp+164]
	mov	ecx, ebx
	call	??0threadParamThumb@@QAE@PAUHDC__@@PAVSplashOutputDev@@PAVPDFDoc@@HPAVQueue@@PAX@Z ; threadParamThumb::threadParamThumb
	mov	ebp, eax
	jmp	SHORT $LN18@DrawPage
$LN17@DrawPage:
	xor	ebp, ebp
$LN18@DrawPage:

; 1288 : 		//Calculate DPI
; 1289 : 		if(width >0 && height >0 && dpi==0){

	cmp	DWORD PTR _width$[esp+148], 0
	mov	DWORD PTR __$EHRec$[esp+160], -1
	fld	QWORD PTR __real@4032000000000000
	fldz
	jle	SHORT $LN135@DrawPage
	cmp	DWORD PTR _height$[esp+148], 0
	jle	SHORT $LN135@DrawPage
	fld	ST(0)
	fld	QWORD PTR _dpi$[esp+148]
	fucom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@DrawPage

; 1290 : 			double ow = doc->getPageCropWidth(page); //Original size at 72 dpi

	mov	ecx, DWORD PTR [ebx+28]
	fstp	ST(0)
	mov	edx, DWORD PTR [ecx+4]

; 1291 : 			//double oh = doc->getPageCropHeight(page);
; 1292 : 			dpi =  72.0*width/ow; //Same DPI for width and height

	fild	DWORD PTR _width$[esp+148]
	mov	eax, DWORD PTR _page$[esp+148]
	mov	eax, DWORD PTR [edx+eax*4-4]
	mov	eax, DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4052000000000000
	fld	QWORD PTR [eax+48]
	fsub	QWORD PTR [eax+32]
	fdivp	ST(1), ST(0)
	jmp	SHORT $LN10@DrawPage
$LN135@DrawPage:
	fld	QWORD PTR _dpi$[esp+148]
$LN10@DrawPage:

; 1293 : 		}
; 1294 : 		tp->renderDPI = IFZERO(dpi,18);

	fld	ST(1)
	fucomp	ST(1)
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@DrawPage
	fstp	ST(0)
	fld	ST(1)
$LN20@DrawPage:

; 1295 : 		tp->pdfDoc = this;
; 1296 : 		if(bThread){

	cmp	BYTE PTR _bThread$[esp+148], 0
	fst	QWORD PTR [ebp]
	mov	DWORD PTR [ebp+40], edi
	je	SHORT $LN9@DrawPage

; 1297 : 			if(m_renderThumbs==0){

	cmp	DWORD PTR [edi+248], 0
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
	jne	SHORT $LN8@DrawPage

; 1298 : 				m_renderThumbs = ::CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)AFPDFDoc::RenderingThreadThumb,(LPVOID)&m_QueuedThumbs,CREATE_SUSPENDED,0);

	push	0
	push	4
	lea	ecx, DWORD PTR [edi+252]
	push	ecx
	push	OFFSET ?RenderingThreadThumb@AFPDFDoc@@KAIPAX@Z ; AFPDFDoc::RenderingThreadThumb
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24

; 1299 : 				::SetThreadPriority(m_renderThumbs,THREAD_PRIORITY_NORMAL);

	push	0
	push	eax
	mov	DWORD PTR [edi+248], eax
	call	DWORD PTR __imp__SetThreadPriority@8

; 1300 : 				::ResumeThread(m_renderThumbs);

	mov	edx, DWORD PTR [edi+248]
	push	edx
	call	DWORD PTR __imp__ResumeThread@4
$LN8@DrawPage:

; 1301 : 			}
; 1302 : 
; 1303 : 			if(!m_QueuedThumbs.AddTail(tp))

	push	ebp
	lea	eax, DWORD PTR [edi+252]
	call	?AddTail@Queue@@QAEHPAX@Z		; Queue::AddTail
	neg	eax
	sbb	eax, eax
	neg	eax
	dec	eax

; 1304 : 				return -1;
; 1305 : 
; 1306 : 			return 0;

	jmp	$LN13@DrawPage
$LN9@DrawPage:

; 1307 : 		}else{
; 1308 : 			PDFDoc *doc;
; 1309 : 			double renderDPI=18;
; 1310 : 			int page=0;
; 1311 : 			bool render=true;
; 1312 : 			doc=(PDFDoc *)tp->doc;

	mov	eax, DWORD PTR [ebp+16]

; 1313 : 			renderDPI =tp->renderDPI;

	fst	QWORD PTR _renderDPI$86102[esp+148]

; 1314 : 			page = tp->pageToRender;

	mov	esi, DWORD PTR [ebp+44]

; 1315 : 			renderDPI=IFZERO(renderDPI,18);

	fucom	ST(1)
	mov	DWORD PTR _doc$86101[esp+148], eax
	mov	DWORD PTR _page$86103[esp+148], esi
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN154@DrawPage
	fstp	ST(0)
	fst	QWORD PTR _renderDPI$86102[esp+148]
	jmp	SHORT $LN21@DrawPage
$LN154@DrawPage:
	fstp	ST(1)
$LN21@DrawPage:

; 1316 : 			page=MAX(1,page);

	cmp	esi, 1
	jge	SHORT $LN23@DrawPage
	mov	DWORD PTR _page$86103[esp+148], 1
	mov	esi, DWORD PTR _page$86103[esp+148]
$LN23@DrawPage:

; 1317 : #ifdef _MUPDF
; 1318 : 				if(SupportsMuPDF() && GetUseMuPDF()){

	cmp	DWORD PTR [edi+228], 0
	jne	SHORT $LN45@DrawPage
	cmp	DWORD PTR [edi+236], 0
	jne	$LN133@DrawPage
$LN45@DrawPage:
	cmp	BYTE PTR [edi+154], 0
	je	$LN133@DrawPage

; 1319 : 					if(LoadFromMuPDF())

	mov	ebx, edi
	fstp	ST(0)
	call	?LoadFromMuPDF@AFPDFDoc@@QAE_NXZ	; AFPDFDoc::LoadFromMuPDF

; 1320 : 					{
; 1321 : 						fz_pixmap *im = _mupdf->display(tp->out,page,m_Rotation,renderDPI/72,callbackAbortDisplay,this);

	fld	QWORD PTR _renderDPI$86102[esp+148]
	test	al, al
	je	$LN133@DrawPage
	fdiv	QWORD PTR __real@4052000000000000
	mov	ecx, DWORD PTR [edi+524]
	mov	edx, DWORD PTR [ebp+28]
	sub	esp, 8
	mov	eax, esi
	fstp	QWORD PTR [esp]
	push	ecx
	mov	ecx, DWORD PTR [edi+8]
	push	edx
	call	?display@mupdfEngine@@QAEPAUfz_pixmap_s@@PAVAuxOutputDev@@HHNP6AHPAX@Z1@Z ; mupdfEngine::display

; 1322 : 						tp->out->SetDataPtr((void *)im->samples);

	mov	edx, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR [ebp+28]
	mov	DWORD PTR [ecx+8], edx

; 1323 : 						tp->out->setSize(im->w,im->h);

	fild	DWORD PTR [eax+12]
	fild	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ebp+28]

; 1324 : 						tp->out->setPixmap(im);
; 1325 : 						Page *p = doc->getCatalog()->getPage(page);
; 1326 : 						double ctm[6];
; 1327 : 						double ictm[6];
; 1328 : 						p->getDefaultCTM(ctm,renderDPI,renderDPI,m_Rotation,gFalse,gTrue);

	push	1
	push	0
	fstp	QWORD PTR [ecx+24]
	fstp	QWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [ebp+28]
	fld	QWORD PTR _renderDPI$86102[esp+156]
	mov	DWORD PTR [ecx+44], eax
	mov	edx, DWORD PTR [edi+524]
	mov	ecx, DWORD PTR _doc$86101[esp+156]
	push	edx
	mov	edx, DWORD PTR [ecx+28]
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	lea	eax, DWORD PTR _ctm$86111[esp+180]
	fstp	QWORD PTR [esp]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi*4-4]
	call	?getDefaultCTM@Page@@QAEXPANNNHHH@Z	; Page::getDefaultCTM

; 1329 : 						tp->out->setDefCTM(ctm);

	mov	ecx, DWORD PTR [ebp+28]
	lea	edx, DWORD PTR _ctm$86111[esp+152]
	mov	DWORD PTR [ecx+16], edx

; 1330 : 						//Invert CTM
; 1331 : 						double det = 1 / (ctm[0] * ctm[3] - ctm[1] * ctm[2]);

	fld	QWORD PTR _ctm$86111[esp+176]
	fld	ST(0)
	fld	QWORD PTR _ctm$86111[esp+152]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _ctm$86111[esp+168]
	fld	ST(0)
	fld	QWORD PTR _ctm$86111[esp+160]
	fmul	ST(1), ST(0)
	fxch	ST(4)
	fsubrp	ST(1), ST(0)
	fld1
	fdivrp	ST(1), ST(0)

; 1332 : 						ictm[0] = ctm[3] * det;

	fld	ST(4)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _ictm$86112[esp+152]

; 1333 : 						ictm[1] = -ctm[1] * det;

	fld	ST(3)
	fmul	ST(0), ST(1)
	fchs
	fstp	QWORD PTR _ictm$86112[esp+160]

; 1334 : 						ictm[2] = -ctm[2] * det;

	fld	ST(1)
	fmul	ST(0), ST(1)
	fchs
	fstp	QWORD PTR _ictm$86112[esp+168]

; 1335 : 						ictm[3] = ctm[0] * det;

	fld	ST(2)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _ictm$86112[esp+176]

; 1336 : 						ictm[4] = (ctm[2] * ctm[5] - ctm[3] * ctm[4]) * det;

	fld	QWORD PTR _ctm$86111[esp+192]
	fld	ST(0)
	fmulp	ST(3), ST(0)
	fld	QWORD PTR _ctm$86111[esp+184]
	fld	ST(0)
	fmulp	ST(7), ST(0)
	fxch	ST(3)
	fsubrp	ST(6), ST(0)
	fxch	ST(5)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _ictm$86112[esp+184]

; 1337 : 						ictm[5] = (ctm[1] * ctm[4] - ctm[0] * ctm[5]) * det;

	fxch	ST(1)
	fmulp	ST(3), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fmulp	ST(1), ST(0)

; 1338 : 						tp->out->setDefICTM(ictm);

	mov	eax, DWORD PTR [ebp+28]
	fstp	QWORD PTR _ictm$86112[esp+192]
	lea	ecx, DWORD PTR _ictm$86112[esp+152]
	mov	DWORD PTR [eax+20], ecx

; 1339 : 						render =false;
; 1340 : 					}
; 1341 : 				}
; 1342 : #endif			
; 1343 : 			if(render && doc->getCatalog() && doc->getCatalog()->isOk()){

	jmp	$LN106@DrawPage
$LN133@DrawPage:
	mov	edx, DWORD PTR _doc$86101[esp+148]
	mov	eax, DWORD PTR [edx+28]
	test	eax, eax
	je	$LN173@DrawPage
	cmp	DWORD PTR [eax+176], 0
	je	$LN173@DrawPage

; 1344 : 				Page *p = doc->getCatalog()->getPage(page);

	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+esi*4-4]

; 1345 : 				if(p && p->isOk()){

	test	ecx, ecx
	je	$LN173@DrawPage
	cmp	DWORD PTR [ecx+64], 0
	je	$LN173@DrawPage

; 1346 : 					p->display(tp->out->getSplash(),renderDPI, renderDPI, 0,
; 1347 : 									gFalse, gTrue, gFalse,doc->getCatalog() /*,
; 1348 : 										callbackAbortDisplay,pdfDoc*/);

	mov	edx, DWORD PTR [ebp+28]
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR [edx+12]
	push	0
	push	1
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	eax
	call	?display@Page@@QAEXPAVOutputDev@@NNHHHHPAVCatalog@@P6AHPAX@Z2@Z ; Page::display

; 1349 : 					tp->out->SetDataPtr(tp->out->getSplash()->getBitmap()->getDataPtr());

	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+180]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+8], ecx

; 1350 : 						tp->out->setDefCTM(tp->out->getSplash()->getDefCTM());

	mov	eax, DWORD PTR [ebp+28]
	mov	edx, DWORD PTR [eax+12]
	add	edx, 8
	mov	DWORD PTR [eax+16], edx

; 1351 : 						tp->out->setDefICTM(tp->out->getSplash()->getDefICTM());

	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 56					; 00000038H
	mov	DWORD PTR [eax+20], ecx

; 1352 : 						tp->out->setSize(tp->out->getSplash()->getBitmapWidth(),tp->out->getSplash()->getBitmapHeight());

	mov	esi, DWORD PTR [ebp+28]
	mov	edi, DWORD PTR [esi+12]
	mov	ecx, edi
	call	?getBitmapWidth@SplashOutputDev@@QAEHXZ	; SplashOutputDev::getBitmapWidth
	mov	DWORD PTR tv1021[esp+148], eax
	fild	DWORD PTR tv1021[esp+148]
	mov	ecx, edi
	fstp	QWORD PTR $T193038[esp+152]
	call	?getBitmapHeight@SplashOutputDev@@QAEHXZ ; SplashOutputDev::getBitmapHeight
	mov	DWORD PTR tv1019[esp+148], eax
	fild	DWORD PTR tv1019[esp+148]
	fld	QWORD PTR $T193038[esp+152]
	fstp	QWORD PTR [esi+24]
	fstp	QWORD PTR [esi+32]
	jmp	SHORT $LN106@DrawPage
$LN173@DrawPage:

; 1345 : 				if(p && p->isOk()){

	fstp	ST(0)

; 1352 : 						tp->out->setSize(tp->out->getSplash()->getBitmapWidth(),tp->out->getSplash()->getBitmapHeight());

$LN106@DrawPage:

; 1353 : 				}
; 1354 : 			}
; 1355 : 
; 1356 : 
; 1357 : 			int bmWidth = tp->out->GetWidth();

	mov	esi, DWORD PTR [ebp+28]
	fld	QWORD PTR [esi+24]
	call	__ftol2_sse

; 1358 : 			int bmHeight = tp->out->GetHeight();					

	fld	QWORD PTR [esi+32]
	mov	edi, eax
	mov	DWORD PTR _bmWidth$86117[esp+148], edi
	call	__ftol2_sse
	mov	ebx, eax

; 1359 : 
; 1360 : 			PageMemory *bmpMem = new PageMemory();

	push	136					; 00000088H
	mov	DWORD PTR _bmHeight$86118[esp+152], ebx
	call	??2@YAPAXI@Z				; operator new
	fld1
	xor	esi, esi
	add	esp, 4
	cmp	eax, esi
	je	SHORT $LN178@DrawPage
	fst	DWORD PTR [eax+8]
	mov	DWORD PTR [eax], esi
	fstp	DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], esi
	fldz
	mov	DWORD PTR [eax+128], esi
	mov	DWORD PTR [eax+132], esi
	fstp	QWORD PTR [eax+16]
	mov	esi, eax
	jmp	SHORT $LN26@DrawPage
$LN178@DrawPage:
	fstp	ST(0)
$LN26@DrawPage:

; 1361 : 			bmpMem->Create(tp->hDC,bmWidth,bmHeight,renderDPI, tp->out->getDefCTM(),tp->out->getDefICTM());	

	fld	QWORD PTR _renderDPI$86102[esp+148]
	mov	eax, DWORD PTR [ebp+28]
	mov	edx, DWORD PTR [ebp+36]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ebx
	mov	ebx, DWORD PTR [eax+16]
	push	edi
	mov	edi, DWORD PTR [eax+20]
	push	edx
	call	?Create@PageMemory@@QAEHPAUHDC__@@HHNPAN1@Z ; PageMemory::Create

; 1362 : 
; 1363 : 			//********START DIB
; 1364 : 			bmpMem->SetDimensions(bmWidth,bmHeight,renderDPI);

	fld1
	mov	edi, DWORD PTR _bmWidth$86117[esp+148]
	fst	DWORD PTR [esi+8]
	mov	ebx, DWORD PTR _bmHeight$86118[esp+148]
	fstp	DWORD PTR [esi+12]
	fld	QWORD PTR _renderDPI$86102[esp+148]
	mov	DWORD PTR [esi+128], edi
	fstp	QWORD PTR [esi+16]
	mov	DWORD PTR [esi+132], ebx

; 1365 : 			bmpMem->SetDIBits(tp->hDC,(void *)tp->out->GetDataPtr());

	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ebp+36]
	push	ecx
	push	edx
	call	?SetDIBits@PageMemory@@QAEHPAUHDC__@@PBX@Z ; PageMemory::SetDIBits

; 1366 : 
; 1367 : 			bmpMem->Draw(tp->hDC,0,0,bmWidth,bmHeight,0,0);

	push	0
	push	0
	push	ebx
	mov	ebx, DWORD PTR [ebp+36]
	push	edi
	push	0
	push	0
	call	?Draw@PageMemory@@QAEHPAUHDC__@@HHHHHH@Z ; PageMemory::Draw

; 1368 : 			
; 1369 : 			bmpMem->Dispose();

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR __imp__DeleteObject@4
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN122@DrawPage
	push	eax
	call	edi
$LN122@DrawPage:

; 1370 : 			delete bmpMem;

	mov	eax, ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi], ebx
	cmp	eax, ebx
	je	SHORT $LN130@DrawPage
	push	eax
	call	edi
$LN130@DrawPage:
	push	esi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi], ebx
	call	??3@YAXPAX@Z				; operator delete

; 1371 : 
; 1372 : 			if( tp->finishNotify )

	mov	eax, DWORD PTR [ebp+24]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN1@DrawPage

; 1373 : 				tp->finishNotify( page, true );

	mov	ecx, DWORD PTR _page$86103[esp+148]
	push	1
	push	ecx
	call	eax
$LN1@DrawPage:

; 1374 : 
; 1375 : 			delete tp;

	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1376 : 
; 1377 : 			return 0;

	xor	eax, eax
$LN13@DrawPage:

; 1378 : 		}
; 1379 : 		
; 1380 : 		return -1;
; 1381 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+152]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 132				; 00000084H
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z$0:
	mov	eax, DWORD PTR $T192854[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z$1:
	mov	eax, DWORD PTR $T192858[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-136]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DrawPage@AFPDFDoc@@QAEJHJHHN_NPAX0@Z ENDP		; AFPDFDoc::DrawPage
PUBLIC	?RenderPage@AFPDFDoc@@QAEJJ_N0@Z		; AFPDFDoc::RenderPage
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z$4
	DD	0ffffffffH
	DD	00H
__catchsym$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z$5 DD 00H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	FLAT:__catch$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z$0
__tryblocktable$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z DD 00H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z$5
__ehfuncinfo$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?RenderPage@AFPDFDoc@@QAEJJ_N0@Z
_TEXT	SEGMENT
_newbytes$85999 = -40					; size = 8
tv720 = -32						; size = 8
tv722 = -28						; size = 4
$T193155 = -28						; size = 4
_paperColor$85997 = -24					; size = 3
_exitcode$86006 = -20					; size = 4
tv725 = -18						; size = 2
__$EHRec$ = -16						; size = 16
$T193157 = 8						; size = 4
_bForce$ = 8						; size = 1
?RenderPage@AFPDFDoc@@QAEJJ_N0@Z PROC			; AFPDFDoc::RenderPage, COMDAT
; _this$ = ecx

; 1098 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 1099 : 
; 1100 : 		if (m_PDFDoc != NULL) {

	mov	eax, DWORD PTR [edi+332]
	xor	ebx, ebx
	cmp	eax, ebx
	je	__tryend$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z$1

; 1101 : 
; 1102 : 			m_PageRenderedByThread=false;
; 1103 : 			
; 1104 : 			//Establecemos el color del papel
; 1105 : 			SplashColor paperColor;
; 1106 : 			paperColor[0] = 0xff;
; 1107 : 			paperColor[1] = 0xff;
; 1108 : 			paperColor[2] = 0xff;
; 1109 : 
; 1110 : 			if(m_splashOut!=0){

	mov	edx, DWORD PTR [edi+344]
	mov	cl, 255					; 000000ffH
	mov	BYTE PTR [edi+168], bl
	mov	BYTE PTR _paperColor$85997[ebp], cl
	mov	BYTE PTR _paperColor$85997[ebp+1], cl
	mov	BYTE PTR _paperColor$85997[ebp+2], cl
	cmp	edx, ebx
	je	$LN11@RenderPage

; 1111 : 				//Heuristically check if we have enough memory ;-)
; 1112 : 				double newbytes = (m_renderDPI/72.0)*(m_renderDPI/72.0) * m_PDFDoc->getPageCropWidth(m_CurrentPage)* m_PDFDoc->getPageCropHeight(m_CurrentPage); //new approx. number of pixels

	fld	QWORD PTR [edi+536]
	mov	eax, DWORD PTR [eax+28]
	fdiv	QWORD PTR __real@4052000000000000
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [edi+504]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	fld	QWORD PTR [ecx+48]
	fsub	QWORD PTR [ecx+32]
	fld	ST(1)
	fmulp	ST(2), ST(0)

; 1113 : 				newbytes = newbytes * 3 + newbytes*2; //24-bit splashbitmap, 16-bit gdi-bitmap
; 1114 : 				newbytes=(newbytes*1.2); //Safety area;
; 1115 : 				newbytes -= m_splashOut->GetWidth()*m_splashOut->GetHeight()*3; //substract old 24-bit splash bitmap size
; 1116 : 				void* testAllocation = malloc((size_t)(2*newbytes));

	fnstcw	WORD PTR tv725[ebp]
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [eax+56]
	fsub	QWORD PTR [eax+40]
	movzx	eax, WORD PTR tv725[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv722[ebp], eax
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [edx+24]
	fld	QWORD PTR [edx+32]
	fld	ST(2)
	fld	QWORD PTR __real@4008000000000000
	fmul	ST(1), ST(0)
	fld	QWORD PTR __real@4000000000000000
	fmul	ST(5), ST(0)
	fxch	ST(2)
	faddp	ST(5), ST(0)
	fxch	ST(4)
	fmul	QWORD PTR __real@3ff3333333333333
	fxch	ST(2)
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fmulp	ST(3), ST(0)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _newbytes$85999[ebp]
	fmulp	ST(1), ST(0)
	fldcw	WORD PTR tv722[ebp]
	fistp	QWORD PTR tv720[ebp]
	mov	ecx, DWORD PTR tv720[ebp]
	push	ecx
	fldcw	WORD PTR tv725[ebp]
	call	DWORD PTR __imp__malloc
	mov	ecx, eax
	add	esp, 4

; 1117 : 				if (testAllocation==0 && newbytes>0){

	cmp	ecx, ebx
	jne	SHORT $LN12@RenderPage
	fldz
	fcomp	QWORD PTR _newbytes$85999[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@RenderPage

; 1118 : 					//We better dont zoom this far in!
; 1119 : 					return errOutOfMemory+1;

	mov	eax, 10002				; 00002712H

; 1215 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@RenderPage:

; 1120 : 				} else {
; 1121 : 					free (testAllocation);

	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN11@RenderPage:

; 1122 : 				}
; 1123 : 			}
; 1124 : 			try{

	mov	DWORD PTR __$EHRec$[ebp+12], ebx

; 1125 : 				//Wait for previous threads and delete them
; 1126 : 				if (m_renderingThread!=0)

	mov	eax, DWORD PTR [edi+240]
	cmp	eax, ebx
	je	SHORT $LN9@RenderPage

; 1127 : 				{					
; 1128 : 					DWORD exitcode=0;
; 1129 : 					GetExitCodeThread(m_renderingThread,&exitcode);

	lea	edx, DWORD PTR _exitcode$86006[ebp]
	push	edx
	push	eax
	mov	DWORD PTR _exitcode$86006[ebp], ebx
	call	DWORD PTR __imp__GetExitCodeThread@8

; 1130 : 					
; 1131 : 					//Cancel if the next page will not be valid
; 1132 : 					if(exitcode==STILL_ACTIVE){

	cmp	DWORD PTR _exitcode$86006[ebp], 259	; 00000103H
	jne	SHORT $LN6@RenderPage

; 1133 : 						if(m_CurrentPage!=m_PageToRenderByThread ){

	mov	eax, DWORD PTR [edi+504]

; 1134 : 							InterlockedExchange(&this->g_lLocker,1);

	push	1
	cmp	eax, DWORD PTR [edi+156]
	je	SHORT $LN7@RenderPage
	lea	ecx, DWORD PTR [edi+164]
	push	ecx
	call	DWORD PTR __imp__InterlockedExchange@8

; 1135 : 						}else{

	jmp	SHORT $LN6@RenderPage
$LN7@RenderPage:

; 1136 : 							 //hurry up!
; 1137 : 							SetThreadPriority(m_renderingThread,THREAD_PRIORITY_ABOVE_NORMAL);

	mov	edx, DWORD PTR [edi+240]
	push	edx
	call	DWORD PTR __imp__SetThreadPriority@8
$LN6@RenderPage:

; 1138 : 						}
; 1139 : 					}
; 1140 : 					//Wait to finish
; 1141 : 					WaitForSingleObject(this->hRenderFinished,INFINITE);

	mov	eax, DWORD PTR [edi+176]
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 1142 : 					CloseHandle(m_renderingThread);

	mov	ecx, DWORD PTR [edi+240]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 1143 : 					m_renderingThread=NULL;

	mov	DWORD PTR [edi+240], ebx
$LN9@RenderPage:

; 1144 : 				}
; 1145 : 				//Read from cache
; 1146 : 				m_Bitmap = GetBitmapCache(m_CurrentPage);

	xor	eax, eax
$LL59@RenderPage:
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN57@RenderPage
	mov	edx, DWORD PTR [edi+eax*4+80]
	cmp	edx, DWORD PTR [edi+504]
	jne	SHORT $LN58@RenderPage
	mov	eax, DWORD PTR [edi+eax*4+12]
	jmp	SHORT $LN60@RenderPage
$LN58@RenderPage:
	inc	eax
	jmp	SHORT $LL59@RenderPage
$LN57@RenderPage:
	xor	eax, eax
$LN60@RenderPage:

; 1147 : 				//Check if the last bitmap is valid
; 1148 : 				if ( bForce || (m_Bitmap && m_Bitmap->getRenderDPI() != m_renderDPI) ){

	cmp	BYTE PTR _bForce$[ebp], 0
	mov	DWORD PTR [edi+352], eax
	jne	SHORT $LN4@RenderPage
	cmp	eax, ebx
	je	SHORT $LN5@RenderPage
	fld	QWORD PTR [eax+16]
	fld	QWORD PTR [edi+536]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@RenderPage
$LN4@RenderPage:

; 1149 : 					m_Bitmap=0;

	mov	DWORD PTR [edi+352], ebx
$LN5@RenderPage:

; 1150 : 				}	
; 1151 : 
; 1152 : 				if(m_Bitmap==0){	

	cmp	DWORD PTR [edi+352], ebx
	jne	$LN3@RenderPage

; 1153 : 					m_PageToRenderByThread = m_CurrentPage;
; 1154 : 
; 1155 : 					if(m_splashOut>0){

	mov	esi, DWORD PTR [edi+344]
	mov	eax, DWORD PTR [edi+504]
	mov	DWORD PTR [edi+156], eax
	cmp	esi, ebx
	jbe	SHORT $LN2@RenderPage

; 1156 : 						delete m_splashOut;

	call	??_GAuxOutputDev@@QAEPAXI@Z

; 1157 : 						m_splashOut=0;

	mov	DWORD PTR [edi+344], ebx
$LN2@RenderPage:

; 1158 : 					}
; 1159 : 					threadParam *tp=new threadParam(this,m_PageToRenderByThread);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN19@RenderPage
	mov	ecx, DWORD PTR [edi+156]
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+8], 1
	mov	DWORD PTR [eax+12], ecx
	mov	ebx, eax
$LN19@RenderPage:

; 1160 : 					tp->out=new AuxOutputDev(new SplashOutputDev(splashModeBGR8, 4, gFalse, paperColor,gTrue,globalParams->getAntialias()));

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T193155[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN23@RenderPage
	push	248					; 000000f8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T193157[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	eax, ecx
	je	SHORT $LN21@RenderPage
	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	call	?getAntialias@GlobalParams@@QAEHXZ	; GlobalParams::getAntialias
	push	eax
	push	1
	lea	ecx, DWORD PTR _paperColor$85997[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T193157[ebp]
	push	0
	push	4
	push	3
	call	??0SplashOutputDev@@QAE@W4SplashColorMode@@HHPAEHH@Z ; SplashOutputDev::SplashOutputDev
	xor	ecx, ecx
	jmp	SHORT $LN22@RenderPage
$LN21@RenderPage:
	xor	eax, eax
$LN22@RenderPage:
	fldz
	mov	DWORD PTR [esi], OFFSET ??_7AuxOutputDev@@6B@
	fst	QWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], ecx
	fstp	QWORD PTR [esi+32]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	BYTE PTR [esi+40], 1
	mov	DWORD PTR [esi+44], ecx
	jmp	SHORT $LN24@RenderPage
$LN23@RenderPage:
	xor	esi, esi
$LN24@RenderPage:
	mov	BYTE PTR __$EHRec$[ebp+12], 0

; 1161 : 					tp->out->setVectorAntialias(globalParams->getVectorAntialias());

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	mov	DWORD PTR [ebx+4], esi
	call	?getVectorAntialias@GlobalParams@@QAEHXZ ; GlobalParams::getVectorAntialias
	mov	ecx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+316]
	call	eax

; 1162 : 					tp->out->startDoc(m_PDFDoc->getXRef());

	mov	ecx, DWORD PTR [edi+332]
	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ecx+12]
	push	eax
	call	?startDoc@SplashOutputDev@@QAEXPAVXRef@@@Z ; SplashOutputDev::startDoc

; 1163 : 					tp->out->clearModRegion();

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [eax+12]
	call	?clearModRegion@SplashOutputDev@@QAEXXZ	; SplashOutputDev::clearModRegion

; 1164 : 					tp->enablePreRender=false;
; 1165 : 					m_splashOut=tp->out;

	mov	edx, DWORD PTR [ebx+4]

; 1166 : 
; 1167 : 					InterlockedExchange(&this->g_lLocker,0);

	push	0
	lea	eax, DWORD PTR [edi+164]
	mov	BYTE PTR [ebx+8], 0
	push	eax
	mov	DWORD PTR [edi+344], edx
	call	DWORD PTR __imp__InterlockedExchange@8

; 1168 : 					//Render the page syncronized
; 1169 : 					AFPDFDoc::RenderingThread((LPVOID)tp);

	push	ebx
	call	?RenderingThread@AFPDFDoc@@KAIPAX@Z	; AFPDFDoc::RenderingThread
	add	esp, 4

; 1170 : 					//At this point the m_Bitmap now contains the full page
; 1171 : 					delete tp;

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1172 : 					m_Bitmap=GetBitmapCache(m_CurrentPage);

	xor	eax, eax
$LL79@RenderPage:
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN77@RenderPage
	mov	ecx, DWORD PTR [edi+eax*4+80]
	cmp	ecx, DWORD PTR [edi+504]
	jne	SHORT $LN78@RenderPage
	mov	eax, DWORD PTR [edi+eax*4+12]
	jmp	SHORT $LN80@RenderPage
$LN78@RenderPage:
	inc	eax
	jmp	SHORT $LL79@RenderPage
$LN77@RenderPage:
	xor	eax, eax
$LN80@RenderPage:
	mov	DWORD PTR [edi+352], eax
	xor	ebx, ebx
$LN3@RenderPage:

; 1173 : 					
; 1174 : 				} 
; 1175 : 				//Update Size
; 1176 : 				if(m_Bitmap){

	mov	eax, DWORD PTR [edi+352]
	cmp	eax, ebx
	je	SHORT $LN1@RenderPage

; 1177 : 					m_PageWidth = m_Bitmap->Width;

	mov	edx, DWORD PTR [eax+128]
	mov	DWORD PTR [edi+520], edx

; 1178 : 					m_PageHeight = m_Bitmap->Height;

	mov	eax, DWORD PTR [eax+132]
	mov	DWORD PTR [edi+516], eax
$LN1@RenderPage:

; 1179 : 				}
; 1180 : 				
; 1181 : 				////prerender next page
; 1182 : 				//PageMemory *nextBmp =GetBitmapCache(m_CurrentPage+1);
; 1183 : 				//if ((nextBmp==0 || (nextBmp && nextBmp->getRenderDPI() != m_renderDPI)) && 
; 1184 : 				//	(enableThread && m_CurrentPage+1 <= m_PDFDoc->getNumPages()))
; 1185 : 				//{
; 1186 : 				//	m_PageToRenderByThread = m_CurrentPage+1;
; 1187 : 
; 1188 : 				//	if(m_splashOut>0){
; 1189 : 				//		delete m_splashOut;
; 1190 : 				//		m_splashOut=0;
; 1191 : 				//	}
; 1192 : 				//	threadParam *tp = new threadParam(this, m_PageToRenderByThread);
; 1193 : 				//	tp->out=new AuxOutputDev(new SplashOutputDev(splashModeBGR8, 4, gFalse, paperColor,gTrue,globalParams->getAntialias()));
; 1194 : 				//	tp->out->startDoc(m_PDFDoc->getXRef());
; 1195 : 				//	tp->out->clearModRegion();
; 1196 : 				//	tp->enablePreRender=false;
; 1197 : 				//	ResetEvent(this->hRenderFinished);
; 1198 : 
; 1199 : 				//	InterlockedExchange(&this->g_lLocker,0);
; 1200 : 				//	m_renderingThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)AFPDFDoc::RenderingThread,(LPVOID)tp,CREATE_SUSPENDED,0);
; 1201 : 				//	//SetThreadPriority(m_renderingThread,THREAD_PRIORITY_BELOW_NORMAL);
; 1202 : 				//	ResumeThread(m_renderingThread);
; 1203 : 				//	
; 1204 : 				//}else
; 1205 : 					m_renderingThread=0;
; 1206 : 				
; 1207 : 				m_LastRenderDPI = m_renderDPI;

	fld	QWORD PTR [edi+536]

; 1208 : 				m_LastPageRendered=m_CurrentPage;

	mov	ecx, DWORD PTR [edi+504]
	fstp	QWORD PTR [edi+528]
	mov	DWORD PTR [edi+240], ebx
	mov	DWORD PTR [edi+508], ecx
__tryend$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z$1:

; 1212 : 			}
; 1213 : 		}
; 1214 : 		return 0;

	xor	eax, eax

; 1215 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z$0:

; 1209 : 
; 1210 : 			} catch(void *){
; 1211 : 				return errOutOfMemory;

	mov	eax, $LN31@RenderPage
	ret	0
$LN31@RenderPage:
	mov	eax, 10001				; 00002711H

; 1215 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z$3:
	mov	eax, DWORD PTR $T193155[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z$4:
	mov	eax, DWORD PTR $T193157[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RenderPage@AFPDFDoc@@QAEJJ_N0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RenderPage@AFPDFDoc@@QAEJJ_N0@Z ENDP			; AFPDFDoc::RenderPage
PUBLIC	?RenderPage@AFPDFDoc@@QAEJJ_N@Z			; AFPDFDoc::RenderPage
; Function compile flags: /Ogtpy
;	COMDAT ?RenderPage@AFPDFDoc@@QAEJJ_N@Z
_TEXT	SEGMENT
?RenderPage@AFPDFDoc@@QAEJJ_N@Z PROC			; AFPDFDoc::RenderPage, COMDAT
; _this$ = ecx
; _bForce$ = eax

; 1094 : 		return RenderPage(lhWnd,bForce,true);

	push	eax
	call	?RenderPage@AFPDFDoc@@QAEJJ_N0@Z	; AFPDFDoc::RenderPage

; 1095 : 	}

	ret	0
?RenderPage@AFPDFDoc@@QAEJJ_N@Z ENDP			; AFPDFDoc::RenderPage
_TEXT	ENDS
PUBLIC	?RenderPage@AFPDFDoc@@QAEJJ@Z			; AFPDFDoc::RenderPage
; Function compile flags: /Ogtpy
;	COMDAT ?RenderPage@AFPDFDoc@@QAEJJ@Z
_TEXT	SEGMENT
?RenderPage@AFPDFDoc@@QAEJJ@Z PROC			; AFPDFDoc::RenderPage, COMDAT
; _this$ = ecx

; 1090 : 		return RenderPage(lhWnd,false);

	push	0
	call	?RenderPage@AFPDFDoc@@QAEJJ_N0@Z	; AFPDFDoc::RenderPage

; 1091 : 	}

	ret	0
?RenderPage@AFPDFDoc@@QAEJJ@Z ENDP			; AFPDFDoc::RenderPage
_TEXT	ENDS
PUBLIC	?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z		; AFPDFDoc::RenderPageThread
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\auxoutputdev.cpp
xdata$x	SEGMENT
__unwindtable$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z$4
	DD	0ffffffffH
	DD	00H
__catchsym$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z$5 DD 00H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	FLAT:__catch$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z$0
__tryblocktable$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z DD 00H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z$5
__ehfuncinfo$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.cpp
xdata$x	ENDS
;	COMDAT ?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z
_TEXT	SEGMENT
tv692 = -44						; size = 8
$T193402 = -40						; size = 4
$T193318 = -40						; size = 4
_newbytes$85891 = -36					; size = 8
tv519 = -32						; size = 4
$T193316 = -32						; size = 4
$T193401 = -28						; size = 4
tv694 = -24						; size = 4
_exitcode$85899 = -24					; size = 4
tv697 = -20						; size = 2
_paperColor$85902 = -20					; size = 3
__$EHRec$ = -16						; size = 16
?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z PROC		; AFPDFDoc::RenderPageThread, COMDAT
; _this$ = ecx

; 916  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 917  : 		if (m_PDFDoc != NULL) {

	mov	eax, DWORD PTR [edi+332]
	xor	ebx, ebx
	cmp	eax, ebx
	je	__tryend$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z$1

; 918  : 
; 919  : 			if(m_splashOut!=0){

	mov	edx, DWORD PTR [edi+344]
	cmp	edx, ebx
	je	$LN7@RenderPage@2

; 920  : 				//Heuristically check if we have enough memory ;-)
; 921  : 				double newbytes = (m_renderDPI/72.0)*(m_renderDPI/72.0) * m_PDFDoc->getPageCropWidth(m_CurrentPage)* m_PDFDoc->getPageCropHeight(m_CurrentPage); //new approx. number of pixels

	fld	QWORD PTR [edi+536]
	mov	eax, DWORD PTR [eax+28]
	fdiv	QWORD PTR __real@4052000000000000
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [edi+504]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	fld	QWORD PTR [ecx+48]
	fsub	QWORD PTR [ecx+32]
	fld	ST(1)
	fmulp	ST(2), ST(0)

; 922  : 				newbytes = newbytes * 3 + newbytes*2; //24-bit splashbitmap, 16-bit gdi-bitmap
; 923  : 				newbytes=(newbytes*1.2); //Safety area;
; 924  : 				newbytes -= m_splashOut->GetWidth()*m_splashOut->GetHeight()*3; //substract old 24-bit splash bitmap size
; 925  : 				void* testAllocation = malloc((int)2.0*(int)newbytes);

	fnstcw	WORD PTR tv697[ebp]
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [eax+56]
	fsub	QWORD PTR [eax+40]
	movzx	eax, WORD PTR tv697[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv694[ebp], eax
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [edx+24]
	fld	QWORD PTR [edx+32]
	fld	ST(2)
	fld	QWORD PTR __real@4008000000000000
	fmul	ST(1), ST(0)
	fxch	ST(4)
	fadd	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR __real@3ff3333333333333
	fxch	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	fst	QWORD PTR _newbytes$85891[ebp]
	fldcw	WORD PTR tv694[ebp]
	fistp	QWORD PTR tv692[ebp]
	mov	ecx, DWORD PTR tv692[ebp]
	add	ecx, ecx
	push	ecx
	fldcw	WORD PTR tv697[ebp]
	call	DWORD PTR __imp__malloc
	mov	ecx, eax
	add	esp, 4

; 926  : 				if (testAllocation==0 && newbytes>0){

	cmp	ecx, ebx
	jne	SHORT $LN8@RenderPage@2
	fldz
	fcomp	QWORD PTR _newbytes$85891[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN8@RenderPage@2

; 927  : 					//We better dont zoom this far in!
; 928  : 					return errOutOfMemory+1;

	mov	eax, 10002				; 00002712H

; 988  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@RenderPage@2:

; 929  : 				} else {
; 930  : 					free (testAllocation);

	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN7@RenderPage@2:

; 931  : 				}
; 932  : 			}
; 933  : 			try{

	mov	DWORD PTR __$EHRec$[ebp+12], ebx

; 934  : 				//Wait for previous threads and delete them
; 935  : 				if (m_renderingThread!=0)

	mov	eax, DWORD PTR [edi+240]
	cmp	eax, ebx
	je	SHORT $LN5@RenderPage@2

; 936  : 				{					
; 937  : 					//ReleaseMutex(hgMutex);
; 938  : 					DWORD exitcode;
; 939  : 					::GetExitCodeThread(m_renderingThread,&exitcode);

	lea	edx, DWORD PTR _exitcode$85899[ebp]
	push	edx
	push	eax
	call	DWORD PTR __imp__GetExitCodeThread@8

; 940  : 					if(exitcode==STILL_ACTIVE){

	cmp	DWORD PTR _exitcode$85899[ebp], 259	; 00000103H
	jne	SHORT $LN4@RenderPage@2

; 941  : 						::InterlockedExchange(&this->g_lLocker,1);

	push	1
	lea	eax, DWORD PTR [edi+164]
	push	eax
	call	DWORD PTR __imp__InterlockedExchange@8

; 942  : 						WaitForSingleObject(this->hRenderFinished,INFINITE);

	mov	ecx, DWORD PTR [edi+176]
	push	-1
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN4@RenderPage@2:

; 943  : 					}
; 944  : 					//TerminateThread(m_renderingThread,0);
; 945  : 					CloseHandle(m_renderingThread);

	mov	edx, DWORD PTR [edi+240]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 946  : 					SetEvent(this->hRenderFinished);

	mov	eax, DWORD PTR [edi+176]
	push	eax
	call	DWORD PTR __imp__SetEvent@4

; 947  : 					m_renderingThread=NULL;

	mov	DWORD PTR [edi+240], ebx
$LN5@RenderPage@2:

; 948  : 				}
; 949  : 				m_PageRenderedByThread=true;
; 950  : 				//Establecemos el color del papel
; 951  : 				SplashColor paperColor;
; 952  : 				paperColor[0] = 0xff;
; 953  : 				paperColor[1] = 0xff;
; 954  : 				paperColor[2] = 0xff;
; 955  : 				
; 956  : 				m_PageHeight =(long)( m_PageHeight * m_renderDPI/m_LastRenderDPI);

	fild	DWORD PTR [edi+516]
	mov	al, 255					; 000000ffH
	mov	BYTE PTR [edi+168], 1
	mov	BYTE PTR _paperColor$85902[ebp], al
	fmul	QWORD PTR [edi+536]
	mov	BYTE PTR _paperColor$85902[ebp+1], al
	mov	BYTE PTR _paperColor$85902[ebp+2], al
	fdiv	QWORD PTR [edi+528]
	call	__ftol2_sse

; 957  : 				m_PageWidth  =(long)( m_PageWidth * m_renderDPI/m_LastRenderDPI);

	fild	DWORD PTR [edi+520]
	mov	esi, eax
	mov	DWORD PTR [edi+516], esi
	fmul	QWORD PTR [edi+536]
	fdiv	QWORD PTR [edi+528]
	call	__ftol2_sse

; 958  : 				m_Bitmap->Resize(m_PageWidth,m_PageHeight,m_renderDPI);

	fld	QWORD PTR [edi+536]
	mov	ecx, DWORD PTR [edi+352]
	mov	DWORD PTR [edi+520], eax
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR $T193402[ebp], esi
	mov	DWORD PTR $T193401[ebp], eax
	mov	DWORD PTR tv519[ebp], edx
	cmp	edx, eax
	jne	SHORT $LN52@RenderPage@2
	cmp	DWORD PTR [ecx+132], esi
	je	SHORT $LN75@RenderPage@2
$LN52@RenderPage@2:
	fild	DWORD PTR $T193401[ebp]
	fidiv	DWORD PTR tv519[ebp]
	fstp	DWORD PTR [ecx+8]
	fild	DWORD PTR $T193402[ebp]
	fidiv	DWORD PTR [ecx+132]
	fstp	DWORD PTR [ecx+12]
	fstp	QWORD PTR [ecx+16]
	jmp	SHORT $LN53@RenderPage@2
$LN75@RenderPage@2:
	fstp	ST(0)
$LN53@RenderPage@2:

; 959  : 
; 960  : 				//Run thread
; 961  : 				if (m_LastPageRenderedByThread != m_CurrentPage 
; 962  : 					|| m_LastRenderDPI!=m_renderDPI)

	mov	ecx, DWORD PTR [edi+504]
	cmp	DWORD PTR [edi+160], ecx
	jne	SHORT $LN2@RenderPage@2
	fld	QWORD PTR [edi+536]
	fcomp	QWORD PTR [edi+528]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	__tryend$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z$1
$LN2@RenderPage@2:

; 963  : 				{
; 964  : 					m_PageRenderedByThread=true;
; 965  : 					m_PageToRenderByThread = m_CurrentPage;
; 966  : 					
; 967  : 					if(m_splashOut>0){

	mov	esi, DWORD PTR [edi+344]
	mov	BYTE PTR [edi+168], 1
	mov	DWORD PTR [edi+156], ecx
	cmp	esi, ebx
	jbe	SHORT $LN1@RenderPage@2

; 968  : 						delete m_splashOut;

	call	??_GAuxOutputDev@@QAEPAXI@Z

; 969  : 						m_splashOut=0;

	mov	DWORD PTR [edi+344], ebx
$LN1@RenderPage@2:

; 970  : 					}
; 971  : 					threadParam *tp =new threadParam(this,m_PageToRenderByThread);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN15@RenderPage@2
	mov	ecx, DWORD PTR [edi+156]
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+8], 1
	mov	DWORD PTR [eax+12], ecx
	mov	ebx, eax
$LN15@RenderPage@2:

; 972  : 					//Note: the alignment is given by GDI requirements: bitmaps have to be 16-bit aligned.
; 973  : 					tp->out=new AuxOutputDev(new SplashOutputDev(splashModeBGR8, 4, gFalse, paperColor,gTrue,globalParams->getAntialias()));

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T193316[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN19@RenderPage@2
	push	248					; 000000f8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T193318[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	eax, ecx
	je	SHORT $LN17@RenderPage@2
	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	call	?getAntialias@GlobalParams@@QAEHXZ	; GlobalParams::getAntialias
	push	eax
	push	1
	lea	ecx, DWORD PTR _paperColor$85902[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T193318[ebp]
	push	0
	push	4
	push	3
	call	??0SplashOutputDev@@QAE@W4SplashColorMode@@HHPAEHH@Z ; SplashOutputDev::SplashOutputDev
	xor	ecx, ecx
	jmp	SHORT $LN18@RenderPage@2
$LN17@RenderPage@2:
	xor	eax, eax
$LN18@RenderPage@2:
	fldz
	mov	DWORD PTR [esi], OFFSET ??_7AuxOutputDev@@6B@
	fst	QWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], ecx
	fstp	QWORD PTR [esi+32]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	BYTE PTR [esi+40], 1
	mov	DWORD PTR [esi+44], ecx
	jmp	SHORT $LN20@RenderPage@2
$LN19@RenderPage@2:
	xor	esi, esi
$LN20@RenderPage@2:
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR [ebx+4], esi

; 974  : 					tp->out->startDoc(m_PDFDoc->getXRef());

	mov	edx, DWORD PTR [edi+332]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [esi+12]
	push	eax
	call	?startDoc@SplashOutputDev@@QAEXPAVXRef@@@Z ; SplashOutputDev::startDoc

; 975  : 					tp->out->clearModRegion();

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [eax+12]
	call	?clearModRegion@SplashOutputDev@@QAEXXZ	; SplashOutputDev::clearModRegion

; 976  : 					tp->enablePreRender=true;

	mov	BYTE PTR [ebx+8], 1

; 977  : 
; 978  : 					//m_splashOut=tp->out;
; 979  : 					ResetEvent(this->hRenderFinished);

	mov	ecx, DWORD PTR [edi+176]
	push	ecx
	call	DWORD PTR __imp__ResetEvent@4

; 980  : 					m_renderingThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)AFPDFDoc::RenderingThread,(LPVOID)tp,CREATE_SUSPENDED,0);

	push	0
	push	4
	push	ebx
	push	OFFSET ?RenderingThread@AFPDFDoc@@KAIPAX@Z ; AFPDFDoc::RenderingThread
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24

; 981  : 					ResumeThread(m_renderingThread);

	push	eax
	mov	DWORD PTR [edi+240], eax
	call	DWORD PTR __imp__ResumeThread@4
__tryend$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z$1:

; 985  : 			}
; 986  : 		}
; 987  : 		return 0;

	xor	eax, eax

; 988  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z$0:

; 982  : 				}
; 983  : 			} catch(void *){
; 984  : 				return errOutOfMemory;

	mov	eax, $LN27@RenderPage@2
	ret	0
$LN27@RenderPage@2:
	mov	eax, 10001				; 00002711H

; 988  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z$3:
	mov	eax, DWORD PTR $T193316[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z$4:
	mov	eax, DWORD PTR $T193318[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RenderPageThread@AFPDFDoc@@QAEJJ_N@Z ENDP		; AFPDFDoc::RenderPageThread
END
